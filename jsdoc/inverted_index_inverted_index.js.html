<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: inverted_index/inverted_index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: inverted_index/inverted_index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {Tokenizer} from './tokenizer';

/**
 * Inverted index class handles featured text search for specific document fields.
 * @constructor InvertedIndex
 * @param {object} options - a configuration object
 * @param {string|string[]} options.fields - string or array of field names to define featured text search for
 * @param {boolean} [options.store=true] - inverted index will be stored at serialization rather than rebuilt on load.
 */
export class InvertedIndex {
	constructor(fieldName) {
		this._fieldName = fieldName;
		this._docCount = 0;
		this._docStore = {};
		this._totalFieldLength = 0;
		this._tokenizer = new Tokenizer();
		this._root = {};
	}

	get documentCount() {
		return this._docCount;
	}

	get documentStore() {
		return this._docStore;
	}

	get totalFieldLength() {
		return this._totalFieldLength;
	}

	get fieldName() {
		return this._fieldName;
	}

	get tokenizer() {
		return this._tokenizer;
	}

	get root() {
		return this._root;
	}

	/**
	 * Adds defined fields of a document to the inverted index.
	 * @param {object} field - the field to add
	 * @param {number} [boost=1] - object with field (key) specific boost (value)
	 */
	insert(field, docId, boost = 1) {
		if (this._docStore.hasOwnProperty(docId)) {
			throw Error('Field already added.');
		}

		this._docCount += 1;
		this._docStore[docId] = {};

		// Tokenize document field.
		let fieldTokens = this._tokenizer.tokenize(field);
		this._totalFieldLength += fieldTokens.length;

		let termRefs = [];
		this._docStore[docId] = {fieldLength: fieldTokens.length, boost: boost};
		Object.defineProperties(this._docStore[docId], {
			termRefs: {enumerable: false, configurable: true, writable: true, value: termRefs}
		});

		// Iterate over all unique field terms.
		for (let term of new Set(fieldTokens)) {
			if (term === '') {
				continue;
			}
			// Calculate term frequency.
			let tf = 0;
			for (let j = 0; j &lt; fieldTokens.length; j++) {
				if (fieldTokens[j] == term) {
					tf++;
				}
			}

			// Add term to index tree.
			let branch = this._root;
			for (let i = 0; i &lt; term.length; i++) {
				let c = term[i];
				if (!branch.hasOwnProperty(c)) {
					let child = {};
					Object.defineProperties(child, {
						parent: {enumerable: false, configurable: true, writable: true, value: branch}
					});
					branch[c] = child;
				}
				branch = branch[c];
			}
			// Add term info to index leaf.
			if (!branch.hasOwnProperty('docs')) {
				branch.docs = {};
				branch.df = 0;
			}
			branch.docs[docId] = tf;
			branch.df += 1;

			// Store index leaf for deletion.
			termRefs.push(branch);
		}
	}

	/**
	 * Removes all relevant terms of a document from the inverted index.
	 * @param {number} docId - the document.
	 */
	remove(docId) {
		if (!this._docStore.hasOwnProperty(String(docId))) {
			return;
		}
		let docStore = this._docStore[docId];
		// Remove document.
		delete this._docStore[docId];
		this._docCount -= 1;

		// Reduce total field length.
		this._totalFieldLength -= docStore.fieldLength;

		// Iterate over all term references.
		// Remove docId from docs and decrement document frequency.
		let termRefs = docStore.termRefs;
		for (let j = 0; j &lt; termRefs.length; j++) {
			let index = termRefs[j];
			index.df -= 1;
			delete index.docs[docId];

			// Delete term branch if not used anymore.
			if (index.df === 0) {
				do {
					// Go tree upwards.
					let parent = index.parent;
					// Delete parent reference for preventing memory leak (cycle reference)
					delete index.parent;

					// Iterate over all children.
					var keys = Object.keys(parent);
					for (let k = 0; k &lt; keys.length; k++) {
						let key = keys[k];
						if (key === 'df' || key === 'docs') {
							continue;
						}
						// Remove previous child form parent.
						if (parent[key] === index) {
							delete parent[key];
							break;
						}
					}
					index = parent;
				} while (index.hasOwnProperty('parent') &amp;&amp; keys.length === 1);
			}
		}
	}

	/**
	 * Gets the term index of a term.
	 * @param {string} term - the term.
	 * @param {object} root - the term index to start from
	 * @param {number} start - the position of the term string to start from
	 * @return {object} - The term index or null if the term is not in the term tree.
	 */
	static getTermIndex(term, root, start = 0) {
		if (start >= term.length) {
			return null;
		}
		for (let i = start; i &lt; term.length; i++) {
			if (!root.hasOwnProperty(term[i])) {
				return null;
			}
			root = root[term[i]];
		}
		return root;
	}

	/**
	 * Extends a term index for the one branch.
	 * @param {object} root - the term index to start from
	 * @return {Array} - array with term indices and extension
	 */
	static getNextTermIndex(root) {
		let termIndices = [];
		let keys = Object.keys(root);
		for (let i = 0; i &lt; keys.length; i++) {
			if (keys[i] !== 'docs' &amp;&amp; keys[i] !== 'df') {
				termIndices.push({index: root[keys[i]], term: keys[i]});
			}
		}
		return termIndices;
	}

	/**
	 * Extends a term index to all available term leafs.
	 * @param {object} root - the term index to start from
	 * @returns {Array} - Array with term indices and extension
	 */
	static extendTermIndex(root) {
		let termIndices = [];
		let stack = [root];
		let treeStack = [''];
		do {
			let root = stack.pop();
			let treeTermn = treeStack.pop();

			if (root.hasOwnProperty('df')) {
				termIndices.push({index: root, term: treeTermn});
			}

			let keys = Object.keys(root);
			for (let i = 0; i &lt; keys.length; i++) {
				if (keys[i] !== 'docs' &amp;&amp; keys[i] !== 'df') {
					stack.push(root[keys[i]]);
					treeStack.push(treeTermn + keys[i]);
				}
			}
		} while (stack.length !== 0);

		return termIndices;
	}

	/**
	 * Serialize the inverted index.
	 * @returns {{docStore: *, _fields: *, index: *}}
	 */
	toJSON() {
		return this;
	}

	/**
	 * Deserialize the inverted index.
	 * @param {{docStore: *, _fields: *, index: *}} serialized - The serialized inverted index.
	 */
	loadJSON(serialized) {
		let dbObject = serialized;

		this._fieldName = dbObject._fieldName;
		this._docCount = dbObject._docCount;
		this._docStore = dbObject._docStore;
		this._totalFieldLength = dbObject._totalFieldLength;
		this._tokenizer = dbObject._tokenizer;
		this._root = dbObject._root;

		let self = this;

		function regenerate(index, parent) {
			// Set parent.
			if (parent !== null) {
				Object.defineProperties(index, {
					parent: {enumerable: false, configurable: true, writable: false, value: parent}
				});
			}

			// Iterate over all keys.
			let keys = Object.keys(index);
			for (let i = 0; i &lt; keys.length; i++) {
				// Found term, save in document store.
				if (keys[i] == 'docs') {
					// Get documents of term.
					let docIds = Object.keys(index.docs);
					for (let j = 0; j &lt; docIds.length; j++) {
						// Get document store at specific document/field.
						let ref = self._docStore[docIds[j]];
						if (!ref.hasOwnProperty('termRefs')) {
							Object.defineProperties(ref, {
								termRefs: {enumerable: false, configurable: true, writable: true, value: []}
							});
						}
						// Set reference to term index.
						ref.termRefs.push(index);
					}
				} else if (keys[i] != 'df') {
					// Iterate over subtree.
					regenerate(index[keys[i]], index);
				}
			}
		}

		regenerate(this._root, null);
	}
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BaseQuery.html">BaseQuery</a></li><li><a href="BoolQuery.html">BoolQuery</a></li><li><a href="Calculator.html">Calculator</a></li><li><a href="Collection.html">Collection</a></li><li><a href="ConstantScoreQuery.html">ConstantScoreQuery</a></li><li><a href="DynamicView.html">DynamicView</a></li><li><a href="ExistsQuery.html">ExistsQuery</a></li><li><a href="FuzzyQuery.html">FuzzyQuery</a></li><li><a href="IndexSearcher.html">IndexSearcher</a></li><li><a href="InvertedIndex.html">InvertedIndex</a></li><li><a href="Loki.html">Loki</a></li><li><a href="LokiEventEmitter.html">LokiEventEmitter</a></li><li><a href="LokiFsAdapter.html">LokiFsAdapter</a></li><li><a href="LokiLocalStorageAdapter.html">LokiLocalStorageAdapter</a></li><li><a href="MatchAllQuery.html">MatchAllQuery</a></li><li><a href="MatchQuery.html">MatchQuery</a></li><li><a href="PrefixQuery.html">PrefixQuery</a></li><li><a href="QueryBuilder.html">QueryBuilder</a></li><li><a href="Resultset.html">Resultset</a></li><li><a href="TermQuery.html">TermQuery</a></li><li><a href="TermsQuery.html">TermsQuery</a></li><li><a href="Tokenizer.html">Tokenizer</a></li><li><a href="WildcardQuery.html">WildcardQuery</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-Query.html">Query</a></li></ul><h3>Global</h3><ul><li><a href="global.html#asArrayOfString">asArrayOfString</a></li><li><a href="global.html#asBoolean">asBoolean</a></li><li><a href="global.html#asString">asString</a></li><li><a href="global.html#isBoolean">isBoolean</a></li><li><a href="global.html#isConvertibleToString">isConvertibleToString</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isNumber">isNumber</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isString">isString</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Feb 14 2017 22:54:44 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
