<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: inverted_index/index_searcher.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: inverted_index/index_searcher.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {Scorer} from './scorer';
import {InvertedIndex} from './inverted_index';
import {QueryBuilder} from './queries';

export class IndexSearcher {
	/**
	 *
	 * @param {object} invIdxs
	 */
	constructor(invIdxs, docs) {
		this._invIdxs = invIdxs;
		this._docs = docs;
		this._scorer = new Scorer(this._invIdxs);
	}

	search(query) {
		let docResults = this._recursive(query.query, true);

		// Final scoring.
		let finalScoring = query.hasOwnProperty("final_scoring") ? query.final_scoring : true;
		if (finalScoring) {
			return this._scorer.finalScore(query, docResults);
		}
		return docResults;
	}

	setDirty() {
		this._scorer.setDirty();
	}

	_recursive(query, doScoring) {
		let docResults = {};
		let boost = query.hasOwnProperty('boost') ? query.boost : 1;
		let fieldName = query.hasOwnProperty("field") ? query.field : null;

		let root = null;
		let tokenizer = null;
		if (this._invIdxs.hasOwnProperty(fieldName)) {
			root = this._invIdxs[fieldName].root;
			tokenizer = this._invIdxs[fieldName].tokenizer;
		}

		switch (query.type) {
			case "bool": {
				docResults = null;
				if (query.hasOwnProperty("must")) {
					docResults = this._getUnique(query.must.values, doScoring, docResults);
				}
				if (query.hasOwnProperty("filter")) {
					docResults = this._getUnique(query.filter.values, false, docResults);
				}

				if (query.hasOwnProperty("should")) {
					let shouldDocs = this._getAll(query.should.values, doScoring);

					let empty = false;
					if (docResults === null) {
						docResults = {};
						empty = true;
					}

					let msm = query.hasOwnProperty("minimum_should_match") ? query.minimum_should_match : 1;
					// Remove all docs with fewer matches.
					// TODO: Enable percent, negative values and ranges.
					let docs = Object.keys(shouldDocs);
					for (let i = 0, docId; i &lt; docs.length, docId = docs[i]; i++) {
						if (shouldDocs[docId].length >= msm) {
							if (docResults.hasOwnProperty(docId)) {
								docResults[docId].push(...shouldDocs[docId]);
							} else if (empty) {
								docResults[docId] = shouldDocs[docId];
							} else {
								delete docResults[docId];
							}
						}
					}
				}
				if (query.hasOwnProperty("not")) {
					let notDocs = this._getAll(query.not.values, false);
					// Remove all docs.
					let docs = Object.keys(notDocs);
					for (let i = 0, docId; i &lt; docs.length, docId = docs[i]; i++) {
						if (docResults.hasOwnProperty(docId)) {
							delete docResults[docId];
						}
					}
				}
				break;
			}
			case "term": {
				let termIdx = InvertedIndex.getTermIndex(query.value, root);
				this._scorer.prepare(fieldName, boost, termIdx, doScoring, docResults, query.value);
				break;
			}
			case "terms": {
				for (let i = 0; i &lt; query.value.length; i++) {
					let termIdx = InvertedIndex.getTermIndex(query.value[i], root);
					this._scorer.prepare(fieldName, boost, termIdx, doScoring, docResults, query.value[i]);
				}
				break;
			}
			case "fuzzy": {
				let f = new FuzzySearch(query);
				let b = f.search(root);
				for (let i = 0; i &lt; b.length; i++) {
					this._scorer.prepare(fieldName, boost * b[i].boost, b[i].index, doScoring, docResults, b[i].term);
				}
				break;
			}
			case "wildcard": {
				let w = new WildcardSearch(query);
				let a = w.search(root);
				for (let i = 0; i &lt; a.length; i++) {
					this._scorer.prepare(fieldName, boost, a[i].index, doScoring, docResults, a[i].term);
				}
				break;
			}
			case "match_all": {
				for (let docId of this._docs) {
					this._scorer.scoreConstant(boost, docId, docResults);
				}
				break;
			}
			case "constant_score": {
				docResults = this._getAll(query.filter.values, false);
				let docs = Object.keys(docResults);
				// Add to each document a constant score.
				for (let i = 0; i &lt; docs.length; i++) {
					this._scorer.scoreConstant(boost, docs[i], docResults);
				}
				break;
			}
			case "prefix": {
				let termIdx = InvertedIndex.getTermIndex(query.value, root);
				if (termIdx != null) {
					termIdx = InvertedIndex.extendTermIndex(termIdx);
				}
				for (let i = 0; i &lt; termIdx.length; i++) {
					this._scorer.prepare(fieldName, boost, termIdx[i].index, doScoring, docResults, query.value + termIdx[i].term);
				}
				break;
			}
			case "exists": {
				if (root != null) {
					let docs = Object.keys(this._invIdxs[fieldName].documentStore);
					for (let i = 0; i &lt; docs.length; i++) {
						this._scorer.scoreConstant(boost, docs[i], docResults);
					}
				}
				break;
			}
			case "match": {
				let terms = tokenizer.tokenize(query.value);
				let operator = query.hasOwnProperty("operator") ? query.operator : "or";

				let tmpQuery = new QueryBuilder().bool();
				if (operator === "or") {
					if (query.hasOwnProperty("minimum_should_match")) {
						tmpQuery = tmpQuery.minimumShouldMatch(query.minimum_should_match);
					}
					// Build a should query.
					tmpQuery = tmpQuery.startShould();
				} else {
					// Build a must query.
					tmpQuery = tmpQuery.startMust();
				}
				tmpQuery = tmpQuery.boost(boost);

				if (query.hasOwnProperty("fuzziness")) {
					let prefixLength = query.hasOwnProperty("prefix_length") ? query.prefix_length : 2;
					// Add each fuzzy.
					for (let i = 0; i &lt; terms.length; i++) {
						tmpQuery = tmpQuery.fuzzy(fieldName, terms[i]).fuzziness(query.fuzziness).prefixLength(prefixLength);
					}
				} else {
					// Add each term.
					for (let i = 0; i &lt; terms.length; i++) {
						tmpQuery = tmpQuery.term(fieldName, terms[i]);
					}
				}
				if (operator === "or") {
					tmpQuery = tmpQuery.endShould();
				} else {
					tmpQuery = tmpQuery.endMust();
				}

				docResults = this._recursive(tmpQuery.build(), doScoring);
				break;
			}
			default:
				break;
		}
		return docResults;
	}

	_getUnique(values, doScoring, docResults) {
		if (values.length === 0) {
			return docResults;
		}

		for (let i = 0; i &lt; values.length; i++) {
			let currDocs = this._recursive(values[i], doScoring);
			if (docResults === null) {
				docResults = this._recursive(values[0], doScoring);
				continue;
			}

			let docs = Object.keys(docResults);
			for (let j = 0, docId; j &lt; docs.length, docId = docs[j]; j++) {
				if (!currDocs.hasOwnProperty(docId)) {
					delete docResults[docId];
				} else {
					docResults[docId].push(...currDocs[docId]);
				}
			}
		}
		return docResults;
	}

	_getAll(values, doScoring) {
		let docResults = {};
		for (let i = 0; i &lt; values.length; i++) {
			let currDocs = this._recursive(values[i], doScoring);
			let docs = Object.keys(currDocs);
			for (let j = 0, docId; j &lt; docs.length, docId = docs[j]; j++) {
				if (!docResults.hasOwnProperty(docId)) {
					docResults[docId] = currDocs[docId];
				} else {
					docResults[docId].push(...currDocs[docId]);
				}
			}
		}
		return docResults;
	}
}


class FuzzySearch {
	constructor(query) {
		this._fuzzy = query.value;
		this._fuzziness = query.hasOwnProperty('fuzziness') ? query.fuzziness : 2;
		this._prefixLength = query.hasOwnProperty('prefix_length') ? query.prefix_length : 2;
	}

	/**
	 * Copyright Kigiri: https://github.com/kigiri
	 *                     Milot Mirdita: https://github.com/milot-mirdita
	 *                     Toni Neubert:  https://github.com/Viatorus/
	 */
	levenshtein_distance(a, b) {
		if (a.length === 0) return b.length;
		if (b.length === 0) return a.length;
		let tmp, i, j, prev, val;
		// swap to save some memory O(min(a,b)) instead of O(a)
		if (a.length > b.length) {
			tmp = a;
			a = b;
			b = tmp;
		}

		var row = Array(a.length + 1);
		// init the row
		for (i = 0; i &lt;= a.length; i++) {
			row[i] = i;
		}

		// fill in the rest
		for (i = 1; i &lt;= b.length; i++) {
			prev = i;
			for (j = 1; j &lt;= a.length; j++) {
				if (b[i - 1] === a[j - 1]) {	// match
					val = row[j - 1];
				} else {
					val = Math.min(row[j - 1] + 1, // substitution
						Math.min(prev + 1,         // insertion
							row[j] + 1));          // deletion

					// transposition.
					if (i > 1 &amp;&amp; j > 1 &amp;&amp; b[i - 2] === a[j - 1] &amp;&amp; a[j - 2] === b[i - 1]) {
						val = Math.min(val, row[j - 1] - (a[j - 1] === b[i - 1] ? 1 : 0));
					}
				}
				row[j - 1] = prev;
				prev = val;
			}
			row[a.length] = prev;
		}
		return row[a.length];
	}

	/**
	 * Performs a fuzzy search for a given term.
	 * @param {string} query - a fuzzy term to match.
	 * @param {number} [maxDistance=2] - maximal edit distance between terms
	 * @returns {Array} - array with all matching term indices.
	 */
	search(root) {
		// Todo: Include levenshtein to reduce similar iterations.
		// Tree tokens at same depth share same row until depth (should works if recursive).
		// Pregenerate tree token ?
		//var treeToken = Array(token.length + maxDistance);

		let start = root;
		let pre = this._fuzzy.slice(0, this._prefixLength);
		let fuzzy = this._fuzzy;
		if (this._prefixLength != 0) {
			start = InvertedIndex.getTermIndex(pre, start);
			fuzzy = fuzzy.slice(this._prefixLength);
		}
		if (start === null) {
			return [];
		}

		let similarTokens = [];

		let stack = [start];
		let treeStack = [''];
		do {
			let root = stack.pop();
			let treeTerms = treeStack.pop();

			// Compare tokens if they are in near distance.
			if (root.hasOwnProperty('df') &amp;&amp; Math.abs(fuzzy.length - treeTerms.length) &lt;= this._fuzziness) {
				const distance = this.levenshtein_distance(fuzzy, treeTerms);
				if (distance &lt;= this._fuzziness) {
					// Calculate boost.
					let boost = 1 - distance / (pre.length + treeTerms.length);
					similarTokens.push({term: pre + treeTerms, index: root, boost: boost});
				}
			}

			// Iterate over all subtrees.
			// If token from tree is not longer than maximal distance.
			if (treeTerms.length - fuzzy.length &lt;= this._fuzziness) {
				// Iterate over all subtrees.
				let keys = Object.keys(root);
				for (let i = 0; i &lt; keys.length; i++) {
					if (keys[i] !== 'docs' &amp;&amp; keys[i] !== 'df') {
						stack.push(root[keys[i]]);
						treeStack.push(treeTerms + keys[i]);
					}
				}
			}
		} while (stack.length !== 0);

		return similarTokens;
	}
}

class WildcardSearch {

	constructor(query) {
		this._wildcard = query.value;
		this._result = [];
	}

	/**
	 * Performs a wild card search for a given query term.
	 * @param {string} query - a wild card query to match.
	 * @returns {Array} - array with all matching term indices.
	 */
	search(root) {
		// Todo: Need an implementation for star operator.
		this._result = [];
		this._recursive(root);
		return this._result;
	}

	/**
	 *
	 * @param root
	 * @param idx
	 * @param term
	 * @param escaped
	 * @private
	 */
	_recursive(root, idx = 0, term = '', escaped = false) {
		if (root === null) {
			return;
		}

		if (idx === this._wildcard.length) {
			if (root.hasOwnProperty('df')) {
				this._result.push({index: root, term: term});
			}
			return;
		}

		if (!escaped &amp;&amp; this._wildcard[idx] === '\\') {
			this._recursive(root, idx + 1, term, true);
		} else if (!escaped &amp;&amp; this._wildcard[idx] === '?') {
			let others = InvertedIndex.getNextTermIndex(root);
			for (let i = 0; i &lt; others.length; i++) {
				this._recursive(others[i].index, idx + 1, term + others[i].term);
			}
		} else {
			this._recursive(InvertedIndex.getTermIndex(this._wildcard[idx], root), idx + 1, term + this._wildcard[idx]);
		}
	}
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BaseQuery.html">BaseQuery</a></li><li><a href="BoolQuery.html">BoolQuery</a></li><li><a href="Calculator.html">Calculator</a></li><li><a href="Collection.html">Collection</a></li><li><a href="ConstantScoreQuery.html">ConstantScoreQuery</a></li><li><a href="DynamicView.html">DynamicView</a></li><li><a href="ExistsQuery.html">ExistsQuery</a></li><li><a href="FuzzyQuery.html">FuzzyQuery</a></li><li><a href="IndexSearcher.html">IndexSearcher</a></li><li><a href="InvertedIndex.html">InvertedIndex</a></li><li><a href="Loki.html">Loki</a></li><li><a href="LokiEventEmitter.html">LokiEventEmitter</a></li><li><a href="LokiFsAdapter.html">LokiFsAdapter</a></li><li><a href="LokiLocalStorageAdapter.html">LokiLocalStorageAdapter</a></li><li><a href="MatchAllQuery.html">MatchAllQuery</a></li><li><a href="MatchQuery.html">MatchQuery</a></li><li><a href="PrefixQuery.html">PrefixQuery</a></li><li><a href="QueryBuilder.html">QueryBuilder</a></li><li><a href="Resultset.html">Resultset</a></li><li><a href="TermQuery.html">TermQuery</a></li><li><a href="TermsQuery.html">TermsQuery</a></li><li><a href="Tokenizer.html">Tokenizer</a></li><li><a href="WildcardQuery.html">WildcardQuery</a></li></ul><h3>Tutorials</h3><ul><li><a href="tutorial-Query.html">Query</a></li></ul><h3>Global</h3><ul><li><a href="global.html#asArrayOfString">asArrayOfString</a></li><li><a href="global.html#asBoolean">asBoolean</a></li><li><a href="global.html#asString">asString</a></li><li><a href="global.html#isBoolean">isBoolean</a></li><li><a href="global.html#isConvertibleToString">isConvertibleToString</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isNumber">isNumber</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isString">isString</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Tue Feb 14 2017 22:54:44 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
