{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap f5810fa7ab702cb596e8","webpack:///./src/core/event_emitter.js","webpack:///./src/core/collection.js","webpack:///./src/core/utils.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/core/clone.js","webpack:///./src/core/helper.js","webpack:///./src/core/loki.js","webpack:///./src/core/resultset.js","webpack:///./src/core/fs_adapter.js","webpack:///./src/core/local_storage_adapter.js","webpack:///./src/core/memory_adapter.js","webpack:///./src/core/dynamic_view.js","webpack:///./src/core/exact_index.js","webpack:///./src/core/unique_index.js","webpack:///external \"fs\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;AChEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB,cAAc,IAAI;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;;AAEA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AC3GyB;AACL;AACD;AACD;AACE;AACY;AACM;AACzB;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,IAAI,uEAAuE;AACtF,SAAS,yBAAyB;AAClC;AACA;;AAEA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB,0BAA0B;AAC1B;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,WAAW;AAC5B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,SAAS;AAClB;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,YAAY;AAC1B;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,eAAe;AAC3B,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB,qBAAqB;;AAErB;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE,+BAA+B;AACrG,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,IAAI;AAChB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;;AAEA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,cAAc;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,cAAc,UAAU;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C,uBAAuB,cAAc,uBAAuB;AACvG,cAAc;AACd,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,SAAS;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,UAAU;AACtB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;ACphEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AClDA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;ACpBA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO,QAAQ;AACf;AACA;;AAEA;AACA;;;;;;;;;;ACjDA;AAAA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,GAAG,IAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;ACnSyB;;AAEC;AACJ;AACU;AACb;AACI;;AAEvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA,sDAAsD;;AAEtD;AACA;AACA,qBAAqB;AACrB,KAAK;AACL;AACA;AACA;;AAEA,yDAAyD;;AAEzD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA,cAAc,QAAQ;AACtB;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,kBAAkB;AAClB;AACA,gDAAgD,UAAU;AAC1D;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,IAAI,uEAAuE;AACvF,cAAc,WAAW;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,WAAW;AACzB;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA,yGAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA,cAAc,OAAO;AACrB;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB;AACA,cAAc,aAAa;AAC3B;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA,eAAe,iCAAiC;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,QAAQ;AACpB,YAAY,IAAI;AAChB;AACA,cAAc,aAAa;AAC3B;AACA,iCAAiC;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB;AACA,cAAc,aAAa;AAC3B;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2EAA2E;AAC3E,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC;AACnC,6FAA6F;;AAE7F;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA,cAAc,MAAM;AACpB;AACA,uDAAuD;AACvD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS,SAAS;AAClB;AACA,6CAA6C,0CAA0C;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA,IAAI;;AAEJ,WAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,KAAK;AACjB,YAAY,IAAI;AAChB,cAAc,QAAQ;AACtB;AACA,gCAAgC;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,KAAK;AACjB,YAAY,IAAI;AAChB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,4EAA4E,4BAA4B;AACxG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;ACtqCc;AACK;AACY;AACO;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF,oBAAoB,eAAe,oBAAoB;AACvD;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,IAAI,mCAAmC;AACnD,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC,uBAAuB,QAAQ;AAC/B,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,wBAAwB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,YAAY,SAAS;AACrB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC;AACA;;;AAGA;AACA;AACA;AACA,YAAY,SAAS;AACrB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA,YAAY,OAAO;AACnB;AACA,YAAY,KAAK;AACjB;AACA,cAAc,MAAM;AACpB;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;AAC9B,YAAY,UAAU,0HAA0H;AAChJ,cAAc,UAAU,uCAAuC,+BAA+B;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;AAAA;;;;;;;;ACnrCA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AAAA;AAAA;;;;;;;;;ACpFA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AAAA;AAAA;;;;;;;;ACjEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,IAAI;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;;;;;;;;;;AC5GyB;AACP;;AAElB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,mBAAmB,cAAc;AACjC,kCAAkC,8BAA8B,EAAE;AAClE;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,SAAS,gCAAgC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,QAAQ;AACpB,cAAc,UAAU;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,SAAS;AACrB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,cAAc,OAAO,iDAAiD;AACtE;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,WAAW;AACpD;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,oCAAoC;AACpC,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,iBAAiB;AAC7B,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,iBAAiB;AAC7B,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AAAA;AAAA;;;;;;;;ACpvBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACxCA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;AC1DA,gD","file":"loki.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"fs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"fs\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"fs\")) : factory(root[\"fs\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_14__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f5810fa7ab702cb596e8","/*\n 'listen' is not defined  no-undef\n */\n\n/**\n * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n * constructor that inherits EventEmitter to emit events and trigger\n * listeners that have been added to the event through the on(event, callback) method\n *\n * @constructor LokiEventEmitter\n */\nexport class LokiEventEmitter {\n\n\tconstructor() {\n\t\t/**\n\t\t * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.events = {};\n\n\t\t/**\n\t\t * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n\t\t * should happen in an async fashion or not\n\t\t * Default is false, which means events are synchronous\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.asyncListeners = false;\n\t}\n\n\t/**\n\t * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\ton(eventName, listener) {\n\t\tlet event;\n\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach((currentEventName) => {\n\t\t\t\tthis.on(currentEventName, listener);\n\t\t\t});\n\t\t\treturn listener;\n\t\t}\n\n\t\tevent = this.events[eventName];\n\t\tif (!event) {\n\t\t\tevent = this.events[eventName] = [];\n\t\t}\n\t\tevent.push(listener);\n\t\treturn listener;\n\t}\n\n\t/**\n\t * emit(eventName, data) - emits a particular event\n\t * with the option of passing optional parameters which are going to be processed by the callback\n\t * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n\t * @param {string} eventName - the name of the event\n\t * @param {object=} data - optional object passed with the event\n\t * @memberof LokiEventEmitter\n\t */\n\temit(eventName, data) {\n\t\tif (eventName && this.events[eventName]) {\n\t\t\tthis.events[eventName].forEach((listener) => {\n\t\t\t\tif (this.asyncListeners) {\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tlistener(data);\n\t\t\t\t\t}, 1);\n\t\t\t\t} else {\n\t\t\t\t\tlistener(data);\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Alias of LokiEventEmitter.prototype.on\n\t * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\taddListener(eventName, listener) {\n\t\treturn this.on(eventName, listener);\n\t}\n\n\t/**\n\t * removeListener() - removes the listener at position 'index' from the event 'eventName'\n\t * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n\t * @param {function} listener - the listener callback function to remove from emitter\n\t * @memberof LokiEventEmitter\n\t */\n\tremoveListener(eventName, listener) {\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach((currentEventName) => {\n\t\t\t\tthis.removeListener(currentEventName, listen);\n\t\t\t});\n\t\t}\n\n\t\tif (this.events[eventName]) {\n\t\t\tconst listeners = this.events[eventName];\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t}\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/event_emitter.js\n// module id = 0\n// module chunks = 0","import {LokiEventEmitter} from './event_emitter';\nimport {UniqueIndex} from './unique_index';\nimport {ExactIndex} from './exact_index';\nimport {Resultset} from './resultset';\nimport {DynamicView} from './dynamic_view';\nimport {clone, cloneObjectArray} from './clone';\nimport {ltHelper, gtHelper, aeqHelper} from './helper';\nimport {Loki} from './loki';\n\n/*\n 'isDeepProperty' is not defined              no-undef\n 'deepProperty' is not defined                no-undef\n 'average' is not defined                     no-undef\n 'standardDeviation' is not defined           no-undef\n 'sub' is not defined                         no-undef\n\n byExample?\n indexing -> own class?\n remove data only?\n */\n\n/**\n * General utils, including statistical functions\n */\nfunction isDeepProperty(field) {\n\treturn field.indexOf('.') !== -1;\n}\n\nfunction parseBase10(num) {\n\treturn parseFloat(num, 10);\n}\n\nfunction add(a, b) {\n\treturn a + b;\n}\n\nfunction sub(a, b) {\n\treturn a - b;\n}\n\nfunction average(array) {\n\treturn (array.reduce(add, 0)) / array.length;\n}\n\nfunction standardDeviation(values) {\n\tconst avg = average(values);\n\tconst squareDiffs = values.map((value) => {\n\t\tconst diff = value - avg;\n\t\tconst sqrDiff = diff * diff;\n\t\treturn sqrDiff;\n\t});\n\n\tconst avgSquareDiff = average(squareDiffs);\n\n\tconst stdDev = Math.sqrt(avgSquareDiff);\n\treturn stdDev;\n}\n\nfunction deepProperty(obj, property, isDeep) {\n\tif (isDeep === false) {\n\t\t// pass without processing\n\t\treturn obj[property];\n\t}\n\tconst pieces = property.split('.');\n\tlet root = obj;\n\twhile (pieces.length > 0) {\n\t\troot = root[pieces.shift()];\n\t}\n\treturn root;\n}\n\n/**\n * Collection class that handles documents of same type\n * @constructor Collection\n * @implements LokiEventEmitter\n * @param {string} name - collection name\n * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n * @param {array} options.unique - array of property names to define unique constraints for\n * @param {array} options.exact - array of property names to define exact constraints for\n * @param {array} options.indices - array property names to define binary indexes for\n * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily (default: true)\n * @param {boolean} options.asyncListeners - default is false\n * @param {boolean} options.disableChangesApi - default is true\n * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n * @param {boolean} options.serializableIndices  - ensures indexed property values are serializable (default: true)\n * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n * @see {@link Loki#addCollection} for normal creation of collections\n */\nexport class Collection extends LokiEventEmitter {\n\n\tconstructor(name, options = {}) {\n\t\tsuper();\n\t\t// the name of the collection\n\n\t\tthis.name = name;\n\t\t// the data held by the collection\n\t\tthis.data = [];\n\t\tthis.idIndex = []; // index of id\n\t\tthis.binaryIndices = {}; // user defined indexes\n\t\tthis.constraints = {\n\t\t\tunique: {},\n\t\t\texact: {}\n\t\t};\n\n\t\t// unique contraints contain duplicate object references, so they are not persisted.\n\t\t// we will keep track of properties which have unique contraint applied here, and regenerate on load\n\t\tthis.uniqueNames = [];\n\n\t\t// transforms will be used to store frequently used query chains as a series of steps\n\t\t// which itself can be stored along with the database.\n\t\tthis.transforms = {};\n\n\t\t// the object type of the collection\n\t\tthis.objType = name;\n\n\t\t// in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n\t\t// currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n\t\t// defaulting to true since this is called from addCollection and adding a collection should trigger save\n\t\tthis.dirty = true;\n\n\t\t// private holders for cached data\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\n\t\t/* OPTIONS */\n\t\t// exact match and unique constraints\n\t\tif (options.unique !== undefined) {\n\t\t\tif (!Array.isArray(options.unique)) {\n\t\t\t\toptions.unique = [options.unique];\n\t\t\t}\n\t\t\toptions.unique.forEach((prop) => {\n\t\t\t\tthis.uniqueNames.push(prop); // used to regenerate on subsequent database loads\n\t\t\t\tthis.constraints.unique[prop] = new UniqueIndex(prop);\n\t\t\t});\n\t\t}\n\n\t\tif (options.exact !== undefined) {\n\t\t\toptions.exact.forEach((prop) => {\n\t\t\t\tthis.constraints.exact[prop] = new ExactIndex(prop);\n\t\t\t});\n\t\t}\n\n\t\t// Inverted index\n\t\tthis._fullTextSearch = null;\n\t\tif (Loki.FullTextSearch !== undefined) {\n\t\t\tthis._fullTextSearch = options.fullTextSearch !== undefined\n\t\t\t\t? new (Loki.FullTextSearch.FullTextSearch)(options.fullTextSearch) : null;\n\t\t}\n\n\t\t// if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n\t\t// if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n\t\tthis.adaptiveBinaryIndices = options.adaptiveBinaryIndices !== undefined ? options.adaptiveBinaryIndices : true;\n\n\t\t// is collection transactional\n\t\tthis.transactional = options.transactional !== undefined ? options.transactional : false;\n\n\t\t// options to clone objects when inserting them\n\t\tthis.cloneObjects = options.clone !== undefined ? options.clone : false;\n\n\t\t// default clone method (if enabled) is parse-stringify\n\t\tthis.cloneMethod = options.cloneMethod !== undefined ? options.cloneMethod : \"parse-stringify\";\n\n\t\t// option to make event listeners async, default is sync\n\t\tthis.asyncListeners = options.asyncListeners !== undefined ? options.asyncListeners : false;\n\n\t\t// disable track changes\n\t\tthis.disableChangesApi = options.disableChangesApi !== undefined ? options.disableChangesApi : true;\n\n\t\t// option to observe objects and update them automatically, ignored if Object.observe is not supported\n\t\tthis.autoupdate = options.autoupdate !== undefined ? options.autoupdate : false;\n\n\t\t// by default, if you insert a document into a collection with binary indices, if those indexed properties contain\n\t\t// a DateTime we will convert to epoch time format so that (across serializations) its value position will be the\n\t\t// same 'after' serialization as it was 'before'.\n\t\tthis.serializableIndices = options.serializableIndices !== undefined ? options.serializableIndices : true;\n\n\t\t//option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n\t\tthis.ttl = {\n\t\t\tage: null,\n\t\t\tttlInterval: null,\n\t\t\tdaemon: null\n\t\t};\n\t\tthis.setTTL(options.ttl || -1, options.ttlInterval);\n\n\t\t// currentMaxId - change manually at your own peril!\n\t\tthis.maxId = 0;\n\n\t\tthis.DynamicViews = [];\n\n\t\t// events\n\t\tthis.events = {\n\t\t\t'insert': [],\n\t\t\t'update': [],\n\t\t\t'pre-insert': [],\n\t\t\t'pre-update': [],\n\t\t\t'close': [],\n\t\t\t'flushbuffer': [],\n\t\t\t'error': [],\n\t\t\t'delete': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\t// changes are tracked by collection and aggregated by the db\n\t\tthis.changes = [];\n\n\t\t// initialize the id index\n\t\tthis.ensureId();\n\t\tlet indices = [];\n\t\t// initialize optional user-supplied indices array ['age', 'lname', 'zip']\n\t\tif (options && options.indices) {\n\t\t\tif (Object.prototype.toString.call(options.indices) === '[object Array]') {\n\t\t\t\tindices = options.indices;\n\t\t\t} else if (typeof options.indices === 'string') {\n\t\t\t\tindices = [options.indices];\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Indices needs to be a string or an array of strings');\n\t\t\t}\n\t\t}\n\n\t\tfor (let idx = 0; idx < indices.length; idx++) {\n\t\t\tthis.ensureIndex(indices[idx]);\n\t\t}\n\n\t\tfunction observerCallback(changes) {\n\n\t\t\tconst changedObjects = typeof Set === 'function' ? new Set() : [];\n\n\t\t\tif (!changedObjects.add)\n\t\t\t\tchangedObjects.add = function (object) {\n\t\t\t\t\tif (this.indexOf(object) === -1)\n\t\t\t\t\t\tthis.push(object);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\n\t\t\tchanges.forEach((change) => {\n\t\t\t\tchangedObjects.add(change.object);\n\t\t\t});\n\n\t\t\tchangedObjects.forEach((object) => {\n\t\t\t\tif (object.$loki === undefined)\n\t\t\t\t\treturn this.removeAutoUpdateObserver(object);\n\t\t\t\ttry {\n\t\t\t\t\tthis.update(object);\n\t\t\t\t} catch (err) {\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.observerCallback = observerCallback;\n\n\t\tconst self = this;\n\t\t/*\n\t\t * This method creates a clone of the current status of an object and associates operation and collection name,\n\t\t * so the parent db can aggregate and generate a changes object for the entire db\n\t\t */\n\t\tfunction createChange(name, op, obj) {\n\t\t\tself.changes.push({\n\t\t\t\tname,\n\t\t\t\toperation: op,\n\t\t\t\tobj: JSON.parse(JSON.stringify(obj))\n\t\t\t});\n\t\t}\n\n\t\t// clear all the changes\n\t\tfunction flushChanges() {\n\t\t\tself.changes = [];\n\t\t}\n\n\t\tthis.getChanges = () => this.changes;\n\n\t\tthis.flushChanges = flushChanges;\n\n\t\t/**\n\t\t * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled\n\t\t */\n\t\tfunction insertMeta(obj) {\n\t\t\tlet len;\n\t\t\tlet idx;\n\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if batch insert\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\tlen = obj.length;\n\n\t\t\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\t\t\tif (obj[idx].meta === undefined) {\n\t\t\t\t\t\tobj[idx].meta = {};\n\t\t\t\t\t}\n\n\t\t\t\t\tobj[idx].meta.created = (new Date()).getTime();\n\t\t\t\t\tobj[idx].meta.revision = 0;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// single object\n\t\t\tif (!obj.meta) {\n\t\t\t\tobj.meta = {};\n\t\t\t}\n\n\t\t\tobj.meta.created = (new Date()).getTime();\n\t\t\tobj.meta.revision = 0;\n\t\t}\n\n\t\tfunction updateMeta(obj) {\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tobj.meta.updated = (new Date()).getTime();\n\t\t\tobj.meta.revision += 1;\n\t\t}\n\n\t\tfunction createInsertChange(obj) {\n\t\t\tcreateChange(self.name, 'I', obj);\n\t\t}\n\n\t\tfunction createUpdateChange(obj) {\n\t\t\tcreateChange(self.name, 'U', obj);\n\t\t}\n\n\t\tfunction insertMetaWithChange(obj) {\n\t\t\tinsertMeta(obj);\n\t\t\tcreateInsertChange(obj);\n\t\t}\n\n\t\tfunction updateMetaWithChange(obj) {\n\t\t\tupdateMeta(obj);\n\t\t\tcreateUpdateChange(obj);\n\t\t}\n\n\n\t\t/* assign correct handler based on ChangesAPI flag */\n\t\tlet insertHandler;\n\n\t\tlet updateHandler;\n\n\t\tfunction setHandlers() {\n\t\t\tinsertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;\n\t\t\tupdateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;\n\t\t}\n\n\t\tsetHandlers();\n\n\t\tthis.setChangesApi = (enabled) => {\n\t\t\tthis.disableChangesApi = !enabled;\n\t\t\tsetHandlers();\n\t\t};\n\t\t/**\n\t\t * built-in events\n\t\t */\n\t\tthis.on('insert', (obj) => {\n\t\t\tinsertHandler(obj);\n\t\t});\n\n\t\tthis.on('update', (obj) => {\n\t\t\tupdateHandler(obj);\n\t\t});\n\n\t\tthis.on('delete', (obj) => {\n\t\t\tif (!this.disableChangesApi) {\n\t\t\t\tcreateChange(this.name, 'R', obj);\n\t\t\t}\n\t\t});\n\n\t\tthis.on('warning', (warning) => {\n\t\t\tthis.console.warn(warning);\n\t\t});\n\t\t// for de-serialization purposes\n\t\tflushChanges();\n\n\t\tthis.console = {\n\t\t\tlog() {\n\t\t\t},\n\t\t\twarn() {\n\t\t\t},\n\t\t\terror() {\n\t\t\t},\n\t\t};\n\n\t\t/* ------ STAGING API -------- */\n\t\t/**\n\t\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t\t * manipulated without affecting the data in the original collection\n\t\t */\n\t\tthis.stages = {};\n\t\tthis.commitLog = [];\n\t}\n\n\t/*toJSON() {\n\t\treturn {\n\t\t\tDynamicViews: this.DynamicViews,\n\t\t\tuniqueNames: this.uniqueNames,\n\t\t\ttransforms: this.transforms,\n\t\t\tbinaryIndices: this.binaryIndices,\n\t\t\tdata: this.data,\n\t\t\tidIndex: this.idIndex,\n\t\t\tmaxId: this.maxId,\n\t\t\tdirty: this.dirty,\n\t\t\tadaptiveBinaryIndices: this.adaptiveBinaryIndices,\n\t\t\ttransactional: this.transactional,\n\t\t\tasyncListeners: this.asyncListeners,\n\t\t\tdisableChangesApi: this.disableChangesApi,\n\t\t\tcloneObjects: this.cloneObjects,\n\t\t\tcloneMethod: this.cloneMethod,\n\t\t\tautoupdate: this.autoupdate,\n\t\t\tchanges: this.changes,\n\t\t};\n\t}*/\n\n\taddAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n\t}\n\n\tremoveAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.unobserve(object, this.observerCallback);\n\t}\n\n\t/**\n\t * Adds a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {array} transform - an array of transformation 'step' objects to save into the collection\n\t * @memberof Collection\n\t */\n\taddTransform(name, transform) {\n\t\tif (this.transforms[name] !== undefined) {\n\t\t\tthrow new Error(\"a transform by that name already exists\");\n\t\t}\n\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Updates a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {object} transform - a transformation object to save into collection\n\t * @memberof Collection\n\t */\n\tsetTransform(name, transform) {\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Removes a named collection transform from the collection\n\t * @param {string} name - name of collection transform to remove\n\t * @memberof Collection\n\t */\n\tremoveTransform(name) {\n\t\tdelete this.transforms[name];\n\t}\n\n\tbyExample(template) {\n\t\tlet k;\n\t\tlet obj;\n\t\tlet query;\n\t\tquery = [];\n\t\tfor (k in template) {\n\t\t\tif (template[k] === undefined) continue;\n\t\t\tquery.push((\n\t\t\t\tobj = {},\n\t\t\t\t\tobj[k] = template[k],\n\t\t\t\t\tobj\n\t\t\t));\n\t\t}\n\t\treturn {\n\t\t\t'$and': query\n\t\t};\n\t}\n\n\tfindObject(template) {\n\t\treturn this.findOne(this.byExample(template));\n\t}\n\n\tfindObjects(template) {\n\t\treturn this.find(this.byExample(template));\n\t}\n\n\t/*----------------------------+\n\t | TTL daemon                  |\n\t +----------------------------*/\n\tttlDaemonFuncGen() {\n\t\tconst collection = this;\n\t\tconst age = this.ttl.age;\n\t\treturn function ttlDaemon() {\n\t\t\tconst now = Date.now();\n\t\t\tconst toRemove = collection.chain().where(function daemonFilter(member) {\n\t\t\t\tconst timestamp = member.meta.updated || member.meta.created;\n\t\t\t\tconst diff = now - timestamp;\n\t\t\t\treturn age < diff;\n\t\t\t});\n\t\t\ttoRemove.remove();\n\t\t};\n\t}\n\n\tsetTTL(age, interval) {\n\t\tif (age < 0) {\n\t\t\tclearInterval(this.ttl.daemon);\n\t\t} else {\n\t\t\tthis.ttl.age = age;\n\t\t\tthis.ttl.ttlInterval = interval;\n\t\t\tthis.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n\t\t}\n\t}\n\n\t/*----------------------------+\n\t | INDEXING                    |\n\t +----------------------------*/\n\n\t/**\n\t * create a row filter that covers all documents in the collection\n\t */\n\tprepareFullDocIndex() {\n\t\tconst len = this.data.length;\n\t\tconst indexes = new Array(len);\n\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\tindexes[i] = i;\n\t\t}\n\t\treturn indexes;\n\t}\n\n\t/**\n\t * Will allow reconfiguring certain collection options.\n\t * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n\t * @memberof Collection\n\t */\n\tconfigureOptions(options) {\n\t\toptions = options || {};\n\n\t\tif (options.adaptiveBinaryIndices !== undefined) {\n\t\t\tthis.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\n\t\t\t// if switching to adaptive binary indices, make sure none are 'dirty'\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\tthis.ensureAllIndexes();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ensure binary index on a certain field\n\t * @param {string} property - name of property to create binary index on\n\t * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n\t * @memberof Collection\n\t */\n\tensureIndex(property, force) {\n\t\t// optional parameter to force rebuild whether flagged as dirty or not\n\t\tif (typeof(force) === 'undefined') {\n\t\t\tforce = false;\n\t\t}\n\n\t\tif (property === null || property === undefined) {\n\t\t\tthrow new Error('Attempting to set index without an associated property');\n\t\t}\n\n\t\tif (this.binaryIndices[property] && !force) {\n\t\t\tif (!this.binaryIndices[property].dirty) return;\n\t\t}\n\n\t\t// if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n\t\tif (this.adaptiveBinaryIndices === true && this.binaryIndices[property] !== undefined && !force) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst index = {\n\t\t\t'name': property,\n\t\t\t'dirty': true,\n\t\t\t'values': this.prepareFullDocIndex()\n\t\t};\n\t\tthis.binaryIndices[property] = index;\n\n\t\tconst wrappedComparer =\n\t\t\t(((p, data) => (a, b) => {\n\t\t\t\tconst objAp = data[a][p];\n\t\t\t\tconst objBp = data[b][p];\n\t\t\t\tif (objAp !== objBp) {\n\t\t\t\t\tif (ltHelper(objAp, objBp, false)) return -1;\n\t\t\t\t\tif (gtHelper(objAp, objBp, false)) return 1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}))(property, this.data);\n\n\t\tindex.values.sort(wrappedComparer);\n\t\tindex.dirty = false;\n\n\t\tthis.dirty = true; // for autosave scenarios\n\t}\n\n\tgetSequencedIndexValues(property) {\n\t\tlet idx;\n\t\tconst idxvals = this.binaryIndices[property].values;\n\t\tlet result = \"\";\n\n\t\tfor (idx = 0; idx < idxvals.length; idx++) {\n\t\t\tresult += \" [\" + idx + \"] \" + this.data[idxvals[idx]][property];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tensureUniqueIndex(field) {\n\t\tlet index = this.constraints.unique[field];\n\t\tif (!index) {\n\t\t\t// keep track of new unique index for regenerate after database (re)load.\n\t\t\tif (this.uniqueNames.indexOf(field) == -1) {\n\t\t\t\tthis.uniqueNames.push(field);\n\t\t\t}\n\t\t}\n\n\t\t// if index already existed, (re)loading it will likely cause collisions, rebuild always\n\t\tthis.constraints.unique[field] = index = new UniqueIndex(field);\n\t\tthis.data.forEach((obj) => {\n\t\t\tindex.set(obj);\n\t\t});\n\t\treturn index;\n\t}\n\n\t/**\n\t * Ensure all binary indices\n\t */\n\tensureAllIndexes(force) {\n\t\tlet key;\n\t\tconst bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (bIndices[key] !== undefined) {\n\t\t\t\tthis.ensureIndex(key, force);\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexesDirty() {\n\t\tlet key;\n\t\tconst bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (bIndices[key] !== undefined) {\n\t\t\t\tbIndices[key].dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexDirty(index) {\n\t\tif (this.binaryIndices[index])\n\t\t\tthis.binaryIndices[index].dirty = true;\n\t}\n\n\t/**\n\t * Quickly determine number of documents in collection (or query)\n\t * @param {object=} query - (optional) query object to count results of\n\t * @returns {number} number of documents in the collection\n\t * @memberof Collection\n\t */\n\tcount(query) {\n\t\tif (!query) {\n\t\t\treturn this.data.length;\n\t\t}\n\n\t\treturn this.chain().find(query).filteredrows.length;\n\t}\n\n\t/**\n\t * Rebuild idIndex\n\t */\n\tensureId() {\n\t\tconst len = this.data.length;\n\t\tlet i = 0;\n\n\t\tthis.idIndex = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tthis.idIndex.push(this.data[i].$loki);\n\t\t}\n\t}\n\n\t/**\n\t * Add a dynamic view to the collection\n\t * @param {string} name - name of dynamic view to add\n\t * @param {object=} options - (optional) options to configure dynamic view with\n\t * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t * @returns {DynamicView} reference to the dynamic view added\n\t * @memberof Collection\n\t **/\n\taddDynamicView(name, options) {\n\t\tconst dv = new DynamicView(this, name, options);\n\t\tthis.DynamicViews.push(dv);\n\n\t\treturn dv;\n\t}\n\n\t/**\n\t * Remove a dynamic view from the collection\n\t * @param {string} name - name of dynamic view to remove\n\t * @memberof Collection\n\t **/\n\tremoveDynamicView(name) {\n\t\tfor (let idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\tthis.DynamicViews.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Look up dynamic view reference from within the collection\n\t * @param {string} name - name of dynamic view to retrieve reference of\n\t * @returns {DynamicView} A reference to the dynamic view with that name\n\t * @memberof Collection\n\t **/\n\tgetDynamicView(name) {\n\t\tfor (let idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\treturn this.DynamicViews[idx];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object and passes all results to an update function.\n\t * For filter function querying you should migrate to [\n\t * Where()]{@link Collection#updateWhere}.\n\t *\n\t * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tfindAndUpdate(filterObject, updateFunction) {\n\t\tif (typeof(filterObject) === \"function\") {\n\t\t\tthis.updateWhere(filterObject, updateFunction);\n\t\t} else {\n\t\t\tthis.chain().find(filterObject).update(updateFunction);\n\t\t}\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object removes all documents which match that filter.\n\t *\n\t * @param {object} filterObject - 'mongo-like' query object\n\t * @memberof Collection\n\t */\n\tfindAndRemove(filterObject) {\n\t\tthis.chain().find(filterObject).remove();\n\t}\n\n\t/**\n\t * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n\t * @param {(object|array)} doc - the document (or array of documents) to be inserted\n\t * @returns {(object|array)} document or documents inserted\n\t * @memberof Collection\n\t */\n\tinsert(doc) {\n\t\tif (!Array.isArray(doc)) {\n\t\t\treturn this.insertOne(doc);\n\t\t}\n\n\t\t// holder to the clone of the object inserted if collections is set to clone objects\n\t\tlet obj;\n\t\tlet results = [];\n\n\t\tthis.emit('pre-insert', doc);\n\t\tfor (let i = 0, len = doc.length; i < len; i++) {\n\t\t\tobj = this.insertOne(doc[i], true);\n\t\t\tif (!obj) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tresults.push(obj);\n\t\t}\n\t\t// at the 'batch' level, if clone option is true then emitted docs are clones\n\t\tthis.emit('insert', results);\n\n\t\t// if clone option is set, clone return values\n\t\tresults = this.cloneObjects ? clone(results, this.cloneMethod) : results;\n\n\t\treturn results.length === 1 ? results[0] : results;\n\t}\n\n\t/**\n\t * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n\t * @param {object} doc - the document to be inserted\n\t * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n\t * @returns {object} document or 'undefined' if there was a problem inserting it\n\t * @memberof Collection\n\t */\n\tinsertOne(doc, bulkInsert) {\n\t\tlet err = null;\n\t\tlet returnObj;\n\n\t\tif (typeof doc !== 'object') {\n\t\t\terr = new TypeError('Document needs to be an object');\n\t\t} else if (doc === null) {\n\t\t\terr = new TypeError('Object cannot be null');\n\t\t}\n\n\t\tif (err !== null) {\n\t\t\tthis.emit('error', err);\n\t\t\tthrow err;\n\t\t}\n\n\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\tconst obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n\t\tif (typeof obj.meta === 'undefined') {\n\t\t\tobj.meta = {\n\t\t\t\trevision: 0,\n\t\t\t\tcreated: 0\n\t\t\t};\n\t\t}\n\n\t\t// both 'pre-insert' and 'insert' events are passed internal data reference even when cloning\n\t\t// insert needs internal reference because that is where loki itself listens to add meta\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('pre-insert', obj);\n\t\t}\n\t\tif (!this.add(obj)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// FullTextSearch TODO.\n\t\tif (this._fullTextSearch !== null) {\n\t\t\tthis._fullTextSearch.addDocument(doc);\n\t\t}\n\n\t\treturnObj = obj;\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('insert', obj);\n\t\t\treturnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\t\t}\n\n\t\tthis.addAutoUpdateObserver(returnObj);\n\t\treturn returnObj;\n\t}\n\n\t/**\n\t * Empties the collection.\n\t * @param {object=} options - configure clear behavior\n\t * @param {bool=} options.removeIndices - (default: false)\n\t * @memberof Collection\n\t */\n\tclear(options) {\n\t\toptions = options || {};\n\n\t\tthis.data = [];\n\t\tthis.idIndex = [];\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\t\tthis.maxId = 0;\n\t\tthis.DynamicViews = [];\n\t\tthis.dirty = true;\n\n\t\t// if removing indices entirely\n\t\tif (options.removeIndices === true) {\n\t\t\tthis.binaryIndices = {};\n\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\t\t\tthis.uniqueNames = [];\n\t\t}\n\t\t// clear indices but leave definitions in place\n\t\telse {\n\t\t\t// clear binary indices\n\t\t\tconst keys = Object.keys(this.binaryIndices);\n\t\t\tkeys.forEach((biname) => {\n\t\t\t\tthis.binaryIndices[biname].dirty = false;\n\t\t\t\tthis.binaryIndices[biname].values = [];\n\t\t\t});\n\n\t\t\t// clear entire unique indices definition\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\n\t\t\t// add definitions back\n\t\t\tthis.uniqueNames.forEach((uiname) => {\n\t\t\t\tthis.ensureUniqueIndex(uiname);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Updates an object and notifies collection that the document has changed.\n\t * @param {object} doc - document to update within the collection\n\t * @memberof Collection\n\t */\n\tupdate(doc) {\n\t\tif (Array.isArray(doc)) {\n\t\t\tlet k = 0;\n\t\t\tconst len = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.update(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify object is a properly formed document\n\t\tif (doc.$loki === undefined) {\n\t\t\tthrow new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n\t\t}\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tconst arr = this.get(doc.$loki, true);\n\n\t\t\t// ref to existing obj\n\t\t\tlet oldInternal;\n\n\t\t\t// ref to new internal obj\n\t\t\tlet newInternal;\n\n\t\t\tlet position;\n\n\t\t\tif (!arr) {\n\t\t\t\tthrow new Error('Trying to update a document not in collection.');\n\t\t\t}\n\n\t\t\toldInternal = arr[0]; // -internal- obj ref\n\t\t\tposition = arr[1]; // position in data array\n\n\t\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\t\tnewInternal = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n\t\t\tthis.emit('pre-update', doc);\n\n\t\t\tObject.keys(this.constraints.unique).forEach((key) => {\n\t\t\t\tthis.constraints.unique[key].update(oldInternal, newInternal);\n\t\t\t});\n\n\t\t\t// operate the update\n\t\t\tthis.data[position] = newInternal;\n\n\t\t\tif (newInternal !== doc) {\n\t\t\t\tthis.addAutoUpdateObserver(doc);\n\t\t\t}\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tfor (let idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].evaluateDocument(position, false);\n\t\t\t}\n\n\t\t\tlet key;\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tconst bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexUpdate(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.idIndex[position] = newInternal.$loki;\n\t\t\t//this.flagBinaryIndexesDirty();\n\n\t\t\t// FullTextSearch.\n\t\t\tif (this._fullTextSearch !== null) {\n\t\t\t\tthis._fullTextSearch.updateDocument(doc);\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\tthis.emit('update', doc, this.cloneObjects ? clone(oldInternal, this.cloneMethod) : null);\n\t\t\treturn doc;\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Add object to collection\n\t */\n\tadd(obj) {\n\t\t// if parameter isn't object exit with throw\n\t\tif ('object' !== typeof obj) {\n\t\t\tthrow new TypeError('Object being added needs to be an object');\n\t\t}\n\t\t// if object you are adding already has id column it is either already in the collection\n\t\t// or the object is carrying its own 'id' property.  If it also has a meta property,\n\t\t// then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n\t\tif (typeof(obj.$loki) !== 'undefined') {\n\t\t\tthrow new Error('Document is already in collection, please use update()');\n\t\t}\n\n\t\t/*\n\t\t * try adding object to collection\n\t\t */\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tthis.maxId++;\n\n\t\t\tif (isNaN(this.maxId)) {\n\t\t\t\tthis.maxId = (this.data[this.data.length - 1].$loki + 1);\n\t\t\t}\n\n\t\t\tobj.$loki = this.maxId;\n\t\t\tobj.meta.version = 0;\n\n\t\t\tlet key;\n\t\t\tconst constrUnique = this.constraints.unique;\n\t\t\tfor (key in constrUnique) {\n\t\t\t\tif (constrUnique[key] !== undefined) {\n\t\t\t\t\tconstrUnique[key].set(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add new obj id to idIndex\n\t\t\tthis.idIndex.push(obj.$loki);\n\n\t\t\t// add the object\n\t\t\tthis.data.push(obj);\n\n\t\t\tconst addedPos = this.data.length - 1;\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tconst dvlen = this.DynamicViews.length;\n\t\t\tfor (let i = 0; i < dvlen; i++) {\n\t\t\t\tthis.DynamicViews[i].evaluateDocument(addedPos, true);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tconst bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexInsert(addedPos, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\treturn (this.cloneObjects) ? (clone(obj, this.cloneMethod)) : (obj);\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Applies a filter function and passes all results to an update function.\n\t *\n\t * @param {function} filterFunction - filter function whose results will execute update\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tupdateWhere(filterFunction, updateFunction) {\n\t\tconst results = this.where(filterFunction);\n\t\tlet i = 0;\n\t\tlet obj;\n\t\ttry {\n\t\t\tfor (i; i < results.length; i++) {\n\t\t\t\tobj = updateFunction(results[i]);\n\t\t\t\tthis.update(obj);\n\t\t\t}\n\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t}\n\t}\n\n\t/**\n\t * Remove all documents matching supplied filter function.\n\t * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n\t * @param {function|object} query - query object to filter on\n\t * @memberof Collection\n\t */\n\tremoveWhere(query) {\n\t\tlet list;\n\t\tif (typeof query === 'function') {\n\t\t\tlist = this.data.filter(query);\n\t\t\tthis.remove(list);\n\t\t} else {\n\t\t\tthis.chain().find(query).remove();\n\t\t}\n\t}\n\n\tremoveDataOnly() {\n\t\tthis.remove(this.data.slice());\n\t}\n\n\t/**\n\t * Remove a document from the collection\n\t * @param {object} doc - document to remove from collection\n\t * @memberof Collection\n\t */\n\tremove(doc) {\n\t\tif (typeof doc === 'number') {\n\t\t\tdoc = this.get(doc);\n\t\t}\n\n\t\tif ('object' !== typeof doc) {\n\t\t\tthrow new Error('Parameter is not an object');\n\t\t}\n\t\tif (Array.isArray(doc)) {\n\t\t\tlet k = 0;\n\t\t\tconst len = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.remove(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (doc.$loki === undefined) {\n\t\t\tthrow new Error('Object is not a document stored in the collection');\n\t\t}\n\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tconst arr = this.get(doc.$loki, true);\n\n\t\t\tconst // obj = arr[0],\n\t\t\t\tposition = arr[1];\n\n\t\t\tObject.keys(this.constraints.unique).forEach((key) => {\n\t\t\t\tif (doc[key] !== null && typeof doc[key] !== 'undefined') {\n\t\t\t\t\tthis.constraints.unique[key].remove(doc[key]);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to remove\n\t\t\tfor (let idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].removeDocument(position);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tlet key;\n\n\t\t\t\tconst bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexRemove(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.data.splice(position, 1);\n\t\t\tthis.removeAutoUpdateObserver(doc);\n\n\t\t\t// remove id from idIndex\n\t\t\tthis.idIndex.splice(position, 1);\n\n\t\t\t// FullTextSearch.\n\t\t\tif (this._fullTextSearch != null) {\n\t\t\t\tthis._fullTextSearch.removeDocument(doc);\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\t\t\tthis.emit('delete', arr[0]);\n\t\t\tdelete doc.$loki;\n\t\t\tdelete doc.meta;\n\t\t\treturn doc;\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/*---------------------+\n\t | Finding methods     |\n\t +----------------------*/\n\n\t/**\n\t * Get by Id - faster than other methods because of the searching algorithm\n\t * @param {int} id - $loki id of document you want to retrieve\n\t * @param {boolean} returnPosition - if 'true' we will return [object, position]\n\t * @returns {(object|array|null)} Object reference if document was found, null if not,\n\t *     or an array if 'returnPosition' was passed.\n\t * @memberof Collection\n\t */\n\tget(id, returnPosition) {\n\t\tconst retpos = returnPosition || false;\n\t\tconst data = this.idIndex;\n\t\tlet max = data.length - 1;\n\t\tlet min = 0;\n\t\tlet mid = (min + max) >> 1;\n\n\t\tid = typeof id === 'number' ? id : parseInt(id, 10);\n\n\t\tif (isNaN(id)) {\n\t\t\tthrow new TypeError('Passed id is not an integer');\n\t\t}\n\n\t\twhile (data[min] < data[max]) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (data[mid] < id) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tif (max === min && data[min] === id) {\n\t\t\tif (retpos) {\n\t\t\t\treturn [this.data[min], min];\n\t\t\t}\n\t\t\treturn this.data[min];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n\t *    Since multiple documents may contain the same value (which the index is sorted on),\n\t *    we hone in on range and then linear scan range to find exact index array position.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tgetBinaryIndexPosition(dataPosition, binaryIndexName) {\n\t\tconst val = this.data[dataPosition][binaryIndexName];\n\t\tconst index = this.binaryIndices[binaryIndexName].values;\n\n\t\t// i think calculateRange can probably be moved to collection\n\t\t// as it doesn't seem to need resultset.  need to verify\n\t\t//let rs = new Resultset(this, null, null);\n\t\tconst range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n\t\tif (range[0] === 0 && range[1] === -1) {\n\t\t\t// uhoh didn't find range\n\t\t\treturn null;\n\t\t}\n\n\t\tconst min = range[0];\n\t\tconst max = range[1];\n\n\t\t// narrow down the sub-segment of index values\n\t\t// where the indexed property value exactly matches our\n\t\t// value and then linear scan to find exact -index- position\n\t\tfor (let idx = min; idx <= max; idx++) {\n\t\t\tif (index[idx] === dataPosition) return idx;\n\t\t}\n\n\t\t// uhoh\n\t\treturn null;\n\t}\n\n\t/**\n\t * Adaptively insert a selected item to the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexInsert(dataPosition, binaryIndexName) {\n\t\tconst index = this.binaryIndices[binaryIndexName].values;\n\t\tlet val = this.data[dataPosition][binaryIndexName];\n\n\t\t// If you are inserting a javascript Date value into a binary index, convert to epoch time\n\t\tif (this.serializableIndices === true && val instanceof Date) {\n\t\t\tthis.data[dataPosition][binaryIndexName] = val.getTime();\n\t\t\tval = this.data[dataPosition][binaryIndexName];\n\t\t}\n\n\t\tconst idxPos = (index.length === 0) ? 0 : this.calculateRangeStart(binaryIndexName, val, true);\n\n\t\t// insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n\t\t// doing this after adjusting dataPositions so no clash with previous item at that position.\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n\t}\n\n\t/**\n\t * Adaptively update a selected item within an index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexUpdate(dataPosition, binaryIndexName) {\n\t\t// linear scan needed to find old position within index unless we optimize for clone scenarios later\n\t\t// within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n\t\tlet idxPos;\n\n\t\tconst index = this.binaryIndices[binaryIndexName].values;\n\t\tconst len = index.length;\n\n\t\tfor (idxPos = 0; idxPos < len; idxPos++) {\n\t\t\tif (index[idxPos] === dataPosition) break;\n\t\t}\n\n\t\t//let idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t//this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n\t\tthis.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n\t}\n\n\t/**\n\t * Adaptively remove a selected item from the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexRemove(dataPosition, binaryIndexName, removedFromIndexOnly) {\n\t\tconst idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\t\tconst index = this.binaryIndices[binaryIndexName].values;\n\t\tlet len;\n\t\tlet idx;\n\n\t\tif (idxPos === null) {\n\t\t\t// throw new Error('unable to determine binary index position');\n\t\t\treturn null;\n\t\t}\n\n\t\t// remove document from index\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t// if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n\t\t// in which case data positions stay the same.\n\t\tif (removedFromIndexOnly === true) {\n\t\t\treturn;\n\t\t}\n\n\t\t// since index stores data array positions, if we remove a document\n\t\t// we need to adjust array positions -1 for all document positions greater than removed position\n\t\tlen = index.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tif (index[idx] > dataPosition) {\n\t\t\t\tindex[idx]--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method used for index maintenance and indexed searching.\n\t * Calculates the beginning of an index range for a given value.\n\t * For index maintainance (adaptive:true), we will return a valid index position to insert to.\n\t * For querying (adaptive:false/undefined), we will :\n\t *    return lower bound/index of range of that value (if found)\n\t *    return next lower index position if not found (hole)\n\t * If index is empty it is assumed to be handled at higher level, so\n\t * this method assumes there is at least 1 document in index.\n\t *\n\t * @param {string} prop - name of property which has binary index\n\t * @param {any} val - value to find within index\n\t * @param {bool?} adaptive - if true, we will return insert position\n\t */\n\tcalculateRangeStart(prop, val, adaptive) {\n\t\tconst rcd = this.data;\n\t\tconst index = this.binaryIndices[prop].values;\n\t\tlet min = 0;\n\t\tlet max = index.length - 1;\n\t\tlet mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tconst minVal = rcd[index[min]][prop];\n\t\tconst maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(rcd[index[mid]][prop], val, false)) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tconst lbound = min;\n\n\t\t// found it... return it\n\t\tif (aeqHelper(val, rcd[index[lbound]][prop])) {\n\t\t\treturn lbound;\n\t\t}\n\n\t\t// if not in index and our value is less than the found one\n\t\tif (ltHelper(val, rcd[index[lbound]][prop], false)) {\n\t\t\treturn adaptive ? lbound : lbound - 1;\n\t\t}\n\n\t\t// not in index and our value is greater than the found one\n\t\treturn adaptive ? lbound + 1 : lbound;\n\t}\n\n\t/**\n\t * Internal method used for indexed $between.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the final position of that upper range value.\n\t */\n\tcalculateRangeEnd(prop, val) {\n\t\tconst rcd = this.data;\n\t\tconst index = this.binaryIndices[prop].values;\n\t\tlet min = 0;\n\t\tlet max = index.length - 1;\n\t\tlet mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tconst minVal = rcd[index[min]][prop];\n\t\tconst maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(val, rcd[index[mid]][prop], false)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tconst ubound = max;\n\n\t\t// only eq if last element in array is our val\n\t\tif (aeqHelper(val, rcd[index[ubound]][prop])) {\n\t\t\treturn ubound;\n\t\t}\n\n\t\t// if not in index and our value is less than the found one\n\t\tif (gtHelper(val, rcd[index[ubound]][prop], false)) {\n\t\t\treturn ubound + 1;\n\t\t}\n\n\t\t// either hole or first nonmatch\n\t\tif (aeqHelper(val, rcd[index[ubound - 1]][prop])) {\n\t\t\treturn ubound - 1;\n\t\t}\n\n\t\t// hole, so ubound if nearest gt than the val we were looking for\n\t\treturn ubound;\n\t}\n\n\t/**\n\t * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n\t *    this is used for collection.find() and first find filter of resultset/dynview\n\t *    slightly different than get() binary search in that get() hones in on 1 value,\n\t *    but we have to hone in on many (range)\n\t * @param {string} op - operation, such as $eq\n\t * @param {string} prop - name of property to calculate range for\n\t * @param {object} val - value to use for range calculation.\n\t * @returns {array} [start, end] index array positions\n\t */\n\tcalculateRange(op, prop, val) {\n\t\tconst rcd = this.data;\n\t\tconst index = this.binaryIndices[prop].values;\n\t\tconst min = 0;\n\t\tconst max = index.length - 1;\n\t\tconst mid = 0;\n\t\tlet lbound;\n\t\tlet lval;\n\t\tlet ubound;\n\t\tlet uval;\n\n\t\t// when no documents are in collection, return empty range condition\n\t\tif (rcd.length === 0) {\n\t\t\treturn [0, -1];\n\t\t}\n\n\t\tconst minVal = rcd[index[min]][prop];\n\t\tconst maxVal = rcd[index[max]][prop];\n\n\t\t// if value falls outside of our range return [0, -1] to designate no results\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\tcase '$aeq':\n\t\t\t\tif (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$dteq':\n\t\t\t\tif (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gt':\n\t\t\t\t// none are within range\n\t\t\t\tif (gtHelper(val, maxVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\t// all are within range\n\t\t\t\tif (gtHelper(minVal, val, false)) {\n\t\t\t\t\treturn [min, max];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gte':\n\t\t\t\t// none are within range\n\t\t\t\tif (gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\t// all are within range\n\t\t\t\tif (gtHelper(minVal, val, true)) {\n\t\t\t\t\treturn [min, max];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lt':\n\t\t\t\t// none are within range\n\t\t\t\tif (ltHelper(val, minVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\t// all are within range\n\t\t\t\tif (ltHelper(maxVal, val, false)) {\n\t\t\t\t\treturn [min, max];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lte':\n\t\t\t\t// none are within range\n\t\t\t\tif (ltHelper(val, minVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\t// all are within range\n\t\t\t\tif (ltHelper(maxVal, val, true)) {\n\t\t\t\t\treturn [min, max];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$between':\n\t\t\t\t// none are within range (low range is greater)\n\t\t\t\tif (gtHelper(val[0], maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\t// none are within range (high range lower)\n\t\t\t\tif (ltHelper(val[1], minVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\tlbound = this.calculateRangeStart(prop, val[0]);\n\t\t\t\tubound = this.calculateRangeEnd(prop, val[1]);\n\n\t\t\t\tif (lbound < 0) lbound++;\n\t\t\t\tif (ubound > max) ubound--;\n\n\t\t\t\tif (!gtHelper(rcd[index[lbound]][prop], val[0], true)) lbound++;\n\t\t\t\tif (!ltHelper(rcd[index[ubound]][prop], val[1], true)) ubound--;\n\n\t\t\t\tif (ubound < lbound) return [0, -1];\n\n\t\t\t\treturn ([lbound, ubound]);\n\t\t\tcase '$in':\n\t\t\t\tconst idxset = [];\n\t\t\t\tconst segResult = [];\n\t\t\t\t// query each value '$eq' operator and merge the seqment results.\n\t\t\t\tfor (let j = 0, len = val.length; j < len; j++) {\n\t\t\t\t\tconst seg = this.calculateRange('$eq', prop, val[j]);\n\n\t\t\t\t\tfor (let i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\tif (idxset[i] === undefined) {\n\t\t\t\t\t\t\tidxset[i] = true;\n\t\t\t\t\t\t\tsegResult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn segResult;\n\t\t}\n\n\t\t// determine lbound where needed\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\tcase '$aeq':\n\t\t\tcase '$dteq':\n\t\t\tcase '$gte':\n\t\t\tcase '$lt':\n\t\t\t\tlbound = this.calculateRangeStart(prop, val);\n\t\t\t\tlval = rcd[index[lbound]][prop];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// determine ubound where needed\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\tcase '$aeq':\n\t\t\tcase '$dteq':\n\t\t\tcase '$lte':\n\t\t\tcase '$gt':\n\t\t\t\tubound = this.calculateRangeEnd(prop, val);\n\t\t\t\tuval = rcd[index[ubound]][prop];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\n\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\tcase '$aeq':\n\t\t\tcase '$dteq':\n\t\t\t\t// if hole (not found)\n\t\t\t\t//if (ltHelper(lval, val, false) || gtHelper(lval, val, false)) {\n\t\t\t\t//  return [0, -1];\n\t\t\t\t//}\n\t\t\t\tif (!aeqHelper(lval, val)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, ubound];\n\n\t\t\t//case '$dteq':\n\t\t\t// if hole (not found)\n\t\t\t//  if (lval > val || lval < val) {\n\t\t\t//    return [0, -1];\n\t\t\t//  }\n\n\t\t\t//  return [lbound, ubound];\n\n\t\t\tcase '$gt':\n\t\t\t\t// (an eqHelper would probably be better test)\n\t\t\t\t// if hole (not found) ub position is already greater\n\t\t\t\tif (!aeqHelper(rcd[index[ubound]][prop], val)) {\n\t\t\t\t\t//if (gtHelper(rcd[index[ubound]][prop], val, false)) {\n\t\t\t\t\treturn [ubound, max];\n\t\t\t\t}\n\t\t\t\t// otherwise (found) so ubound is still equal, get next\n\t\t\t\treturn [ubound + 1, max];\n\n\t\t\tcase '$gte':\n\t\t\t\t// if hole (not found) lb position marks left outside of range\n\t\t\t\tif (!aeqHelper(rcd[index[lbound]][prop], val)) {\n\t\t\t\t\t//if (ltHelper(rcd[index[lbound]][prop], val, false)) {\n\t\t\t\t\treturn [lbound + 1, max];\n\t\t\t\t}\n\t\t\t\t// otherwise (found) so lb is first position where its equal\n\t\t\t\treturn [lbound, max];\n\n\t\t\tcase '$lt':\n\t\t\t\t// if hole (not found) position already is less than\n\t\t\t\tif (!aeqHelper(rcd[index[lbound]][prop], val)) {\n\t\t\t\t\t//if (ltHelper(rcd[index[lbound]][prop], val, false)) {\n\t\t\t\t\treturn [min, lbound];\n\t\t\t\t}\n\t\t\t\t// otherwise (found) so lb marks left inside of eq range, get previous\n\t\t\t\treturn [min, lbound - 1];\n\n\t\t\tcase '$lte':\n\t\t\t\t// if hole (not found) ub position marks right outside so get previous\n\t\t\t\tif (!aeqHelper(rcd[index[ubound]][prop], val)) {\n\t\t\t\t\t//if (gtHelper(rcd[index[ubound]][prop], val, false)) {\n\t\t\t\t\treturn [min, ubound - 1];\n\t\t\t\t}\n\t\t\t\t// otherwise (found) so ub is last position where its still equal\n\t\t\t\treturn [min, ubound];\n\n\t\t\tdefault:\n\t\t\t\treturn [0, rcd.length - 1];\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve doc by Unique index\n\t * @param {string} field - name of uniquely indexed property to use when doing lookup\n\t * @param {value} value - unique value to search for\n\t * @returns {object} document matching the value passed\n\t * @memberof Collection\n\t */\n\tby(field, value) {\n\t\tif (value === undefined) {\n\t\t\treturn (value) => this.by(field, value);\n\t\t}\n\n\t\tconst result = this.constraints.unique[field].get(value);\n\t\tif (!this.cloneObjects) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn clone(result, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Find one object by index property, by property equal to value\n\t * @param {object} query - query object used to perform search with\n\t * @returns {(object|null)} First matching document, or null if none\n\t * @memberof Collection\n\t */\n\tfindOne(query) {\n\t\tquery = query || {};\n\n\t\t// Instantiate Resultset and exec find op passing firstOnly = true param\n\t\tconst result = this.chain().find(query, true).data();\n\n\t\tif (Array.isArray(result) && result.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif (!this.cloneObjects) {\n\t\t\t\treturn result[0];\n\t\t\t} else {\n\t\t\t\treturn clone(result[0], this.cloneMethod);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Chain method, used for beginning a series of chained find() and/or view() operations\n\t * on a collection.\n\t *\n\t * @param {array} transform - Ordered array of transform step objects similar to chain\n\t * @param {object} parameters - Object containing properties representing parameters to substitute\n\t * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n\t * @memberof Collection\n\t */\n\tchain(transform, parameters) {\n\t\tconst rs = new Resultset(this);\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t}\n\n\t/**\n\t * Find method, api is similar to mongodb.\n\t * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n\t * @example {@tutorial Query Examples}\n\t * @param {object} query - 'mongo-like' query object\n\t * @returns {array} Array of matching documents\n\t * @memberof Collection\n\t */\n\tfind(query) {\n\t\treturn this.chain().find(query).data();\n\t}\n\n\t/**\n\t * Find object by unindexed field by property equal to value,\n\t * simply iterates and returns the first element matching the query\n\t */\n\tfindOneUnindexed(prop, value) {\n\t\tlet i = this.data.length;\n\t\tlet doc;\n\t\twhile (i--) {\n\t\t\tif (this.data[i][prop] === value) {\n\t\t\t\tdoc = this.data[i];\n\t\t\t\treturn doc;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Transaction methods\n\t */\n\n\t/** start the transation */\n\tstartTransaction() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = clone(this.data, this.cloneMethod);\n\t\t\tthis.cachedIndex = this.idIndex;\n\t\t\tthis.cachedBinaryIndex = this.binaryIndices;\n\n\t\t\t// propagate startTransaction to dynamic views\n\t\t\tfor (let idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].startTransaction();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** commit the transation */\n\tcommit() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = null;\n\t\t\tthis.cachedIndex = null;\n\t\t\tthis.cachedBinaryIndex = null;\n\n\t\t\t// propagate commit to dynamic views\n\t\t\tfor (let idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].commit();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** roll back the transation */\n\trollback() {\n\t\tif (this.transactional) {\n\t\t\tif (this.cachedData !== null && this.cachedIndex !== null) {\n\t\t\t\tthis.data = this.cachedData;\n\t\t\t\tthis.idIndex = this.cachedIndex;\n\t\t\t\tthis.binaryIndices = this.cachedBinaryIndex;\n\t\t\t}\n\n\t\t\t// propagate rollback to dynamic views\n\t\t\tfor (let idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].rollback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query the collection by supplying a javascript filter function.\n\t * @example\n\t * let results = coll.where(function(obj) {\n\t *   return obj.legs === 8;\n\t * });\n\t *\n\t * @param {function} fun - filter function to run against all collection docs\n\t * @returns {array} all documents which pass your filter function\n\t * @memberof Collection\n\t */\n\twhere(fun) {\n\t\treturn this.chain().where(fun).data();\n\t}\n\n\t/**\n\t * Map Reduce operation\n\t *\n\t * @param {function} mapFunction - function to use as map function\n\t * @param {function} reduceFunction - function to use as reduce function\n\t * @returns {data} The result of your mapReduce operation\n\t * @memberof Collection\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data.map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Join two collections on specified properties\n\t *\n\t * @param {array} joinData - array of documents to 'join' to this collection\n\t * @param {string} leftJoinProp - property name in collection\n\t * @param {string} rightJoinProp - property name in joinData\n\t * @param {function=} mapFun - (Optional) map function to use\n\t * @returns {Resultset} Result of the mapping operation\n\t * @memberof Collection\n\t */\n\teqJoin(joinData, leftJoinProp, rightJoinProp, mapFun) {\n\t\t// logic in Resultset class\n\t\treturn new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);\n\t}\n\n\t/* ------ STAGING API -------- */\n\t/**\n\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t * manipulated without affecting the data in the original collection\n\t */\n\n\n\t/**\n\t * (Staging API) create a stage and/or retrieve it\n\t * @memberof Collection\n\t */\n\tgetStage(name) {\n\t\tif (!this.stages[name]) {\n\t\t\tthis.stages[name] = {};\n\t\t}\n\t\treturn this.stages[name];\n\t}\n\n\t/**\n\t * a collection of objects recording the changes applied through a commmitStage\n\t */\n\n\t/**\n\t * (Staging API) create a copy of an object and insert it into a stage\n\t * @memberof Collection\n\t */\n\tstage(stageName, obj) {\n\t\tconst copy = JSON.parse(JSON.stringify(obj));\n\t\tthis.getStage(stageName)[obj.$loki] = copy;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n\t * then create a message to be inserted in the commitlog\n\t * @param {string} stageName - name of stage\n\t * @param {string} message\n\t * @memberof Collection\n\t */\n\tcommitStage(stageName, message) {\n\t\tconst stage = this.getStage(stageName);\n\t\tlet prop;\n\t\tconst timestamp = new Date().getTime();\n\n\t\tfor (prop in stage) {\n\n\t\t\tthis.update(stage[prop]);\n\t\t\tthis.commitLog.push({\n\t\t\t\ttimestamp,\n\t\t\t\tmessage,\n\t\t\t\tdata: JSON.parse(JSON.stringify(stage[prop]))\n\t\t\t});\n\t\t}\n\t\tthis.stages[stageName] = {};\n\t}\n\n\tno_op() {\n\t\treturn;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textract(field) {\n\t\tlet i = 0;\n\t\tconst len = this.data.length;\n\t\tconst isDotNotation = isDeepProperty(field);\n\t\tconst result = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tresult.push(deepProperty(this.data[i], field, isDotNotation));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmax(field) {\n\t\treturn Math.max.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmin(field) {\n\t\treturn Math.min.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmaxRecord(field) {\n\t\tlet i = 0;\n\t\tconst len = this.data.length;\n\t\tconst deep = isDeepProperty(field);\n\n\t\tconst result = {\n\t\t\tindex: 0,\n\t\t\tvalue: undefined\n\t\t};\n\n\t\tlet max;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (max !== undefined) {\n\t\t\t\tif (max < deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = max;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tminRecord(field) {\n\t\tlet i = 0;\n\t\tconst len = this.data.length;\n\t\tconst deep = isDeepProperty(field);\n\n\t\tconst result = {\n\t\t\tindex: 0,\n\t\t\tvalue: undefined\n\t\t};\n\n\t\tlet min;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (min !== undefined) {\n\t\t\t\tif (min > deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = min;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textractNumerical(field) {\n\t\treturn this.extract(field).map(parseBase10).filter(Number).filter((n) => !(isNaN(n)));\n\t}\n\n\t/**\n\t * Calculates the average numerical value of a property\n\t *\n\t * @param {string} field - name of property in docs to average\n\t * @returns {number} average of property in all docs in the collection\n\t * @memberof Collection\n\t */\n\tavg(field) {\n\t\treturn average(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * Calculate standard deviation of a field\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tstdDev(field) {\n\t\treturn standardDeviation(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tmode(field) {\n\t\tconst dict = {};\n\t\tconst data = this.extract(field);\n\t\tdata.forEach((obj) => {\n\t\t\tif (dict[obj]) {\n\t\t\t\tdict[obj] += 1;\n\t\t\t} else {\n\t\t\t\tdict[obj] = 1;\n\t\t\t}\n\t\t});\n\t\tlet max;\n\t\tlet prop;\n\t\tlet mode;\n\t\tfor (prop in dict) {\n\t\t\tif (max) {\n\t\t\t\tif (max < dict[prop]) {\n\t\t\t\t\tmode = prop;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmode = prop;\n\t\t\t\tmax = dict[prop];\n\t\t\t}\n\t\t}\n\t\treturn mode;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field - property name\n\t */\n\tmedian(field) {\n\t\tconst values = this.extractNumerical(field);\n\t\tvalues.sort(sub);\n\n\t\tconst half = Math.floor(values.length / 2);\n\n\t\tif (values.length % 2) {\n\t\t\treturn values[half];\n\t\t} else {\n\t\t\treturn (values[half - 1] + values[half]) / 2.0;\n\t\t}\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/collection.js\n// module id = 1\n// module chunks = 0","/**\n * Created by toni on 1/27/17.\n */\nexport function copyProperties(src, dest) {\n\tlet prop;\n\tfor (prop in src) {\n\t\tdest[prop] = src[prop];\n\t}\n}\n\n// used to recursively scan hierarchical transform step object for param substitution\nfunction resolveTransformObject(subObj, params, depth) {\n\tlet prop;\n\tlet pname;\n\n\tif (typeof depth !== 'number') {\n\t\tdepth = 0;\n\t}\n\n\tif (++depth >= 10) return subObj;\n\n\tfor (prop in subObj) {\n\t\tif (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n\t\t\tpname = subObj[prop].substring(8);\n\t\t\tif (params[pname] !== undefined) {\n\t\t\t\tsubObj[prop] = params[pname];\n\t\t\t}\n\t\t} else if (typeof subObj[prop] === \"object\") {\n\t\t\tsubObj[prop] = resolveTransformObject(subObj[prop], params, depth);\n\t\t}\n\t}\n\n\treturn subObj;\n}\n// top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\nexport function resolveTransformParams(transform, params) {\n\tlet idx;\n\tlet clonedStep;\n\tconst resolvedTransform = [];\n\n\tif (typeof params === 'undefined') return transform;\n\n\t// iterate all steps in the transform array\n\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t// clone transform so our scan and replace can operate directly on cloned transform\n\t\tclonedStep = JSON.parse(JSON.stringify(transform[idx]));\n\t\tresolvedTransform.push(resolveTransformObject(clonedStep, params));\n\t}\n\n\treturn resolvedTransform;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/utils.js\n// module id = 2\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 3\n// module chunks = 0","export function clone(data, method) {\n\tif (data === null || data === undefined) {\n\t\treturn null;\n\t}\n\n\tconst cloneMethod = method || 'parse-stringify';\n\tlet cloned;\n\n\tswitch (cloneMethod) {\n\t\tcase \"parse-stringify\":\n\t\t\tcloned = JSON.parse(JSON.stringify(data));\n\t\t\tbreak;\n\t\tcase \"jquery-extend-deep\":\n\t\t\tcloned = jQuery.extend(true, {}, data);\n\t\t\tbreak;\n\t\tcase \"shallow\":\n\t\t\t// more compatible method for older browsers\n\t\t\tcloned = data.prototype ? Object.create(data.prototype) : {};\n\t\t\tObject.keys(data).map((i) => {\n\t\t\t\tcloned[i] = data[i];\n\t\t\t});\n\t\t\tbreak;\n\t\tcase \"shallow-assign\":\n\t\t\t// should be supported by newer environments/browsers\n\t\t\tcloned = data.prototype ? Object.create(data.prototype) : {};\n\t\t\tObject.assign(cloned, data);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn cloned;\n}\n\nexport function cloneObjectArray(objarray, method) {\n\tlet i;\n\tconst result = [];\n\n\tif (method === \"parse-stringify\") {\n\t\treturn clone(objarray, method);\n\t}\n\n\ti = objarray.length - 1;\n\n\tfor (; i <= 0; i--) {\n\t\tresult.push(clone(objarray[i], method));\n\t}\n\n\treturn result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/clone.js\n// module id = 4\n// module chunks = 0","/** Helper function for determining 'loki' abstract equality which is a little more abstract than ==\n *     aeqHelper(5, '5') === true\n *     aeqHelper(5.0, '5') === true\n *     aeqHelper(new Date(\"1/1/2011\"), new Date(\"1/1/2011\")) === true\n *     aeqHelper({a:1}, {z:4}) === true (all objects sorted equally)\n *     aeqHelper([1, 2, 3], [1, 3]) === false\n *     aeqHelper([1, 2, 3], [1, 2, 3]) === true\n *     aeqHelper(undefined, null) === true\n */\nexport function aeqHelper(prop1, prop2) {\n\tlet cv1;\n\tlet cv2;\n\tlet t1;\n\tlet t2;\n\n\tif (prop1 === prop2) return true;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n\t\t// dates and NaN conditions (typed dates before serialization)\n\t\tswitch (prop1) {\n\t\t\tcase undefined:\n\t\t\t\tt1 = 1;\n\t\t\t\tbreak;\n\t\t\tcase null:\n\t\t\t\tt1 = 1;\n\t\t\t\tbreak;\n\t\t\tcase false:\n\t\t\t\tt1 = 3;\n\t\t\t\tbreak;\n\t\t\tcase true:\n\t\t\t\tt1 = 4;\n\t\t\t\tbreak;\n\t\t\tcase \"\":\n\t\t\t\tt1 = 5;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tt1 = (prop1 === prop1) ? 9 : 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tswitch (prop2) {\n\t\t\tcase undefined:\n\t\t\t\tt2 = 1;\n\t\t\t\tbreak;\n\t\t\tcase null:\n\t\t\t\tt2 = 1;\n\t\t\t\tbreak;\n\t\t\tcase false:\n\t\t\t\tt2 = 3;\n\t\t\t\tbreak;\n\t\t\tcase true:\n\t\t\t\tt2 = 4;\n\t\t\t\tbreak;\n\t\t\tcase \"\":\n\t\t\t\tt2 = 5;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tt2 = (prop2 === prop2) ? 9 : 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// one or both is edge case\n\t\tif (t1 !== 9 || t2 !== 9) {\n\t\t\treturn (t1 === t2);\n\t\t}\n\t}\n\n\t// Handle 'Number-like' comparisons\n\tcv1 = Number(prop1);\n\tcv2 = Number(prop2);\n\n\t// if one or both are 'number-like'...\n\tif (cv1 === cv1 || cv2 === cv2) {\n\t\treturn (cv1 === cv2);\n\t}\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\treturn (cv1 == cv2);\n}\n\n/** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n */\nexport function ltHelper(prop1, prop2, equal) {\n\tlet cv1;\n\tlet cv2;\n\tlet t1;\n\tlet t2;\n\n\t// if one of the params is falsy or strictly true or not equal to itself\n\t// 0, 0.0, \"\", NaN, null, undefined, not defined, false, true\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n\t\tswitch (prop1) {\n\t\t\tcase undefined:\n\t\t\t\tt1 = 1;\n\t\t\t\tbreak;\n\t\t\tcase null:\n\t\t\t\tt1 = 1;\n\t\t\t\tbreak;\n\t\t\tcase false:\n\t\t\t\tt1 = 3;\n\t\t\t\tbreak;\n\t\t\tcase true:\n\t\t\t\tt1 = 4;\n\t\t\t\tbreak;\n\t\t\tcase \"\":\n\t\t\t\tt1 = 5;\n\t\t\t\tbreak;\n\t\t\t// if strict equal probably 0 so sort higher, otherwise probably NaN so sort lower than even null\n\t\t\tdefault:\n\t\t\t\tt1 = (prop1 === prop1) ? 9 : 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tswitch (prop2) {\n\t\t\tcase undefined:\n\t\t\t\tt2 = 1;\n\t\t\t\tbreak;\n\t\t\tcase null:\n\t\t\t\tt2 = 1;\n\t\t\t\tbreak;\n\t\t\tcase false:\n\t\t\t\tt2 = 3;\n\t\t\t\tbreak;\n\t\t\tcase true:\n\t\t\t\tt2 = 4;\n\t\t\t\tbreak;\n\t\t\tcase \"\":\n\t\t\t\tt2 = 5;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tt2 = (prop2 === prop2) ? 9 : 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// one or both is edge case\n\t\tif (t1 !== 9 || t2 !== 9) {\n\t\t\treturn (t1 === t2) ? equal : (t1 < t2);\n\t\t}\n\t}\n\n\t// if both are numbers (string encoded or not), compare as numbers\n\tcv1 = Number(prop1);\n\tcv2 = Number(prop2);\n\n\tif (cv1 === cv1 && cv2 === cv2) {\n\t\tif (cv1 < cv2) return true;\n\t\tif (cv1 > cv2) return false;\n\t\treturn equal;\n\t}\n\n\tif (cv1 === cv1 && cv2 !== cv2) {\n\t\treturn true;\n\t}\n\n\tif (cv2 === cv2 && cv1 !== cv1) {\n\t\treturn false;\n\t}\n\n\tif (prop1 < prop2) return true;\n\tif (prop1 > prop2) return false;\n\tif (prop1 == prop2) return equal;\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 < cv2) {\n\t\treturn true;\n\t}\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\treturn false;\n}\n\nexport function gtHelper(prop1, prop2, equal) {\n\tlet cv1;\n\tlet cv2;\n\tlet t1;\n\tlet t2;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true || prop1 !== prop1 || prop2 !== prop2) {\n\t\tswitch (prop1) {\n\t\t\tcase undefined:\n\t\t\t\tt1 = 1;\n\t\t\t\tbreak;\n\t\t\tcase null:\n\t\t\t\tt1 = 1;\n\t\t\t\tbreak;\n\t\t\tcase false:\n\t\t\t\tt1 = 3;\n\t\t\t\tbreak;\n\t\t\tcase true:\n\t\t\t\tt1 = 4;\n\t\t\t\tbreak;\n\t\t\tcase \"\":\n\t\t\t\tt1 = 5;\n\t\t\t\tbreak;\n\t\t\t// NaN 0\n\t\t\tdefault:\n\t\t\t\tt1 = (prop1 === prop1) ? 9 : 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tswitch (prop2) {\n\t\t\tcase undefined:\n\t\t\t\tt2 = 1;\n\t\t\t\tbreak;\n\t\t\tcase null:\n\t\t\t\tt2 = 1;\n\t\t\t\tbreak;\n\t\t\tcase false:\n\t\t\t\tt2 = 3;\n\t\t\t\tbreak;\n\t\t\tcase true:\n\t\t\t\tt2 = 4;\n\t\t\t\tbreak;\n\t\t\tcase \"\":\n\t\t\t\tt2 = 5;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tt2 = (prop2 === prop2) ? 9 : 0;\n\t\t\t\tbreak;\n\t\t}\n\n\t\t// one or both is edge case\n\t\tif (t1 !== 9 || t2 !== 9) {\n\t\t\treturn (t1 === t2) ? equal : (t1 > t2);\n\t\t}\n\t}\n\n\t// if both are numbers (string encoded or not), compare as numbers\n\tcv1 = Number(prop1);\n\tcv2 = Number(prop2);\n\tif (cv1 === cv1 && cv2 === cv2) {\n\t\tif (cv1 > cv2) return true;\n\t\tif (cv1 < cv2) return false;\n\t\treturn equal;\n\t}\n\n\tif (cv1 === cv1 && cv2 !== cv2) {\n\t\treturn false;\n\t}\n\n\tif (cv2 === cv2 && cv1 !== cv1) {\n\t\treturn true;\n\t}\n\n\tif (prop1 > prop2) return true;\n\tif (prop1 < prop2) return false;\n\tif (prop1 == prop2) return equal;\n\n\t// not strict equal nor less than nor gt so must be dates or mixed types\n\t// convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 > cv2) {\n\t\treturn true;\n\t}\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\treturn false;\n}\n\nfunction sortHelper(prop1, prop2, desc) {\n\tif (aeqHelper(prop1, prop2)) return 0;\n\n\tif (ltHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (1) : (-1);\n\t}\n\n\tif (gtHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (-1) : (1);\n\t}\n\n\t// not lt, not gt so implied equality-- date compatible\n\treturn 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/helper.js\n// module id = 5\n// module chunks = 0","import {LokiEventEmitter} from './event_emitter';\n\nimport {LokiMemoryAdapter} from './memory_adapter';\nimport {LokiFsAdapter} from './fs_adapter';\nimport {LokiLocalStorageAdapter} from './local_storage_adapter';\nimport {Collection} from './collection';\nimport {copyProperties} from './utils';\n\n/*\n 'LokiFsAdapter' is not defined                 no-undef\tx\n 'LokiLocalStorageAdapter' is not defined       no-undef\tx\n 'Collection' is not defined                    no-undef\tx\n 'delim' is not defined                         no-undef\tx\n 'Utils' is not defined                         no-undef\tx\n\n TBD:\n * Default persistence should be not available.\n * getIndexedAdapter is also obsolet\n * Make some functions private.\n * Inflate? -> Utils.copyProperties\n */\n\n/**\n * Loki: The main database class\n * @constructor Loki\n * @implements LokiEventEmitter\n * @param {string} filename - name of the file to be saved to\n * @param {object=} options - (Optional) config options object\n * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n * @param {boolean} options.verbose - enable console output (default is 'false')\n */\nexport class Loki extends LokiEventEmitter {\n\n\tconstructor(filename, options) {\n\t\tsuper();\n\t\tthis.filename = filename || 'loki.db';\n\t\tthis.collections = [];\n\n\t\t// persist version of code which created the database to the database.\n\t\t// could use for upgrade scenarios\n\t\tthis.databaseVersion = 1.5;\n\t\tthis.engineVersion = 1.5;\n\n\t\t// autosave support (disabled by default)\n\t\t// pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n\t\tthis.autosave = false;\n\t\tthis.autosaveInterval = 5000;\n\t\tthis.autosaveHandle = null;\n\t\tthis._throttledSaves = true;\n\n\t\tthis.options = {\n\t\t\tserializationMethod: options && options.serializationMethod !== undefined ? options.serializationMethod : 'normal',\n\t\t\tdestructureDelimiter: options && options.destructureDelimiter !== undefined ? options.destructureDelimiter : '$<\\n'\n\t\t};\n\n\t\t// currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n\t\t// will not or cannot be deserialized.  You are required to configure persistence every time\n\t\t// you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\n\t\t// persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n\t\t// this is optional option param, otherwise environment detection will be used\n\t\t// if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n\t\tthis.persistenceMethod = null;\n\n\t\t// retain reference to optional (non-serializable) persistenceAdapter 'instance'\n\t\tthis.persistenceAdapter = null;\n\n\t\t// flags used to throttle saves\n\t\tthis._throttledSaveRunning = null;\n\t\tthis._throttledSavePending = null;\n\n\t\t// enable console output if verbose flag is set (disabled by default)\n\t\tthis.verbose = options && options.verbose !== undefined ? options.verbose : false;\n\n\t\tthis.events = {\n\t\t\t'init': [],\n\t\t\t'loaded': [],\n\t\t\t'flushChanges': [],\n\t\t\t'close': [],\n\t\t\t'changes': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\tconst getENV = () => {\n\t\t\tif (typeof global !== 'undefined' && (global.android || global.NSObject)) {\n\t\t\t\t// If no adapter is set use the default nativescript adapter\n\t\t\t\tif (!options.adapter) {\n\t\t\t\t\t//let LokiNativescriptAdapter = require('./loki-nativescript-adapter');\n\t\t\t\t\t//options.adapter=new LokiNativescriptAdapter();\n\t\t\t\t}\n\t\t\t\treturn 'NATIVESCRIPT'; //nativescript\n\t\t\t}\n\n\t\t\tconst isNode = typeof global !== \"undefined\" && ({}).toString.call(global) === '[object global]';\n\n\t\t\tif (isNode) {\n\t\t\t\tif (global.window) {\n\t\t\t\t\treturn 'NODEJS'; //node-webkit\n\t\t\t\t} else {\n\t\t\t\t\treturn 'NODEJS';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst isBrowser = typeof window !== 'undefined' && ({}).toString.call(window) === '[object Window]';\n\n\t\t\tif (typeof document !== 'undefined') {\n\t\t\t\tif (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n\t\t\t\t\treturn 'CORDOVA';\n\t\t\t\t}\n\t\t\t\treturn 'BROWSER';\n\t\t\t}\n\n\t\t\tif (!isBrowser) {\n\t\t\t\tthrow SyntaxError(\"Unknown enviroment...\");\n\t\t\t}\n\t\t};\n\n\t\t// refactored environment detection due to invalid detection for browser environments.\n\t\t// if they do not specify an options.env we want to detect env rather than default to nodejs.\n\t\t// currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n\t\t//   might want to review whether we can consolidate.\n\t\tif (options && options.env !== undefined) {\n\t\t\tthis.ENV = options.env;\n\t\t} else {\n\t\t\tthis.ENV = getENV();\n\t\t}\n\n\t\tthis.on('init', this.clearChanges);\n\t}\n\n\t/**\n\t * configures options related to database persistence.\n\t *\n\t * @param {object} options - configuration options to apply to loki db object\n\t * @param {adapter} options.adapter - an instance of a loki persistence adapter\n\t * @param {boolean} options.autosave - enables autosave\n\t * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n\t * @param {boolean} options.autoload - enables autoload on loki instantiation\n\t * @param {object} options.inflate - options that are passed to loadDatabase if autoload enabled\n\t * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']\n\t * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n\t * @param {boolean} options.throttledSaves - if true, it batches multiple calls to to saveDatabase reducing number of\n\t *   disk I/O operations and guaranteeing proper serialization of the calls. Default value is true.\n\t * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n\t */\n\tinitializePersistence(options = {}) {\n\t\tconst defaultPersistence = {\n\t\t\t'NODEJS': 'fs',\n\t\t\t'BROWSER': 'localStorage',\n\t\t\t'CORDOVA': 'localStorage',\n\t\t\t'MEMORY': 'memory'\n\t\t};\n\n\t\tconst persistenceMethods = {\n\t\t\t'fs': LokiFsAdapter,\n\t\t\t'localStorage': LokiLocalStorageAdapter,\n\t\t\t'memory': LokiMemoryAdapter\n\t\t};\n\n\t\tthis.options = options;\n\n\t\tthis.persistenceMethod = null;\n\t\t// retain reference to optional persistence adapter 'instance'\n\t\t// currently keeping outside options because it can't be serialized\n\t\tthis.persistenceAdapter = null;\n\n\t\t// process the options\n\t\tif (this.options.persistenceMethod !== undefined) {\n\t\t\t// check if the specified persistence method is known\n\t\t\tif (typeof(persistenceMethods[this.options.persistenceMethod]) === 'function') {\n\t\t\t\tthis.persistenceMethod = this.options.persistenceMethod;\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.options.persistenceMethod]();\n\t\t\t}\n\t\t\t// should be throw an error here, or just fall back to defaults ??\n\t\t}\n\n\t\t// ensure defaults exists for options which were not set\n\t\tif (this.options.serializationMethod === undefined) {\n\t\t\tthis.options.serializationMethod = 'normal';\n\t\t}\n\n\t\t// ensure passed or default option exists\n\t\tif (this.options.destructureDelimiter === undefined) {\n\t\t\tthis.options.destructureDelimiter = '$<\\n';\n\t\t}\n\n\t\t// if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n\t\tif (this.persistenceAdapter === null) {\n\t\t\tthis.persistenceMethod = defaultPersistence[this.ENV];\n\t\t\tif (this.persistenceMethod) {\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n\t\t\t}\n\t\t}\n\n\t\t// if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n\t\tif (this.options.adapter !== undefined) {\n\t\t\tthis.persistenceMethod = 'adapter';\n\t\t\tthis.persistenceAdapter = this.options.adapter;\n\t\t}\n\n\t\tif (this.options.autosaveInterval !== undefined) {\n\t\t\tthis.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n\t\t}\n\n\t\tif (this.options.throttledSaves !== undefined) {\n\t\t\tthis._throttledSaves = this.options.throttledSaves;\n\t\t}\n\n\t\tthis.autosaveDisable();\n\n\t\tlet loaded;\n\n\t\t// if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n\t\tif (this.options.autoload) {\n\t\t\tloaded = this.loadDatabase(this.options.inflate);\n\t\t} else {\n\t\t\tloaded = Promise.resolve();\n\t\t}\n\n\t\treturn loaded.then(() => {\n\t\t\tif (this.options.autosave) {\n\t\t\t\tthis.autosaveEnable();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n\t *\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n\t */\n\tcopy(options = {}) {\n\t\t// in case running in an environment without accurate environment detection, pass 'NA'\n\t\tconst databaseCopy = new Loki(this.filename, {env: \"NA\"});\n\t\tlet clen;\n\t\tlet idx;\n\n\t\t// currently inverting and letting loadJSONObject do most of the work\n\t\tdatabaseCopy.loadJSONObject(this, {\n\t\t\tretainDirtyFlags: true\n\t\t});\n\n\t\t// since our toJSON is not invoked for reference database adapters, this will let us mimic\n\t\tif (options.removeNonSerializable !== undefined && options.removeNonSerializable === true) {\n\t\t\tdatabaseCopy.autosaveHandle = null;\n\t\t\tdatabaseCopy.persistenceAdapter = null;\n\n\t\t\tclen = databaseCopy.collections.length;\n\t\t\tfor (idx = 0; idx < clen; idx++) {\n\t\t\t\tdatabaseCopy.collections[idx].constraints = null;\n\t\t\t\tdatabaseCopy.collections[idx].ttl = null;\n\t\t\t}\n\t\t}\n\n\t\treturn databaseCopy;\n\t}\n\n\t/**\n\t * Adds a collection to the database.\n\t * @param {string} name - name of collection to add\n\t * @param {object=} options - (optional) options to configure collection with.\n\t * @param {string[]} options.unique - array of property names to define unique constraints for\n\t * @param {string[]} options.exact - array of property names to define exact constraints for\n\t * @param {string[]} options.indices - array property names to define binary indexes for\n\t * @param {boolean} options.asyncListeners - default is false\n\t * @param {boolean} options.disableChangesApi - default is true\n\t * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n\t * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n\t * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n\t * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n\t * @returns {Collection} a reference to the collection which was just added\n\t */\n\taddCollection(name, options) {\n\t\tconst collection = new Collection(name, options);\n\t\tthis.collections.push(collection);\n\n\t\tif (this.verbose)\n\t\t\tcollection.console = console;\n\n\t\treturn collection;\n\t}\n\n\tloadCollection(collection) {\n\t\tif (!collection.name) {\n\t\t\tthrow new Error('Collection must have a name property to be loaded');\n\t\t}\n\t\tthis.collections.push(collection);\n\t}\n\n\t/**\n\t * Retrieves reference to a collection by name.\n\t * @param {string} collectionName - name of collection to look up\n\t * @returns {Collection} Reference to collection in database by that name, or null if not found\n\t */\n\tgetCollection(collectionName) {\n\t\tlet i;\n\t\tconst len = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\treturn this.collections[i];\n\t\t\t}\n\t\t}\n\n\t\t// no such collection\n\t\tthis.emit('warning', 'collection ' + collectionName + ' not found');\n\t\treturn null;\n\t}\n\n\tlistCollections() {\n\t\tlet i = this.collections.length;\n\t\tconst colls = [];\n\n\t\twhile (i--) {\n\t\t\tcolls.push({\n\t\t\t\tname: this.collections[i].name,\n\t\t\t\ttype: this.collections[i].objType,\n\t\t\t\tcount: this.collections[i].data.length\n\t\t\t});\n\t\t}\n\t\treturn colls;\n\t}\n\n\t/**\n\t * Removes a collection from the database.\n\t * @param {string} collectionName - name of collection to remove\n\t */\n\tremoveCollection(collectionName) {\n\t\tlet i;\n\t\tconst len = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\tconst tmpcol = new Collection(collectionName, {});\n\t\t\t\tconst curcol = this.collections[i];\n\t\t\t\tfor (const prop in curcol) {\n\t\t\t\t\tif (curcol[prop] !== undefined && tmpcol[prop] !== undefined) {\n\t\t\t\t\t\tcurcol[prop] = tmpcol[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.collections.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n\t *\n\t * @returns {string} Stringified representation of the loki database.\n\t */\n\tserialize(options = {}) {\n\t\tif (options.serializationMethod === undefined) {\n\t\t\toptions.serializationMethod = this.options.serializationMethod;\n\t\t}\n\n\t\tswitch (options.serializationMethod) {\n\t\t\tcase \"normal\":\n\t\t\t\treturn JSON.stringify(this);\n\t\t\tcase \"pretty\":\n\t\t\t\treturn JSON.stringify(this, null, 2);\n\t\t\tcase \"destructured\":\n\t\t\t\treturn this.serializeDestructured(); // use default options\n\t\t\tdefault:\n\t\t\t\treturn JSON.stringify(this);\n\t\t}\n\t}\n\n\t// alias of serialize\n\ttoJSON() {\n\t\treturn {\n\t\t\tevents: this.events,\n\t\t\tENV: this.ENV,\n\t\t\tserializationMethod: this.serializationMethod,\n\t\t\tasyncListeners: this.asyncListeners,\n\t\t\tautosave: this.autosave,\n\t\t\tautosaveInterval: this.autosaveInterval,\n\t\t\tcollections: this.collections,\n\t\t\tdatabaseVersion: this.databaseVersion,\n\t\t\tengineVersion: this.engineVersion,\n\t\t\tfilename: this.filename,\n\t\t\toptions: this.options,\n\t\t\tpersistenceAdapter: this.persistenceAdapter,\n\t\t\tpersistenceMethod: this.persistenceMethod,\n\t\t\t_throttledSaves: this._throttledSaves,\n\t\t\tverbose: this.verbose,\n\t\t};\n\t}\n\n\t/**\n\t * Destructured JSON serialization routine to allow alternate serialization methods.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {object=} options - output format options for use externally to loki\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {string|Array} A custom, restructured aggregation of independent serializations.\n\t */\n\tserializeDestructured(options = {}) {\n\t\tlet idx;\n\t\tlet sidx;\n\t\tlet result;\n\t\tlet resultlen;\n\t\tconst reconstruct = [];\n\t\tlet dbcopy;\n\n\t\tif (options.partitioned === undefined) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (options.delimited === undefined) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (options.delimiter === undefined) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n\t\tif (options.partitioned === true && options.partition !== undefined && options.partition >= 0) {\n\t\t\treturn this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: options.partition\n\t\t\t});\n\t\t}\n\n\t\t// not just an individual collection, so we will need to serialize db container via shallow copy\n\t\tdbcopy = new Loki(this.filename);\n\t\tdbcopy.loadJSONObject(this);\n\n\t\tfor (idx = 0; idx < dbcopy.collections.length; idx++) {\n\t\t\tdbcopy.collections[idx].data = [];\n\t\t}\n\n\t\t// if we -only- wanted the db container portion, return it now\n\t\tif (options.partitioned === true && options.partition === -1) {\n\t\t\t// since we are deconstructing, override serializationMethod to normal for here\n\t\t\treturn dbcopy.serialize({\n\t\t\t\tserializationMethod: \"normal\"\n\t\t\t});\n\t\t}\n\n\t\t// at this point we must be deconstructing the entire database\n\t\t// start by pushing db serialization into first array element\n\t\treconstruct.push(dbcopy.serialize({\n\t\t\tserializationMethod: \"normal\"\n\t\t}));\n\n\t\tdbcopy = null;\n\n\t\t// push collection data into subsequent elements\n\t\tfor (idx = 0; idx < this.collections.length; idx++) {\n\t\t\tresult = this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: idx\n\t\t\t});\n\n\t\t\t// NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n\t\t\tif (options.partitioned === false && options.delimited === false) {\n\t\t\t\tif (!Array.isArray(result)) {\n\t\t\t\t\tthrow new Error(\"a nondelimited, non partitioned collection serialization did not return an expected array\");\n\t\t\t\t}\n\n\t\t\t\t// Array.concat would probably duplicate memory overhead for copying strings.\n\t\t\t\t// Instead copy each individually, and clear old value after each copy.\n\t\t\t\t// Hopefully this will allow g.c. to reduce memory pressure, if needed.\n\t\t\t\tresultlen = result.length;\n\n\t\t\t\tfor (sidx = 0; sidx < resultlen; sidx++) {\n\t\t\t\t\treconstruct.push(result[sidx]);\n\t\t\t\t\tresult[sidx] = null;\n\t\t\t\t}\n\n\t\t\t\treconstruct.push(\"\");\n\t\t\t} else {\n\t\t\t\treconstruct.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n\t\tif (options.partitioned) {\n\t\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t\t// useful for simple future adaptations of existing persistence adapters to save collections separately\n\t\t\tif (options.delimited) {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t\t// This format might be the most versatile for 'rolling your own' partitioned sync or save.\n\t\t\t// Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n\t\t\telse {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t} else {\n\t\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t\t// This is the method Loki will use internally if 'destructured'.\n\t\t\t// Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n\t\t\tif (options.delimited) {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct.join(options.delimiter);\n\t\t\t}\n\t\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\t\t\t// This format might be best candidate for custom synchronous syncs or saves\n\t\t\telse {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Utility method to serialize a collection in a 'destructured' format\n\t *\n\t * @param {object} options - used to determine output of method\n\t * @param {int=} options.delimited - whether to return single delimited string or an array\n\t * @param {string=} options.delimiter - (optional) if delimited, this is delimiter to use\n\t * @param {int} options.collectionIndex -  specify which collection to serialize data for\n\t *\n\t * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n\t */\n\tserializeCollection(options = {}) {\n\t\tlet doccount;\n\t\tlet docidx;\n\t\tlet resultlines = [];\n\n\t\tif (options.delimited === undefined) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (options.collectionIndex === undefined) {\n\t\t\tthrow new Error(\"serializeCollection called without 'collectionIndex' option\");\n\t\t}\n\n\t\tdoccount = this.collections[options.collectionIndex].data.length;\n\n\t\tresultlines = [];\n\n\t\tfor (docidx = 0; docidx < doccount; docidx++) {\n\t\t\tresultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));\n\t\t}\n\n\t\t// D and DA\n\t\tif (options.delimited) {\n\t\t\t// indicate no more documents in collection (via empty delimited string)\n\t\t\tresultlines.push(\"\");\n\n\t\t\treturn resultlines.join(options.delimiter);\n\t\t} else {\n\t\t\t// NDAA and NDA\n\t\t\treturn resultlines;\n\t\t}\n\t}\n\n\t/**\n\t * Destructured JSON deserialization routine to minimize memory overhead.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {string|array} destructuredSource - destructured json or array to deserialize from\n\t * @param {object=} options - source format options\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to deserialize only a single partition\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n\t */\n\tdeserializeDestructured(destructuredSource, options = {}) {\n\t\tlet workarray = [];\n\t\tlet len;\n\t\tlet cdb;\n\t\tlet idx;\n\t\tlet collIndex = 0;\n\t\tlet collCount;\n\t\tlet lineIndex = 1;\n\t\tlet done = false;\n\t\tlet currLine;\n\t\tlet currObject;\n\n\t\tif (options.partitioned === undefined) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (options.delimited === undefined) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (options.delimiter === undefined) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// Partitioned\n\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t// -or- single partition\n\t\tif (options.partitioned) {\n\t\t\t// handle single partition\n\t\t\tif (options.partition !== undefined) {\n\t\t\t\t// db only\n\t\t\t\tif (options.partition === -1) {\n\t\t\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\n\t\t\t\t\treturn cdb;\n\t\t\t\t}\n\n\t\t\t\t// single collection, return doc array\n\t\t\t\treturn this.deserializeCollection(destructuredSource[options.partition + 1], options);\n\t\t\t}\n\n\t\t\t// Otherwise we are restoring an entire partitioned db\n\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\t\t\tcollCount = cdb.collections.length;\n\t\t\tfor (collIndex = 0; collIndex < collCount; collIndex++) {\n\t\t\t\t// attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n\t\t\t\tcdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n\t\t\t}\n\n\t\t\treturn cdb;\n\t\t}\n\n\t\t// Non-Partitioned\n\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\n\t\t// D\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tdestructuredSource = null; // lower memory pressure\n\t\t\tlen = workarray.length;\n\n\t\t\tif (len === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// NDA\n\t\telse {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\t// first line is database and collection shells\n\t\tcdb = JSON.parse(workarray[0]);\n\t\tcollCount = cdb.collections.length;\n\t\tworkarray[0] = null;\n\n\t\twhile (!done) {\n\t\t\tcurrLine = workarray[lineIndex];\n\n\t\t\t// empty string indicates either end of collection or end of file\n\t\t\tif (workarray[lineIndex] === \"\") {\n\t\t\t\t// if no more collections to load into, we are done\n\t\t\t\tif (++collIndex > collCount) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrObject = JSON.parse(workarray[lineIndex]);\n\t\t\t\tcdb.collections[collIndex].data.push(currObject);\n\t\t\t}\n\n\t\t\t// lower memory pressure and advance iterator\n\t\t\tworkarray[lineIndex++] = null;\n\t\t}\n\n\t\treturn cdb;\n\t}\n\n\t/**\n\t * Deserializes a destructured collection.\n\t *\n\t * @param {string|Array} destructuredSource - destructured representation of collection to inflate\n\t * @param {object} options - used to describe format of destructuredSource input\n\t * @param {int} options.delimited - whether source is delimited string or an array\n\t * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n\t *\n\t * @returns {Array} an array of documents to attach to collection.data.\n\t */\n\tdeserializeCollection(destructuredSource, options = {}) {\n\t\tlet workarray = [];\n\t\tlet idx;\n\t\tlet len;\n\n\t\tif (options.partitioned === undefined) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (options.delimited === undefined) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (options.delimiter === undefined) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tworkarray.pop();\n\t\t} else {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\tlen = workarray.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tworkarray[idx] = JSON.parse(workarray[idx]);\n\t\t}\n\n\t\treturn workarray;\n\t}\n\n\t/**\n\t * Inflates a loki database from a serialized JSON string\n\t *\n\t * @param {string} serializedDb - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t */\n\tloadJSON(serializedDb, options) {\n\t\tlet dbObject;\n\t\tif (serializedDb.length === 0) {\n\t\t\tdbObject = {};\n\t\t} else {\n\t\t\t// using option defined in instantiated db not what was in serialized db\n\t\t\tswitch (this.options.serializationMethod) {\n\t\t\t\tcase \"normal\":\n\t\t\t\tcase \"pretty\":\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"destructured\":\n\t\t\t\t\tdbObject = this.deserializeDestructured(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.loadJSONObject(dbObject, options);\n\t}\n\n\t/**\n\t * Inflates a loki database from a JS object\n\t *\n\t * @param {object} dbObject - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool?} options.retainDirtyFlags - whether collection dirty flags will be preserved\n\t */\n\tloadJSONObject(dbObject, options) {\n\t\tlet i = 0;\n\t\tconst len = dbObject.collections ? dbObject.collections.length : 0;\n\t\tlet coll;\n\t\tlet copyColl;\n\t\tlet clen;\n\t\tlet j;\n\t\tlet loader;\n\t\tlet collObj;\n\n\t\tthis.name = dbObject.name;\n\t\tthis.collections = [];\n\n\t\tfunction makeLoader(coll) {\n\t\t\tconst collOptions = options[coll.name];\n\t\t\tlet inflater;\n\n\t\t\tif (collOptions.proto) {\n\t\t\t\tinflater = collOptions.inflate || copyProperties;\n\n\t\t\t\treturn (data) => {\n\t\t\t\t\tconst collObj = new (collOptions.proto)();\n\t\t\t\t\tinflater(data, collObj);\n\t\t\t\t\treturn collObj;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn collOptions.inflate;\n\t\t}\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tcoll = dbObject.collections[i];\n\t\t\tcopyColl = this.addCollection(coll.name, {disableChangesApi: coll.disableChangesApi});\n\n\t\t\tcopyColl.adaptiveBinaryIndices = coll.adaptiveBinaryIndices !== undefined ? (coll.adaptiveBinaryIndices === true) : false;\n\t\t\tcopyColl.transactional = coll.transactional;\n\t\t\tcopyColl.asyncListeners = coll.asyncListeners;\n\t\t\tcopyColl.disableChangesApi = coll.disableChangesApi;\n\t\t\tcopyColl.cloneObjects = coll.cloneObjects;\n\t\t\tcopyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n\t\t\tcopyColl.autoupdate = coll.autoupdate;\n\t\t\tcopyColl.changes = coll.changes;\n\n\t\t\tif (options && options.retainDirtyFlags === true) {\n\t\t\t\tcopyColl.dirty = coll.dirty;\n\t\t\t} else {\n\t\t\t\tcopyColl.dirty = false;\n\t\t\t}\n\n\t\t\t// load each element individually\n\t\t\tclen = coll.data.length;\n\t\t\tj = 0;\n\t\t\tif (options && options[coll.name] !== undefined) {\n\t\t\t\tloader = makeLoader(coll);\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcollObj = loader(coll.data[j]);\n\t\t\t\t\tcopyColl.data[j] = collObj;\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(collObj);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcopyColl.data[j] = coll.data[j];\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(copyColl.data[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcopyColl.maxId = (typeof coll.maxId === 'undefined') ? 0 : coll.maxId;\n\t\t\tcopyColl.idIndex = coll.idIndex;\n\t\t\tif (coll.binaryIndices !== undefined) {\n\t\t\t\tcopyColl.binaryIndices = coll.binaryIndices;\n\t\t\t}\n\t\t\tif (coll.transforms !== undefined) {\n\t\t\t\tcopyColl.transforms = coll.transforms;\n\t\t\t}\n\n\t\t\tcopyColl.ensureId();\n\n\t\t\t// regenerate unique indexes\n\t\t\tcopyColl.uniqueNames = [];\n\t\t\tif (coll.uniqueNames !== undefined) {\n\t\t\t\tcopyColl.uniqueNames = coll.uniqueNames;\n\t\t\t\tfor (j = 0; j < copyColl.uniqueNames.length; j++) {\n\t\t\t\t\tcopyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case they are loading a database created before we added dynamic views, handle undefined\n\t\t\tif (coll.DynamicViews === undefined)\n\t\t\t\tcontinue;\n\n\t\t\t// reinflate DynamicViews and attached Resultsets\n\t\t\tfor (let idx = 0; idx < coll.DynamicViews.length; idx++) {\n\t\t\t\tconst colldv = coll.DynamicViews[idx];\n\n\t\t\t\tconst dv = copyColl.addDynamicView(colldv.name, colldv.options);\n\t\t\t\tdv.resultdata = colldv.resultdata;\n\t\t\t\tdv.resultsdirty = colldv.resultsdirty;\n\t\t\t\tdv.filterPipeline = colldv.filterPipeline;\n\n\t\t\t\tdv.sortCriteria = colldv.sortCriteria;\n\t\t\t\tdv.sortFunction = null;\n\n\t\t\t\tdv.sortDirty = colldv.sortDirty;\n\t\t\t\tdv.resultset.filteredrows = colldv.resultset.filteredrows;\n\t\t\t\tdv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\n\t\t\t\tdv.rematerialize({\n\t\t\t\t\tremoveWhereFilters: true\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Upgrade Logic for binary index refactoring at version 1.5\n\t\t\tif (dbObject.databaseVersion < 1.5) {\n\t\t\t\t// rebuild all indices\n\t\t\t\tcopyColl.ensureAllIndexes(true);\n\t\t\t\tcopyColl.dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n\t * Does not actually destroy the db.\n\t *\n\t * @returns {Promise} a Promise that resolves after closing the database succeeded\n\t */\n\tclose() {\n\t\tlet saved;\n\t\t// for autosave scenarios, we will let close perform final save (if dirty)\n\t\t// For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n\t\tif (this.autosave) {\n\t\t\tthis.autosaveDisable();\n\t\t\t// Check if collections are dirty.\n\t\t\tfor (let idx = 0; idx < this.collections.length; idx++) {\n\t\t\t\tif (this.collections[idx].dirty) {\n\t\t\t\t\tsaved = this.saveDatabase();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(() => {\n\t\t\tthis.emit('close');\n\t\t});\n\t}\n\n\t/**-------------------------+\n\t | Changes API               |\n\t +--------------------------*/\n\n\t/**\n\t * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n\t * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n\t */\n\n\t/**\n\t * (Changes API) : takes all the changes stored in each\n\t * collection and creates a single array for the entire database. If an array of names\n\t * of collections is passed then only the included collections will be tracked.\n\t *\n\t * @param {Array=} optional array of collection names. No arg means all collections are processed.\n\t * @returns {Array} array of changes\n\t * @see private method createChange() in Collection\n\t */\n\tgenerateChangesNotification(arrayOfCollectionNames) {\n\t\tfunction getCollName(coll) {\n\t\t\treturn coll.name;\n\t\t}\n\n\t\tlet changes = [];\n\t\tconst selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\n\t\tthis.collections.forEach((coll) => {\n\t\t\tif (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n\t\t\t\tchanges = changes.concat(coll.getChanges());\n\t\t\t}\n\t\t});\n\t\treturn changes;\n\t}\n\n\t/**\n\t * (Changes API) - stringify changes for network transmission\n\t * @returns {string} string representation of the changes\n\t */\n\tserializeChanges(collectionNamesArray) {\n\t\treturn JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n\t}\n\n\t/**\n\t * (Changes API) : clears all the changes in all collections.\n\t */\n\tclearChanges() {\n\t\tthis.collections.forEach((coll) => {\n\t\t\tif (coll.flushChanges) {\n\t\t\t\tcoll.flushChanges();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Wait for throttledSaves to complete and invoke your callback when drained or duration is met.\n\t *\n\t * @param {object=} options - configuration options\n\t * @param {boolean} options.recursiveWait - (default: true) if after queue is drained, another save was kicked off, wait for it\n\t * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n\t * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n\t * @returns {Promise} a Promise that resolves when save queue is drained, it is passed a sucess parameter value\n\t */\n\tthrottledSaveDrain(options = {}) {\n\t\tconst now = (new Date()).getTime();\n\n\t\tif (!this._throttledSaves) {\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\tif (options.recursiveWait === undefined) {\n\t\t\toptions.recursiveWait = true;\n\t\t}\n\t\tif (options.recursiveWaitLimit === undefined) {\n\t\t\toptions.recursiveWaitLimit = false;\n\t\t}\n\t\tif (options.recursiveWaitLimitDuration === undefined) {\n\t\t\toptions.recursiveWaitLimitDuration = 2000;\n\t\t}\n\t\tif (options.started === undefined) {\n\t\t\toptions.started = (new Date()).getTime();\n\t\t}\n\n\t\t// if save is pending\n\t\tif (this._throttledSaves && this._throttledSaveRunning !== null) {\n\t\t\t// if we want to wait until we are in a state where there are no pending saves at all\n\t\t\tif (options.recursiveWait) {\n\t\t\t\t// queue the following meta callback for when it completes\n\t\t\t\treturn Promise.resolve(Promise.all([this._throttledSaveRunning, this._throttledSavePending])).then(() => {\n\t\t\t\t\tif (this._throttledSaveRunning !== null || this._throttledSavePending !== null) {\n\t\t\t\t\t\tif (options.recursiveWaitLimit && (now - options.started > options.recursiveWaitLimitDuration)) {\n\t\t\t\t\t\t\treturn Promise.reject();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn this.throttledSaveDrain(options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t// just notify when current queue is depleted\n\t\t\telse {\n\t\t\t\treturn Promise.resolve(this._throttledSaveRunning);\n\t\t\t}\n\t\t}\n\t\t// no save pending, just callback\n\t\telse {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Internal load logic, decoupled from throttling/contention logic\n\t *\n\t * @param {object} options - an object containing inflation options for each collection\n\t * @returns {Promise} a Promise that resolves after the database is loaded\n\t */\n\t_loadDatabase(options = {}) {\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.loadDatabase(this.filename))\n\t\t\t.then((dbString) => {\n\t\t\t\tif (typeof (dbString) === 'string') {\n\t\t\t\t\tthis.loadJSON(dbString, options);\n\t\t\t\t\tthis.emit('load', this);\n\t\t\t\t} else {\n\t\t\t\t\t// if adapter has returned an js object (other than null or error) attempt to load from JSON object\n\t\t\t\t\tif (typeof (dbString) === \"object\" && dbString !== null && !(dbString instanceof Error)) {\n\t\t\t\t\t\tthis.loadJSONObject(dbString, options);\n\t\t\t\t\t\tthis.emit('load', this);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dbString instanceof Error)\n\t\t\t\t\t\t\tthrow dbString;\n\n\t\t\t\t\t\tthrow new TypeError('The persistence adapter did not load a serialized DB string or object.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles loading from file system, local storage, or adapter (indexeddb)\n\t *    This method utilizes loki configuration options (if provided) to determine which\n\t *    persistence method to use, or environment detection (if configuration was not provided).\n\t *    To avoid contention with any throttledSaves, we will drain the save queue first.\n\t *\n\t * @param {object} options - if throttling saves and loads, this controls how we drain save queue before loading\n\t * @param {boolean} options.recursiveWait - (default: true) wait recursively until no saves are queued\n\t * @param {bool} options.recursiveWaitLimit - (default: false) limit our recursive waiting to a duration\n\t * @param {int} options.recursiveWaitLimitDelay - (default: 2000) cutoff in ms to stop recursively re-draining\n\t * @returns {Promise} a Promise that resolves after the database is loaded\n\t */\n\tloadDatabase(options) {\n\t\t// if throttling disabled, just call internal\n\t\tif (!this._throttledSaves) {\n\t\t\treturn this._loadDatabase(options);\n\t\t}\n\n\t\t// try to drain any pending saves in the queue to lock it for loading\n\t\treturn this.throttledSaveDrain(options).then(() => {\n\t\t\t// pause/throttle saving until loading is done\n\t\t\tthis._throttledSaveRunning = this._loadDatabase(options).then(() => {\n\t\t\t\t// now that we are finished loading, if no saves were throttled, disable flag\n\t\t\t\tthis._throttledSaveRunning = null;\n\t\t\t});\n\t\t\treturn this._throttledSaveRunning;\n\t\t}, () => {\n\t\t\tthrow new Error(\"Unable to pause save throttling long enough to read database\");\n\t\t});\n\t}\n\n\t_saveDatabase() {\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\tlet saved;\n\n\t\t// check if the adapter is requesting (and supports) a 'reference' mode export\n\t\tif (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n\t\t\t// filename may seem redundant but loadDatabase will need to expect this same filename\n\t\t\tsaved = this.persistenceAdapter.exportDatabase(this.filename, this.copy({removeNonSerializable: true}));\n\t\t}\n\t\t// otherwise just pass the serialized database to adapter\n\t\telse {\n\t\t\tsaved = this.persistenceAdapter.saveDatabase(this.filename, this.serialize());\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(() => {\n\t\t\t// Set all collection not dirty.\n\t\t\tfor (let idx = 0; idx < this.collections.length; idx++) {\n\t\t\t\tthis.collections[idx].dirty = false;\n\t\t\t}\n\t\t\tthis.emit(\"save\");\n\t\t});\n\t}\n\n\t/**\n\t * Handles saving to file system, local storage, or adapter (indexeddb)\n\t *    This method utilizes loki configuration options (if provided) to determine which\n\t *    persistence method to use, or environment detection (if configuration was not provided).\n\t *\n\t * @returns {Promise} a Promise that resolves after the database is persisted\n\t */\n\tsaveDatabase() {\n\t\tif (!this._throttledSaves) {\n\t\t\treturn this._saveDatabase();\n\t\t}\n\n\t\t// if the db save is currently running, a new promise for a next db save is created\n\t\t// all calls to save db will get this new promise which will be processed right after\n\t\t// the current db save is finished\n\t\tif (this._throttledSaveRunning !== null && this._throttledSavePending === null) {\n\t\t\tthis._throttledSavePending = Promise.resolve(this._throttledSaveRunning).then(() => {\n\t\t\t\tthis._throttledSaveRunning = null;\n\t\t\t\tthis._throttledSavePending = null;\n\t\t\t\treturn this.saveDatabase();\n\t\t\t});\n\t\t}\n\t\tif (this._throttledSavePending !== null) {\n\t\t\treturn this._throttledSavePending;\n\t\t}\n\t\tthis._throttledSaveRunning = this._saveDatabase().then(() => {\n\t\t\tthis._throttledSaveRunning = null;\n\t\t});\n\n\t\treturn this._throttledSaveRunning;\n\t}\n\n\t/**\n\t * Handles deleting a database from file system, local storage, or adapter (indexeddb)\n\t *\n\t * @returns {Promise} a Promise that resolves after the database is deleted\n\t */\n\tdeleteDatabase() {\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.deleteDatabase(this.filename));\n\t}\n\n\t/**\n\t * autosaveEnable - begin a javascript interval to periodically save the database.\n\t *\n\t */\n\tautosaveEnable() {\n\t\tif (this.autosaveHandle) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet running = true;\n\n\t\tthis.autosave = true;\n\t\tthis.autosaveHandle = () => {\n\t\t\trunning = false;\n\t\t\tthis.autosaveHandle = undefined;\n\t\t};\n\n\t\t(() => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (running) {\n\t\t\t\t\tthis.saveDatabase().then(saveDatabase, saveDatabase);\n\t\t\t\t}\n\t\t\t}, this.autosaveInterval);\n\t\t})();\n\t}\n\n\t/**\n\t * autosaveDisable - stop the autosave interval timer.\n\t *\n\t */\n\tautosaveDisable() {\n\t\tthis.autosave = false;\n\n\t\tif (this.autosaveHandle) {\n\t\t\tthis.autosaveHandle();\n\t\t}\n\t}\n}\n\nLoki.Plugins = {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/loki.js\n// module id = 6\n// module chunks = 0","import {clone} from './clone';\nimport {Collection} from './collection';\nimport {resolveTransformParams} from './utils';\nimport {ltHelper, gtHelper, aeqHelper} from './helper';\n\n/*\n 'Utils' is not defined                 no-undef\t(resolveTransformParams)\n 'sortHelper' is not defined            no-undef\n 'compoundeval' is not defined          no-undef\n 'indexedOpsList' is not defined        no-undef\n 'LokiOps' is not defined               no-undef\n 'dotSubScan' is not defined            no-undef\n 'clone' is not defined                 no-undef\n\n\n */\n\nfunction containsCheckFn(a) {\n\tif (typeof a === 'string' || Array.isArray(a)) {\n\t\treturn (b) => a.indexOf(b) !== -1;\n\t} else if (typeof a === 'object' && a !== null) {\n\t\treturn (b) => hasOwnProperty.call(a, b);\n\t}\n\treturn null;\n}\n\nfunction doQueryOp(val, op) {\n\tfor (let p in op) {\n\t\tif (hasOwnProperty.call(op, p)) {\n\t\t\treturn LokiOps[p](val, op[p]);\n\t\t}\n\t}\n\treturn false;\n}\n\n\nexport const LokiOps = {\n\t// comparison operators\n\t// a is the value in the collection\n\t// b is the query value\n\t$eq(a, b) {\n\t\treturn a === b;\n\t},\n\n\t// abstract/loose equality\n\t$aeq(a, b) {\n\t\treturn a == b;\n\t},\n\n\t$ne(a, b) {\n\t\t// ecma 5 safe test for NaN\n\t\tif (b !== b) {\n\t\t\t// ecma 5 test value is not NaN\n\t\t\treturn (a === a);\n\t\t}\n\n\t\treturn a !== b;\n\t},\n\n\t// date equality / loki abstract equality test\n\t$dteq(a, b) {\n\t\treturn aeqHelper(a, b);\n\t},\n\n\t$gt(a, b) {\n\t\treturn gtHelper(a, b, false);\n\t},\n\n\t$gte(a, b) {\n\t\treturn gtHelper(a, b, true);\n\t},\n\n\t$lt(a, b) {\n\t\treturn ltHelper(a, b, false);\n\t},\n\n\t$lte(a, b) {\n\t\treturn ltHelper(a, b, true);\n\t},\n\n\t// ex : coll.find({'orderCount': {$between: [10, 50]}});\n\t$between(a, vals) {\n\t\tif (a === undefined || a === null) return false;\n\t\treturn (gtHelper(a, vals[0], true) && ltHelper(a, vals[1], true));\n\t},\n\n\t$in(a, b) {\n\t\treturn b.indexOf(a) !== -1;\n\t},\n\n\t$nin(a, b) {\n\t\treturn b.indexOf(a) === -1;\n\t},\n\n\t$keyin(a, b) {\n\t\treturn a in b;\n\t},\n\n\t$nkeyin(a, b) {\n\t\treturn !(a in b);\n\t},\n\n\t$definedin(a, b) {\n\t\treturn b[a] !== undefined;\n\t},\n\n\t$undefinedin(a, b) {\n\t\treturn b[a] === undefined;\n\t},\n\n\t$regex(a, b) {\n\t\treturn b.test(a);\n\t},\n\n\t$containsString(a, b) {\n\t\treturn (typeof a === 'string') && (a.indexOf(b) !== -1);\n\t},\n\n\t$containsNone(a, b) {\n\t\treturn !LokiOps.$containsAny(a, b);\n\t},\n\n\t$containsAny(a, b) {\n\t\tconst checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$contains(a, b) {\n\t\tconst checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$type(a, b) {\n\t\tlet type = typeof a;\n\t\tif (type === 'object') {\n\t\t\tif (Array.isArray(a)) {\n\t\t\t\ttype = 'array';\n\t\t\t} else if (a instanceof Date) {\n\t\t\t\ttype = 'date';\n\t\t\t}\n\t\t}\n\t\treturn (typeof b !== 'object') ? (type === b) : doQueryOp(type, b);\n\t},\n\n\t$finite(a, b) {\n\t\treturn (b === isFinite(a));\n\t},\n\n\t$size(a, b) {\n\t\tif (Array.isArray(a)) {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$len(a, b) {\n\t\tif (typeof a === 'string') {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$where(a, b) {\n\t\treturn b(a) === true;\n\t},\n\n\t// field-level logical operators\n\t// a is the value in the collection\n\t// b is the nested query operation (for '$not')\n\t//   or an array of nested query operations (for '$and' and '$or')\n\t$not(a, b) {\n\t\treturn !doQueryOp(a, b);\n\t},\n\n\t$and(a, b) {\n\t\tfor (let idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (!doQueryOp(a, b[idx])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t$or(a, b) {\n\t\tfor (let idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (doQueryOp(a, b[idx])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\n// if an op is registered in this object, our 'calculateRange' can use it with our binary indices.\n// if the op is registered to a function, we will run that function/op as a 2nd pass filter on results.\n// those 2nd pass filter functions should be similar to LokiOps functions, accepting 2 vals to compare.\nconst indexedOps = {\n\t$eq: LokiOps.$eq,\n\t$aeq: true,\n\t$dteq: true,\n\t$gt: true,\n\t$gte: true,\n\t$lt: true,\n\t$lte: true,\n\t$in: true,\n\t$between: true\n};\n\n\nfunction sortHelper(prop1, prop2, desc) {\n\tif (prop1 === prop2) {\n\t\treturn 0;\n\t}\n\n\tif (ltHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (1) : (-1);\n\t}\n\n\tif (gtHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (-1) : (1);\n\t}\n\n\t// not lt, not gt so implied equality-- date compatible\n\treturn 0;\n}\n\n/**\n * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n *\n * @param {array} properties - array of property names, in order, by which to evaluate sort order\n * @param {object} obj1 - first object to compare\n * @param {object} obj2 - second object to compare\n * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n */\nfunction compoundeval(properties, obj1, obj2) {\n\tlet res = 0;\n\tlet prop;\n\tlet field;\n\tfor (let i = 0, len = properties.length; i < len; i++) {\n\t\tprop = properties[i];\n\t\tfield = prop[0];\n\t\tres = sortHelper(obj1[field], obj2[field], prop[1]);\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n/**\n * dotSubScan - helper function used for dot notation queries.\n *\n * @param {object} root - object to traverse\n * @param {array} paths - array of properties to drill into\n * @param {function} fun - evaluation function to test with\n * @param {any} value - comparative value to also pass to (compare) fun\n * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n */\nfunction dotSubScan(root, paths, fun, value, poffset) {\n\tconst pathOffset = poffset || 0;\n\tconst path = paths[pathOffset];\n\tif (root === undefined || root === null || root[path] === undefined) {\n\t\treturn false;\n\t}\n\n\tlet valueFound = false;\n\tconst element = root[path];\n\tif (pathOffset + 1 >= paths.length) {\n\t\t// if we have already expanded out the dot notation,\n\t\t// then just evaluate the test function and value on the element\n\t\tvalueFound = fun(element, value);\n\t} else if (Array.isArray(element)) {\n\t\tfor (let index = 0, len = element.length; index < len; index += 1) {\n\t\t\tvalueFound = dotSubScan(element[index], paths, fun, value, pathOffset + 1);\n\t\t\tif (valueFound === true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvalueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);\n\t}\n\n\treturn valueFound;\n}\n\n/**\n * Resultset class allowing chainable queries.  Intended to be instanced internally.\n *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n *\n * @example\n *    mycollection.chain()\n *      .find({ 'doors' : 4 })\n *      .where(function(obj) { return obj.name === 'Toyota' })\n *      .data();\n */\nexport class Resultset {\n\t/**\n\t * Constructor.\n\t * @param {Collection} collection - the collection which this Resultset will query against\n\t * @returns {Resultset}\n\t */\n\tconstructor(collection) {\n\t\t// retain reference to collection we are querying against\n\t\tthis.collection = collection;\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * reset() - Reset the resultset to its initial state.\n\t *\n\t * @returns {Resultset} Reference to this resultset, for future chain operations.\n\t */\n\treset() {\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tthis.filteredrows = [];\n\t\t}\n\t\tthis.filterInitialized = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tconst copy = this.copy();\n\t\tcopy.collection = null;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Allows you to limit the number of documents passed to next chain operation.\n\t *    A resultset copy() is made to avoid altering original resultset.\n\t *\n\t * @param {int} qty - The number of documents to return.\n\t * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\tlimit(qty) {\n\t\t// if this has no filters applied, we need to populate filteredrows first\n\t\tif (!this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tthis.filteredrows =\tthis.filteredrows.slice(0, qty);\n\t\tthis.filterInitialized = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Used for skipping 'pos' number of documents in the resultset.\n\t *\n\t * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n\t * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\toffset(pos) {\n\t\t// if this has no filters applied, we need to populate filteredrows first\n\t\tif (!this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tthis.filteredrows =\tthis.filteredrows.slice(pos);\n\t\tthis.filterInitialized = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * copy() - To support reuse of resultset in branched query situations.\n\t *\n\t * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n\t * @memberof Resultset\n\t */\n\tcopy() {\n\t\tconst result = new Resultset(this.collection);\n\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tresult.filteredrows = this.filteredrows.slice();\n\t\t}\n\t\tresult.filterInitialized = this.filterInitialized;\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Alias of copy()\n\t * @memberof Resultset\n\t */\n\tbranch() {\n\t\treturn this.copy();\n\t}\n\n\t/**\n\t * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n\t *\n\t * @param transform {(string|array)} - name of collection transform or raw transform array\n\t * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n\t * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n\t * @memberof Resultset\n\t */\n\ttransform(transform, parameters) {\n\t\tlet idx;\n\t\tlet step;\n\t\tlet rs = this;\n\n\t\t// if transform is name, then do lookup first\n\t\tif (typeof transform === 'string') {\n\t\t\tif (this.collection.transforms[transform] !== undefined) {\n\t\t\t\ttransform = this.collection.transforms[transform];\n\t\t\t}\n\t\t}\n\n\t\t// either they passed in raw transform array or we looked it up, so process\n\t\tif (typeof transform !== 'object' || !Array.isArray(transform)) {\n\t\t\tthrow new Error(\"Invalid transform\");\n\t\t}\n\n\t\tif (typeof parameters !== 'undefined') {\n\t\t\ttransform = resolveTransformParams(transform, parameters);\n\t\t}\n\n\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\tstep = transform[idx];\n\n\t\t\tswitch (step.type) {\n\t\t\t\tcase \"find\":\n\t\t\t\t\trs.find(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"where\":\n\t\t\t\t\trs.where(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"simplesort\":\n\t\t\t\t\trs.simplesort(step.property, step.desc);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"compoundsort\":\n\t\t\t\t\trs.compoundsort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sort\":\n\t\t\t\t\trs.sort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"limit\":\n\t\t\t\t\trs = rs.limit(step.value);\n\t\t\t\t\tbreak; // limit makes copy so update reference\n\t\t\t\tcase \"offset\":\n\t\t\t\t\trs = rs.offset(step.value);\n\t\t\t\t\tbreak; // offset makes copy so update reference\n\t\t\t\tcase \"map\":\n\t\t\t\t\trs = rs.map(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"eqJoin\":\n\t\t\t\t\trs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases break chain by returning array data so make any of these last in transform steps\n\t\t\t\tcase \"mapReduce\":\n\t\t\t\t\trs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases update documents in current filtered resultset (use carefully)\n\t\t\t\tcase \"update\":\n\t\t\t\t\trs.update(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\trs.remove();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn rs;\n\t}\n\n\t/**\n\t * User supplied compare function is provided two documents to compare. (chainable)\n\t * @example\n\t *    rslt.sort(function(obj1, obj2) {\n\t *      if (obj1.name === obj2.name) return 0;\n\t *      if (obj1.name > obj2.name) return 1;\n\t *      if (obj1.name < obj2.name) return -1;\n\t *    });\n\t *\n\t * @param {function} comparefun - A javascript compare function used for sorting.\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsort(comparefun) {\n\t\t// if this has no filters applied, just we need to populate filteredrows first\n\t\tif (!this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tconst wrappedComparer =\n\t\t\t(((userComparer, data) => (a, b) => userComparer(data[a], data[b])))(comparefun, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n\t *    Sorting based on the same lt/gt helper functions used for binary indices.\n\t *\n\t * @param {string} propname - name of property to sort by.\n\t * @param {bool=} isdesc - (Optional) If true, the property will be sorted in descending order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsimplesort(propname, isdesc) {\n\t\tif (typeof (isdesc) === 'undefined') {\n\t\t\tisdesc = false;\n\t\t}\n\n\t\t// if this has no filters applied, just we need to populate filteredrows first\n\t\tif (!this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t// if we have a binary index and no other filters applied, we can use that instead of sorting (again)\n\t\t\tif (this.collection.binaryIndices[propname] !== undefined) {\n\t\t\t\t// make sure index is up-to-date\n\t\t\t\tthis.collection.ensureIndex(propname);\n\t\t\t\t// copy index values into filteredrows\n\t\t\t\tthis.filteredrows = this.collection.binaryIndices[propname].values.slice(0);\n\n\t\t\t\tif (isdesc) {\n\t\t\t\t\tthis.filteredrows.reverse();\n\t\t\t\t}\n\n\t\t\t\t// we are done, return this (resultset) for further chain ops\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t// otherwise initialize array for sort below\n\t\t\telse {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\t}\n\n\t\tconst wrappedComparer =\n\t\t\t(((prop, desc, data) => (a, b) => sortHelper(data[a][prop], data[b][prop], desc)))(propname, isdesc, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * rs.compoundsort(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * rs.compoundsort(['age', ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tcompoundsort(properties) {\n\t\tif (properties.length === 0) {\n\t\t\tthrow new Error(\"Invalid call to compoundsort, need at least one property\");\n\t\t}\n\n\t\tlet prop;\n\t\tif (properties.length === 1) {\n\t\t\tprop = properties[0];\n\t\t\tif (Array.isArray(prop)) {\n\t\t\t\treturn this.simplesort(prop[0], prop[1]);\n\t\t\t}\n\t\t\treturn this.simplesort(prop, false);\n\t\t}\n\n\t\t// unify the structure of 'properties' to avoid checking it repeatedly while sorting\n\t\tfor (let i = 0, len = properties.length; i < len; i += 1) {\n\t\t\tprop = properties[i];\n\t\t\tif (!Array.isArray(prop)) {\n\t\t\t\tproperties[i] = [prop, false];\n\t\t\t}\n\t\t}\n\n\t\t// if this has no filters applied, just we need to populate filteredrows first\n\t\tif (!this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tconst wrappedComparer =\n\t\t\t(((props, data) => (a, b) => compoundeval(props, data[a], data[b])))(properties, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * findOr() - oversee the operation of OR'ed query expressions.\n\t *    OR'ed expression evaluation runs each expression individually against the full collection,\n\t *    and finally does a set OR on each expression's results.\n\t *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindOr(expressionArray) {\n\t\tlet fr = null;\n\t\tlet fri = 0;\n\t\tlet frlen = 0;\n\t\tconst docset = [];\n\t\tconst idxset = [];\n\t\tlet idx = 0;\n\t\tconst origCount = this.count();\n\n\t\t// If filter is already initialized, then we query against only those items already in filter.\n\t\t// This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n\t\tfor (let ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n\t\t\t// we need to branch existing query to run each filter separately and combine results\n\t\t\tfr = this.branch().find(expressionArray[ei]).filteredrows;\n\t\t\tfrlen = fr.length;\n\t\t\t// if the find operation did not reduce the initial set, then the initial set is the actual result\n\t\t\tif (frlen === origCount) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// add any document 'hits'\n\t\t\tfor (fri = 0; fri < frlen; fri++) {\n\t\t\t\tidx = fr[fri];\n\t\t\t\tif (idxset[idx] === undefined) {\n\t\t\t\t\tidxset[idx] = true;\n\t\t\t\t\tdocset.push(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.filteredrows = docset;\n\t\tthis.filterInitialized = true;\n\n\t\treturn this;\n\t}\n\n\t$or(...args) {\n\t\treturn this.findOr(...args);\n\t}\n\n\t/**\n\t * findAnd() - oversee the operation of AND'ed query expressions.\n\t *    AND'ed expression evaluation runs each expression progressively against the full collection,\n\t *    internally utilizing existing chained resultset functionality.\n\t *    Only the first filter can utilize a binary index.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindAnd(expressionArray) {\n\t\t// we have already implementing method chaining in this (our Resultset class)\n\t\t// so lets just progressively apply user supplied and filters\n\t\tfor (let i = 0, len = expressionArray.length; i < len; i++) {\n\t\t\tif (this.count() === 0) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis.find(expressionArray[i]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t$and(...args) {\n\t\treturn this.findAnd(...args);\n\t}\n\n\t/**\n\t * Used for querying via a mongo-style query object.\n\t *\n\t * @param {object} query - A mongo-style query object used for filtering current results.\n\t * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tfind(query, firstOnly) {\n\t\tif (this.collection.data.length === 0) {\n\t\t\tthis.filteredrows = [];\n\t\t\tthis.filterInitialized = true;\n\t\t\treturn this;\n\t\t}\n\n\t\tconst queryObject = query || 'getAll';\n\t\tlet p;\n\t\tlet property;\n\t\tlet queryObjectOp;\n\t\tlet obj;\n\t\tlet operator;\n\t\tlet value;\n\t\tlet key;\n\t\tlet searchByIndex = false;\n\t\tlet result = [];\n\t\tlet filters = [];\n\t\tlet index = null;\n\n\t\t// flag if this was invoked via findOne()\n\t\tfirstOnly = firstOnly || false;\n\n\t\tif (typeof queryObject === 'object') {\n\t\t\tfor (p in queryObject) {\n\t\t\t\tobj = {};\n\t\t\t\tobj[p] = queryObject[p];\n\t\t\t\tfilters.push(obj);\n\n\t\t\t\tif (queryObject[p] !== undefined) {\n\t\t\t\t\tproperty = p;\n\t\t\t\t\tqueryObjectOp = queryObject[p];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if more than one expression in single query object,\n\t\t\t// convert implicit $and to explicit $and\n\t\t\tif (filters.length > 1) {\n\t\t\t\treturn this.find({'$and': filters}, firstOnly);\n\t\t\t}\n\t\t}\n\n\t\t// apply no filters if they want all\n\t\tif (!property || queryObject === 'getAll') {\n\t\t\tif (firstOnly) {\n\t\t\t\tthis.filteredrows = (this.collection.data.length > 0) ? [0] : [];\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\t// injecting $and and $or expression tree evaluation here.\n\t\tif (property === '$and' || property === '$or') {\n\t\t\tthis[property](queryObjectOp);\n\n\t\t\t// for chained find with firstonly,\n\t\t\tif (firstOnly && this.filteredrows.length > 1) {\n\t\t\t\tthis.filteredrows = this.filteredrows.slice(0, 1);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\n\t\t// see if query object is in shorthand mode (assuming eq operator)\n\t\tif (queryObjectOp === null || (typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date)) {\n\t\t\toperator = '$eq';\n\t\t\tvalue = queryObjectOp;\n\t\t} else if (typeof queryObjectOp === 'object') {\n\t\t\tfor (key in queryObjectOp) {\n\t\t\t\tif (queryObjectOp[key] !== undefined) {\n\t\t\t\t\toperator = key;\n\t\t\t\t\tvalue = queryObjectOp[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Do not know what you want to do.');\n\t\t}\n\n\t\t// for regex ops, precompile\n\t\tif (operator === '$regex') {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue = new RegExp(value[0], value[1]);\n\t\t\t} else if (!(value instanceof RegExp)) {\n\t\t\t\tvalue = new RegExp(value);\n\t\t\t}\n\t\t}\n\n\t\tif (query.query) {\n\t\t\tlet res = this.collection._fullTextSearch.search(query);\n\t\t\tlet docIds = Object.keys(res);\n\t\t\tlet results = [];\n\t\t\tfor (let i = 0; i < docIds.length; i++) {\n\t\t\t\tlet docId = parseInt(docIds[i]);\n\t\t\t\tfor (let j = 0; j < this.collection.data.length; j++) {\n\t\t\t\t\tif (this.collection.data[j].$loki === docId) {\n\t\t\t\t\t\tresults.push(this.collection.data[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\t// if user is deep querying the object such as find('name.first': 'odin')\n\t\tconst usingDotNotation = (property.indexOf('.') !== -1);\n\n\t\t// if an index exists for the property being queried against, use it\n\t\t// for now only enabling where it is the first filter applied and prop is indexed\n\t\tvar doIndexCheck = !usingDotNotation && !this.filterInitialized;\n\n\t\tif (doIndexCheck && this.collection.binaryIndices[property] && indexedOps[operator]) {\n\t\t\t// this is where our lazy index rebuilding will take place\n\t\t\t// basically we will leave all indexes dirty until we need them\n\t\t\t// so here we will rebuild only the index tied to this property\n\t\t\t// ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n\t\t\tif (this.collection.adaptiveBinaryIndices !== true) {\n\t\t\t\tthis.collection.ensureIndex(property);\n\t\t\t}\n\n\t\t\tsearchByIndex = true;\n\t\t\tindex = this.collection.binaryIndices[property];\n\t\t}\n\n\t\t// the comparison function\n\t\tconst fun = LokiOps[operator];\n\n\t\t// \"shortcut\" for collection data\n\t\tconst t = this.collection.data;\n\n\t\t// filter data length\n\t\tlet i = 0;\n\n\t\tlet len = 0;\n\n\t\t// Query executed differently depending on :\n\t\t//    - whether the property being queried has an index defined\n\t\t//    - if chained, we handle first pass differently for initial filteredrows[] population\n\t\t//\n\t\t// For performance reasons, each case has its own if block to minimize in-loop calculations\n\n\t\tlet filter;\n\n\t\tlet rowIdx = 0;\n\n\t\t// If the filteredrows[] is already initialized, use it\n\t\tif (this.filterInitialized) {\n\t\t\tfilter = this.filteredrows;\n\t\t\tlen = filter.length;\n\n\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\tif (usingDotNotation) {\n\t\t\t\tproperty = property.split('.');\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (dotSubScan(t[rowIdx], property, fun, value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (fun(t[rowIdx][property], value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// first chained query so work against data[] but put results in filteredrows\n\t\telse {\n\t\t\t// if not searching by index\n\t\t\tif (!searchByIndex) {\n\t\t\t\tlen = t.length;\n\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t\tif (firstOnly) {\n\t\t\t\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\t\t\t\tthis.filterInitialized = true;\n\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t\tif (firstOnly) {\n\t\t\t\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\t\t\t\tthis.filterInitialized = true;\n\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// search by index\n\t\t\t\tconst segm = this.collection.calculateRange(operator, property, value);\n\n\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\tfor (i = segm[0]; i <= segm[1]; i++) {\n\t\t\t\t\t\tif (indexedOps[operator] !== true) {\n\t\t\t\t\t\t\t// must be a function, implying 2nd phase filtering of results from calculateRange\n\t\t\t\t\t\t\tif (indexedOps[operator](t[index.values[i]][property], value)) {\n\t\t\t\t\t\t\t\tresult.push(index.values[i]);\n\t\t\t\t\t\t\t\tif (firstOnly) {\n\t\t\t\t\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\t\t\t\t\tthis.filterInitialized = true;\n\t\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tresult.push(index.values[i]);\n\t\t\t\t\t\t\tif (firstOnly) {\n\t\t\t\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\t\t\t\tthis.filterInitialized = true;\n\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, len = segm.length; i < len; i++) {\n\t\t\t\t\t\tresult.push(index.values[segm[i]]);\n\t\t\t\t\t\tif (firstOnly) {\n\t\t\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\t\t\tthis.filterInitialized = true;\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.filteredrows = result;\n\t\tthis.filterInitialized = true; // next time work against filteredrows[]\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * where() - Used for filtering via a javascript filter function.\n\t *\n\t * @param {function} fun - A javascript function used for filtering current results by.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\twhere(fun) {\n\t\tlet viewFunction;\n\t\tlet result = [];\n\n\t\tif ('function' === typeof fun) {\n\t\t\tviewFunction = fun;\n\t\t} else {\n\t\t\tthrow new TypeError('Argument is not a stored view or a function');\n\t\t}\n\t\ttry {\n\t\t\t// If the filteredrows[] is already initialized, use it\n\t\t\tif (this.filterInitialized) {\n\t\t\t\tlet j = this.filteredrows.length;\n\n\t\t\t\twhile (j--) {\n\t\t\t\t\tif (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n\t\t\t\t\t\tresult.push(this.filteredrows[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.filteredrows = result;\n\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t// otherwise this is initial chained op, work against data, push into filteredrows[]\n\t\t\telse {\n\t\t\t\tlet k = this.collection.data.length;\n\n\t\t\t\twhile (k--) {\n\t\t\t\t\tif (viewFunction(this.collection.data[k]) === true) {\n\t\t\t\t\t\tresult.push(k);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.filteredrows = result;\n\t\t\t\tthis.filterInitialized = true;\n\n\t\t\t\treturn this;\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * count() - returns the number of documents in the resultset.\n\t *\n\t * @returns {number} The number of documents in the resultset.\n\t * @memberof Resultset\n\t */\n\tcount() {\n\t\tif (this.filterInitialized) {\n\t\t\treturn this.filteredrows.length;\n\t\t}\n\t\treturn this.collection.count();\n\t}\n\n\t/**\n\t * Terminates the chain and returns array of filtered documents\n\t *\n\t * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n\t * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n\t *        the collection is not configured for clone object.\n\t * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n\t *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'\n\t * @param {bool} options.removeMeta - Will force clones and strip $loki and meta properties from documents\n\t *\n\t * @returns {array} Array of documents in the resultset\n\t * @memberof Resultset\n\t */\n\tdata(options = {}) {\n\t\tlet result = [];\n\t\tlet data = this.collection.data;\n\t\tlet obj;\n\t\tlet len;\n\t\tlet i;\n\t\tlet method;\n\n\t\t// if user opts to strip meta, then force clones and use 'shallow' if 'force' options are not present\n\t\tif (options.removeMeta && !options.forceClones) {\n\t\t\toptions.forceClones = true;\n\t\t\toptions.forceCloneMethod = options.forceCloneMethod || 'shallow';\n\t\t}\n\n\t\t// if this has no filters applied, just return collection.data\n\t\tif (!this.filterInitialized) {\n\t\t\tif (this.filteredrows.length === 0) {\n\t\t\t\t// determine whether we need to clone objects or not\n\t\t\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\t\t\tlen = data.length;\n\t\t\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tobj = clone(data[i], method);\n\t\t\t\t\t\tif (options.removeMeta) {\n\t\t\t\t\t\t\tdelete obj.$loki;\n\t\t\t\t\t\t\tdelete obj.meta;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult.push(obj);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t// otherwise we are not cloning so return sliced array with same object references\n\t\t\t\telse {\n\t\t\t\t\treturn data.slice();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// filteredrows must have been set manually, so use it\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t}\n\t\t}\n\n\t\tconst fr = this.filteredrows;\n\t\tlen = fr.length;\n\n\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tobj = clone(data[fr[i]], method);\n\t\t\t\tif (options.removeMeta) {\n\t\t\t\t\tdelete obj.$loki;\n\t\t\t\t\tdelete obj.meta;\n\t\t\t\t}\n\t\t\t\tresult.push(obj);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tresult.push(data[fr[i]]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Used to run an update operation on all documents currently in the resultset.\n\t *\n\t * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tupdate(updateFunction) {\n\t\tif (typeof(updateFunction) !== \"function\") {\n\t\t\tthrow new TypeError('Argument is not a function');\n\t\t}\n\n\t\t// if this has no filters applied, we need to populate filteredrows first\n\t\tif (!this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tconst len = this.filteredrows.length;\n\t\tconst rcd = this.collection.data;\n\n\t\tfor (let idx = 0; idx < len; idx++) {\n\t\t\t// pass in each document object currently in resultset to user supplied updateFunction\n\t\t\tupdateFunction(rcd[this.filteredrows[idx]]);\n\n\t\t\t// notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate\n\t\t\tthis.collection.update(rcd[this.filteredrows[idx]]);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all document objects which are currently in resultset from collection (as well as resultset)\n\t *\n\t * @returns {Resultset} this (empty) resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tremove() {\n\n\t\t// if this has no filters applied, we need to populate filteredrows first\n\t\tif (!this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tthis.collection.remove(this.data());\n\n\t\tthis.filteredrows = [];\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns {value} The output of your reduceFunction\n\t * @memberof Resultset\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n\t * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n\t * @param {Array} joinData - Data array to join to.\n\t * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n\t * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n\t * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n\t * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n\t * @memberof Resultset\n\t */\n\teqJoin(joinData, leftJoinKey, rightJoinKey, mapFun) {\n\t\tlet leftData = [];\n\t\tlet leftDataLength;\n\t\tlet rightData = [];\n\t\tlet rightDataLength;\n\t\tlet key;\n\t\tlet result = [];\n\t\tlet leftKeyisFunction = typeof leftJoinKey === 'function';\n\t\tlet rightKeyisFunction = typeof rightJoinKey === 'function';\n\t\tlet joinMap = {};\n\n\t\t//get the left data\n\t\tleftData = this.data();\n\t\tleftDataLength = leftData.length;\n\n\t\t//get the right data\n\t\tif (joinData instanceof Resultset) {\n\t\t\trightData = joinData.data();\n\t\t} else if (Array.isArray(joinData)) {\n\t\t\trightData = joinData;\n\t\t} else {\n\t\t\tthrow new TypeError('joinData needs to be an array or result set');\n\t\t}\n\t\trightDataLength = rightData.length;\n\n\t\t//construct a lookup table\n\t\tfor (let i = 0; i < rightDataLength; i++) {\n\t\t\tkey = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n\t\t\tjoinMap[key] = rightData[i];\n\t\t}\n\n\t\tif (!mapFun) {\n\t\t\tmapFun = (left, right) => ({\n\t\t\t\tleft,\n\t\t\t\tright\n\t\t\t});\n\t\t}\n\n\t\t//Run map function over each object in the resultset\n\t\tfor (let j = 0; j < leftDataLength; j++) {\n\t\t\tkey = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n\t\t\tresult.push(mapFun(leftData[j], joinMap[key] || {}));\n\t\t}\n\n\t\t//return a new resultset with no filters\n\t\tthis.collection = new Collection('joinData');\n\t\tthis.collection.insert(result);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t}\n\n\tmap(mapFun) {\n\t\tlet data = this.data().map(mapFun);\n\t\t//return return a new resultset with no filters\n\t\tthis.collection = new Collection('mappedData');\n\t\tthis.collection.insert(data);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t}\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/resultset.js\n// module id = 7\n// module chunks = 0","/**\n * A loki persistence adapter which persists using node fs module\n * @constructor LokiFsAdapter\n */\nexport class LokiFsAdapter {\n\n\tconstructor() {\n\t\t// TODO\n\t\tif (typeof global !== \"undefined\" && ({}).toString.call(global) === '[object global]') {\n\t\t\tthis.fs = require('fs');\n\t\t}\n\t}\n\n\t/**\n\t * loadDatabase() - Load data from file, will throw an error if the file does not exist\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiFsAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.fs.stat(dbname, (err, stats) => {\n\t\t\t\tif (!err && stats.isFile()) {\n\t\t\t\t\tthis.fs.readFile(dbname, {\n\t\t\t\t\t\tencoding: 'utf8'\n\t\t\t\t\t}, function readFileCallback(err, data) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * saveDatabase() - save data to file, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiFsAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tconst tmpdbname = dbname + '~';\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.fs.writeFile(tmpdbname, dbstring, (err) => {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tthis.fs.rename(tmpdbname, dbname, (err) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * deleteDatabase() - delete the database file, will throw an error if the\n\t * file can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiFsAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/fs_adapter.js\n// module id = 8\n// module chunks = 0","function localStorageAvailable() {\n\ttry {\n\t\treturn (window && window.localStorage !== undefined && window.localStorage !== null);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n/*\n 'localStorageAvailable' is not defined\n */\n\n/**\n * A loki persistence adapter which persists to web browser's local storage object\n * @constructor LokiLocalStorageAdapter\n */\nexport class LokiLocalStorageAdapter {\n\n\t/**\n\t * loadDatabase() - Load data from localstorage\n\t * @param {string} dbname - the name of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\treturn Promise.resolve(localStorage.getItem(dbname));\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n\t/**\n\t * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was saved\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.setItem(dbname, dbstring);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n\t/**\n\t * deleteDatabase() - delete the database from localstorage, will throw an error if it\n\t * can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.removeItem(dbname);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/local_storage_adapter.js\n// module id = 9\n// module chunks = 0","/**\n * In in-memory persistence adapter for an in-memory database.\n * This simple 'key/value' adapter is intended for unit testing and diagnostics.\n *\n * @param {object=} options - memory adapter options\n * @param {boolean} options.asyncResponses - whether callbacks are invoked asynchronously (default: false)\n * @param {int} options.asyncTimeout - timeout in ms to queue callbacks (default: 50)\n *\n * @constructor LokiMemoryAdapter\n */\nexport class LokiMemoryAdapter {\n\n\tconstructor(options) {\n\t\tthis.hashStore = {};\n\t\tthis.options = options || {};\n\n\t\tif (this.options.asyncResponses === undefined) {\n\t\t\tthis.options.asyncResponses = false;\n\t\t}\n\n\t\tif (this.options.asyncTimeout === undefined) {\n\t\t\tthis.options.asyncTimeout = 50; // 50 ms default\n\t\t}\n\t}\n\n\t/**\n\t * Loads a serialized database from its in-memory store.\n\t * (Loki persistence adapter interface function)\n\t *\n\t * @param {string} dbname - name of the database (filename/keyname)\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiMemoryAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tif (this.options.asyncResponses) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tif (this.hashStore[dbname] !== undefined) {\n\t\t\t\t\t\tresolve(this.hashStore[dbname].value);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treject(new Error(\"unable to load database, \" + dbname + \" was not found in memory adapter\"));\n\t\t\t\t\t}\n\t\t\t\t}, this.options.asyncTimeout);\n\t\t\t});\n\t\t}\n\t\telse {\n\t\t\tif (this.hashStore[dbname] !== undefined) {\n\t\t\t\treturn Promise.resolve(this.hashStore[dbname].value);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Promise.reject(new Error(\"unable to load database, \" + dbname + \" was not found in memory adapter\"));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Saves a serialized database to its in-memory store.\n\t * (Loki persistence adapter interface function)\n\t *\n\t * @param {string} dbname - name of the database (filename/keyname)\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiMemoryAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tlet saveCount;\n\n\t\tif (this.options.asyncResponses) {\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsaveCount = (this.hashStore[dbname] !== undefined ? this.hashStore[dbname].savecount : 0);\n\n\t\t\t\t\tthis.hashStore[dbname] = {\n\t\t\t\t\t\tsavecount: saveCount + 1,\n\t\t\t\t\t\tlastsave: new Date(),\n\t\t\t\t\t\tvalue: dbstring\n\t\t\t\t\t};\n\n\t\t\t\t\tresolve();\n\t\t\t\t}, this.options.asyncTimeout);\n\t\t\t});\n\t\t} else {\n\t\t\tsaveCount = (this.hashStore[dbname] !== undefined ? this.hashStore[dbname].savecount : 0);\n\n\t\t\tthis.hashStore[dbname] = {\n\t\t\t\tsavecount: saveCount + 1,\n\t\t\t\tlastsave: new Date(),\n\t\t\t\tvalue: dbstring\n\t\t\t};\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Deletes a database from its in-memory store.\n\t *\n\t * @param {string} dbname - name of the database (filename/keyname)\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiMemoryAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tif (this.hashStore[dbname] !== undefined) {\n\t\t\tdelete this.hashStore[dbname];\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/memory_adapter.js\n// module id = 10\n// module chunks = 0","import {LokiEventEmitter} from './event_emitter';\nimport {Resultset} from './resultset';\n\n/*\n 'LokiEventEmitter' is not defined        no-undef\n 'Resultset' is not defined               no-undef\n\n applySortCriteria -> like Resultset::compoundsort\n\n queueRebuildEvent -> Promise?\n\n */\n\n/**\n * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n *\n * @example\n * let mydv = mycollection.addDynamicView('test');  // default is non-persistent\n * mydv.applyFind({ 'doors' : 4 });\n * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n * let results = mydv.data();\n *\n * @constructor DynamicView\n * @implements LokiEventEmitter\n * @param {Collection} collection - A reference to the collection to work against\n * @param {string} name - The name of this dynamic view\n * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n */\nexport class DynamicView extends LokiEventEmitter {\n\n\tconstructor(collection, name, options) {\n\t\tsuper();\n\t\tthis.collection = collection;\n\t\tthis.name = name;\n\t\tthis.rebuildPending = false;\n\t\tthis.options = options || {};\n\n\t\tif (this.options.persistent === undefined) {\n\t\t\tthis.options.persistent = false;\n\t\t}\n\n\t\t// 'persistentSortPriority':\n\t\t// 'passive' will defer the sort phase until they call data(). (most efficient overall)\n\t\t// 'active' will sort async whenever next idle. (prioritizes read speeds)\n\t\tif (this.options.sortPriority === undefined) {\n\t\t\tthis.options.sortPriority = 'passive';\n\t\t}\n\n\t\tif (this.options.minRebuildInterval === undefined) {\n\t\t\tthis.options.minRebuildInterval = 1;\n\t\t}\n\n\t\tthis.resultset = new Resultset(collection);\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = false;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\t// for now just have 1 event for when we finally rebuilt lazy view\n\t\t// once we refactor transactions, i will tie in certain transactional events\n\n\t\tthis.events = {\n\t\t\t'rebuild': []\n\t\t};\n\t}\n\n\t/**\n\t * rematerialize() - intended for use immediately after deserialization (loading)\n\t *    This will clear out and reapply filterPipeline ops, recreating the view.\n\t *    Since where filters do not persist correctly, this method allows\n\t *    restoring the view to state where user can re-apply those where filters.\n\t *\n\t * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n\t * @returns {DynamicView} This dynamic view for further chained ops.\n\t * @memberof DynamicView\n\t * @fires DynamicView.rebuild\n\t */\n\trematerialize(options) {\n\t\tlet fpl;\n\t\tlet fpi;\n\t\tlet idx;\n\n\t\toptions = options || {};\n\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\t\tthis.resultset = new Resultset(this.collection);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.sortDirty = true;\n\t\t}\n\n\t\tif (options.removeWhereFilters !== undefined) {\n\t\t\t// for each view see if it had any where filters applied... since they don't\n\t\t\t// serialize those functions lets remove those invalid filters\n\t\t\tfpl = this.filterPipeline.length;\n\t\t\tfpi = fpl;\n\t\t\twhile (fpi--) {\n\t\t\t\tif (this.filterPipeline[fpi].type === 'where') {\n\t\t\t\t\tif (fpi !== this.filterPipeline.length - 1) {\n\t\t\t\t\t\tthis.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filterPipeline.length--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n\t\tconst ofp = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\t// now re-apply 'find' filterPipeline ops\n\t\tfpl = ofp.length;\n\t\tfor (idx = 0; idx < fpl; idx++) {\n\t\t\tthis.applyFind(ofp[idx].val);\n\t\t}\n\n\t\t// during creation of unit tests, i will remove this forced refresh and leave lazy\n\t\tthis.data();\n\n\t\t// emit rebuild event in case user wants to be notified\n\t\tthis.emit('rebuild', this);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * branchResultset() - Makes a copy of the internal resultset for branched queries.\n\t *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n\t *    so your branched query should be immediately resolved and not held for future evaluation.\n\t *\n\t * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n\t * @param {object=} parameters - optional parameters (if optional transform requires them)\n\t * @returns {Resultset} A copy of the internal resultset for branched queries.\n\t * @memberof DynamicView\n\t */\n\tbranchResultset(transform, parameters) {\n\t\tconst rs = this.resultset.branch();\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t}\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tconst copy = new DynamicView(this.collection, this.name, this.options);\n\n\t\tcopy.resultset = this.resultset;\n\t\tcopy.resultdata = []; // let's not save data (copy) to minimize size\n\t\tcopy.resultsdirty = true;\n\t\tcopy.filterPipeline = this.filterPipeline;\n\t\tcopy.sortFunction = this.sortFunction;\n\t\tcopy.sortCriteria = this.sortCriteria;\n\t\tcopy.sortDirty = this.sortDirty;\n\n\t\t// avoid circular reference, reapply in db.loadJSON()\n\t\tcopy.collection = null;\n\n\t\treturn copy;\n\t}\n\n\t/**\n\t * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n\t *     Existing options should be retained.\n\t * @param {object=} options - configure removeFilter behavior\n\t * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n\t * @memberof DynamicView\n\t */\n\tremoveFilters(options) {\n\t\toptions = options || {};\n\n\t\tthis.rebuildPending = false;\n\t\tthis.resultset.reset();\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\tif (options.queueSortPhase === true) {\n\t\t\tthis.queueSortPhase();\n\t\t}\n\t}\n\n\t/**\n\t * applySort() - Used to apply a sort to the dynamic view\n\t * @example\n\t * dv.applySort(function(obj1, obj2) {\n\t *   if (obj1.name === obj2.name) return 0;\n\t *   if (obj1.name > obj2.name) return 1;\n\t *   if (obj1.name < obj2.name) return -1;\n\t * });\n\t *\n\t * @param {function} comparefun - a javascript compare function used for sorting\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySort(comparefun) {\n\t\tthis.sortFunction = comparefun;\n\t\tthis.sortCriteria = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applySimpleSort() - Used to specify a property used for view translation.\n\t * @example\n\t * dv.applySimpleSort(\"name\");\n\t *\n\t * @param {string} propname - Name of property by which to sort.\n\t * @param {boolean=} isdesc - (Optional) If true, the sort will be in descending order.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySimpleSort(propname, isdesc) {\n\t\tthis.sortCriteria = [\n\t\t\t[propname, isdesc || false]\n\t\t];\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * dv.applySortCriteria(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * dv.applySortCriteria(['age', ['name', true]);\n\t * // to sort by age (descending) and then by name (descending)\n\t * dv.applySortCriteria(['age', true], ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n\t * @memberof DynamicView\n\t */\n\tapplySortCriteria(criteria) {\n\t\tthis.sortCriteria = criteria;\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * startTransaction() - marks the beginning of a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tstartTransaction() {\n\t\tthis.cachedresultset = this.resultset.copy();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * commit() - commits a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tcommit() {\n\t\tthis.cachedresultset = null;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * rollback() - rolls back a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\trollback() {\n\t\tthis.resultset = this.cachedresultset;\n\n\t\tif (this.options.persistent) {\n\t\t\t// for now just rebuild the persistent dynamic view data in this worst case scenario\n\t\t\t// (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n\t\t\tthis.resultdata = this.resultset.data();\n\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Implementation detail.\n\t * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter.\n\t * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n\t */\n\t_indexOfFilterWithId(uid) {\n\t\tif (typeof uid === 'string' || typeof uid === 'number') {\n\t\t\tfor (let idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n\t\t\t\tif (uid === this.filterPipeline[idx].uid) {\n\t\t\t\t\treturn idx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Implementation detail.\n\t * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n\t *\n\t * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n\t */\n\t_addFilter(filter) {\n\t\tthis.filterPipeline.push(filter);\n\t\tthis.resultset[filter.type](filter.val);\n\t}\n\n\t/**\n\t * reapplyFilters() - Reapply all the filters in the current pipeline.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\treapplyFilters() {\n\t\tthis.resultset.reset();\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tconst filters = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\tfor (let idx = 0, len = filters.length; idx < len; idx += 1) {\n\t\t\tthis._addFilter(filters[idx]);\n\t\t}\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n\t *\n\t * @param {object} filter - A filter object to add to the pipeline.\n\t *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFilter(filter) {\n\t\tconst idx = this._indexOfFilterWithId(filter.uid);\n\t\tif (idx >= 0) {\n\t\t\tthis.filterPipeline[idx] = filter;\n\t\t\treturn this.reapplyFilters();\n\t\t}\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tthis._addFilter(filter);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n\t *\n\t * @param {object} query - A mongo-style query object to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFind(query, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'find',\n\t\t\tval: query,\n\t\t\tuid\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n\t *\n\t * @param {function} fun - A javascript filter function to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyWhere(fun, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'where',\n\t\t\tval: fun,\n\t\t\tuid\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter to be removed.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tremoveFilter(uid) {\n\t\tconst idx = this._indexOfFilterWithId(uid);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n\t\t}\n\n\t\tthis.filterPipeline.splice(idx, 1);\n\t\tthis.reapplyFilters();\n\t\treturn this;\n\t}\n\n\t/**\n\t * count() - returns the number of documents representing the current DynamicView contents.\n\t *\n\t * @returns {number} The number of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tcount() {\n\t\t// in order to be accurate we will pay the minimum cost (and not alter dv state management)\n\t\t// recurring resultset data resolutions should know internally its already up to date.\n\t\t// for persistent data this will not update resultdata nor fire rebuild event.\n\t\tif (this.resultsdirty) {\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t}\n\n\t\treturn this.resultset.count();\n\t}\n\n\t/**\n\t * data() - resolves and pending filtering and sorting, then returns document array as result.\n\t *\n\t * @returns {array} An array of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tdata() {\n\t\t// using final sort phase as 'catch all' for a few use cases which require full rebuild\n\t\tif (this.sortDirty || this.resultsdirty) {\n\t\t\tthis.performSortPhase({\n\t\t\t\tsuppressRebuildEvent: true\n\t\t\t});\n\t\t}\n\t\treturn (this.options.persistent) ? (this.resultdata) : (this.resultset.data());\n\t}\n\n\t/**\n\t * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n\t *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n\t */\n\tqueueRebuildEvent() {\n\t\tif (this.rebuildPending) {\n\t\t\treturn;\n\t\t}\n\t\tthis.rebuildPending = true;\n\n\t\tsetTimeout(() => {\n\t\t\tif (this.rebuildPending) {\n\t\t\t\tthis.rebuildPending = false;\n\t\t\t\tthis.emit('rebuild', this);\n\t\t\t}\n\t\t}, this.options.minRebuildInterval);\n\t}\n\n\t/**\n\t * queueSortPhase : If the view is sorted we will throttle sorting to either :\n\t *    (1) passive - when the user calls data(), or\n\t *    (2) active - once they stop updating and yield js thread control\n\t */\n\tqueueSortPhase() {\n\t\t// already queued? exit without queuing again\n\t\tif (this.sortDirty) {\n\t\t\treturn;\n\t\t}\n\t\tthis.sortDirty = true;\n\n\t\tif (this.options.sortPriority === \"active\") {\n\t\t\t// active sorting... once they are done and yield js thread, run async performSortPhase()\n\t\t\tsetTimeout(() => {\n\t\t\t\tthis.performSortPhase();\n\t\t\t}, this.options.minRebuildInterval);\n\t\t} else {\n\t\t\t// must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n\t\t\t// potentially notify user that data has changed.\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\t}\n\n\t/**\n\t * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n\t *\n\t */\n\tperformSortPhase(options) {\n\t\t// async call to this may have been pre-empted by synchronous call to data before async could fire\n\t\tif (!this.sortDirty && !this.resultsdirty) {\n\t\t\treturn;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tif (this.sortDirty) {\n\t\t\tif (this.sortFunction) {\n\t\t\t\tthis.resultset.sort(this.sortFunction);\n\t\t\t} else if (this.sortCriteria) {\n\t\t\t\tthis.resultset.compoundsort(this.sortCriteria);\n\t\t\t}\n\n\t\t\tthis.sortDirty = false;\n\t\t}\n\n\t\tif (this.options.persistent) {\n\t\t\t// persistent view, rebuild local resultdata array\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t\tthis.resultsdirty = false;\n\t\t}\n\n\t\tif (!options.suppressRebuildEvent) {\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\t}\n\n\t/**\n\t * evaluateDocument() - internal method for (re)evaluating document inclusion.\n\t *    Called by : collection.insert() and collection.update().\n\t *\n\t * @param {int} objIndex - index of document to (re)run through filter pipeline.\n\t * @param {bool} isNew - true if the document was just added to the collection.\n\t */\n\tevaluateDocument(objIndex, isNew) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst ofr = this.resultset.filteredrows;\n\t\tconst oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));\n\t\tconst oldlen = ofr.length;\n\n\t\t// creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n\t\t// mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n\t\tconst evalResultset = new Resultset(this.collection);\n\t\tevalResultset.filteredrows = [objIndex];\n\t\tevalResultset.filterInitialized = true;\n\t\tlet filter;\n\t\tfor (let idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n\t\t\tfilter = this.filterPipeline[idx];\n\t\t\tevalResultset[filter.type](filter.val);\n\t\t}\n\n\t\t// not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n\t\tconst newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;\n\n\t\t// wasn't in old, shouldn't be now... do nothing\n\t\tif (oldPos === -1 && newPos === -1) return;\n\n\t\t// wasn't in resultset, should be now... add\n\t\tif (oldPos === -1 && newPos !== -1) {\n\t\t\tofr.push(objIndex);\n\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata.push(this.collection.data[objIndex]);\n\t\t\t}\n\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, shouldn't be now... delete\n\t\tif (oldPos !== -1 && newPos === -1) {\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr.splice(oldPos, 1);\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.splice(oldPos, 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, should still be now... (update persistent only?)\n\t\tif (oldPos !== -1 && newPos !== -1) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\t// in case document changed, replace persistent view data with the latest collection.data document\n\t\t\t\tthis.resultdata[oldPos] = this.collection.data[objIndex];\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * removeDocument() - internal function called on collection.delete()\n\t */\n\tremoveDocument(objIndex) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tconst ofr = this.resultset.filteredrows;\n\t\tconst oldPos = ofr.indexOf(+objIndex);\n\t\tlet oldlen = ofr.length;\n\t\tlet idx;\n\n\t\tif (oldPos !== -1) {\n\t\t\t// if not last row in resultdata, swap last to hole and truncate last row\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr[oldPos] = ofr[oldlen - 1];\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata[oldPos] = this.resultdata[oldlen - 1];\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// last row, so just truncate last row\n\t\t\telse {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t}\n\n\t\t// since we are using filteredrows to store data array positions\n\t\t// if they remove a document (whether in our view or not),\n\t\t// we need to adjust array positions -1 for all document array references after that position\n\t\toldlen = ofr.length;\n\t\tfor (idx = 0; idx < oldlen; idx++) {\n\t\t\tif (ofr[idx] > objIndex) {\n\t\t\t\tofr[idx]--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * mapReduce() - data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns The output of your reduceFunction\n\t * @memberof DynamicView\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/dynamic_view.js\n// module id = 11\n// module chunks = 0","export class ExactIndex {\n\n\tconstructor(exactField) {\n\t\tthis.index = {};\n\t\tthis.field = exactField;\n\t}\n\n\t// add the value you want returned to the key in the index\n\tset(key, val) {\n\t\tif (this.index[key]) {\n\t\t\tthis.index[key].push(val);\n\t\t} else {\n\t\t\tthis.index[key] = [val];\n\t\t}\n\t\tconsole.log(\"?\");\n\t}\n\n\t// remove the value from the index, if the value was the last one, remove the key\n\tremove(key, val) {\n\t\tconst idxSet = this.index[key];\n\t\tfor (const i in idxSet) {\n\t\t\tif (idxSet[i] == val) {\n\t\t\t\tidxSet.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\tif (idxSet.length < 1) {\n\t\t\tthis.index[key] = undefined;\n\t\t}\n\t}\n\n\t// get the values related to the key, could be more than one\n\tget(key) {\n\t\tconsole.log(\"!\");\n\t\treturn this.index[key];\n\t}\n\n\t// clear will zap the index\n\tclear(key) {\n\t\tthis.index = {};\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/exact_index.js\n// module id = 12\n// module chunks = 0","export class UniqueIndex {\n\n\tconstructor(uniqueField) {\n\t\tthis.field = uniqueField;\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t}\n\n\tset(obj) {\n\t\tconst fieldValue = obj[this.field];\n\t\tif (fieldValue !== null && typeof(fieldValue) !== 'undefined') {\n\t\t\tif (this.keyMap[fieldValue]) {\n\t\t\t\tthrow new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n\t\t\t} else {\n\t\t\t\tthis.keyMap[fieldValue] = obj;\n\t\t\t\tthis.lokiMap[obj.$loki] = fieldValue;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\treturn this.keyMap[key];\n\t}\n\n\tbyId(id) {\n\t\treturn this.keyMap[this.lokiMap[id]];\n\t}\n\n\t/**\n\t * Updates a document's unique index given an updated object.\n\t * @param  {Object} obj Original document object\n\t * @param  {Object} doc New document object (likely the same as obj)\n\t */\n\tupdate(obj, doc) {\n\t\tif (this.lokiMap[obj.$loki] !== doc[this.field]) {\n\t\t\tconst old = this.lokiMap[obj.$loki];\n\t\t\tthis.set(doc);\n\t\t\t// make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n\t\t\tthis.keyMap[old] = undefined;\n\t\t} else {\n\t\t\tthis.keyMap[obj[this.field]] = doc;\n\t\t}\n\t}\n\n\tremove(key) {\n\t\tconst obj = this.keyMap[key];\n\t\tif (obj !== null && typeof obj !== 'undefined') {\n\t\t\tthis.keyMap[key] = undefined;\n\t\t\tthis.lokiMap[obj.$loki] = undefined;\n\t\t} else {\n\t\t\tthrow new Error('Key is not in unique index: ' + this.field);\n\t\t}\n\t}\n\n\tclear() {\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/unique_index.js\n// module id = 13\n// module chunks = 0","module.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 14\n// module chunks = 0"],"sourceRoot":""}