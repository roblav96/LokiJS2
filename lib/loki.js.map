{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 8244cd82aa0b3bd37298","webpack:///./src/core/event_emitter.js","webpack:///./src/core/collection.js","webpack:///./src/core/utils.js","webpack:///./src/core/clone.js","webpack:///./src/core/helper.js","webpack:///./src/core/loki.js","webpack:///./src/core/resultset.js","webpack:///./src/core/fs_adapter.js","webpack:///./src/core/local_storage_adapter.js","webpack:///./src/core/loki-indexed-adapter.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/core/dynamic_view.js","webpack:///./src/core/exact_index.js","webpack:///./src/core/unique_index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA,mDAA2C,cAAc;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;;;;;;;AC/DA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;;AAEA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB,cAAc,IAAI;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AC/GyB;AACL;AACD;AACD;AACE;AACY;AACL;AACd;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,IAAI,uEAAuE;AACtF,SAAS,yBAAyB;AAClC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB,0BAA0B;AAC1B;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA,oBAAoB;AACpB;;AAEA;AACA;AACA;;AAEA,eAAe,sBAAsB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,SAAS;AAClB;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,YAAY;AAC1B;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C;AACA,YAAY,gBAAgB;AAC5B,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,eAAe;AAC3B,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wBAAwB;AACxB,qBAAqB;;AAErB;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,qBAAqB;;AAErB;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oBAAoB;AAC9B;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,sEAAsE,+BAA+B;AACrG,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,cAAc;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;;AAEA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,cAAc;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,cAAc,UAAU;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C,uBAAuB,cAAc,uBAAuB;AACvG,cAAc;AACd,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,SAAS;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,UAAU;AACtB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACh6DA;AAAA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;ACrDA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO,QAAQ;AACf;AACA;;AAEA;AACA;;;;;;;;;AC3CA;AAAA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;AC/GyB;;AAEH;AACU;AACb;AACL;;AAEd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,IAAI;AAChB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ,UAAU,EAAE;AAC1E;AACA,YAAY,MAAM;AAClB,YAAY,OAAO,sCAAsC,yBAAyB;AAClF,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,OAAO;AACnB,YAAY,IAAI,uEAAuE;AACvF,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;AACA,uGAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4DAA4D;AAC5D;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;;AAEA,eAAe,iCAAiC;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,oCAAoC;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB,YAAY,QAAQ;AACpB,YAAY,IAAI;AAChB;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,QAAQ;AACpB,YAAY,MAAM;AAClB,YAAY,KAAK;AACjB,YAAY,MAAM;AAClB,YAAY,QAAQ;AACpB;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,2EAA2E;AAC3E,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA,mCAAmC;AACnC,6FAA6F;;AAE7F;AACA;AACA;AACA,6BAA6B;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,aAAa;AACzB,YAAY,OAAO;AACnB,YAAY,IAAI;AAChB,YAAY,OAAO;AACnB;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,SAAS,SAAS;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA,IAAI;;AAEJ,WAAW,UAAU;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,iCAAiC;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA,oBAAoB,gCAAgC;AACpD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,KAAK;AACL;AACA;AACA,iDAAiD;AACjD;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AAEA;;;;;;;;;;;;;;ACrnCc;AACK;AACL;AACa;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF,oBAAoB,eAAe,oBAAoB;AACvD;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,IAAI;AACf,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,SAAS;AACpB,WAAW,KAAK;AAChB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,IAAI,mCAAmC;AACnD,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC,uBAAuB,QAAQ;AAC/B,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,wBAAwB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,mBAAmB;AAClC;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,YAAY,SAAS;AACrB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,MAAM;AAClB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA,KAAK;AACL,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA,KAAK;AACL,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA,YAAY,SAAS;AACrB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA,YAAY,OAAO;AACnB;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA,GAAG;AACH,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,cAAc,UAAU;AACxB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,WAAW;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,MAAM;AAClB,YAAY,kBAAkB;AAC9B,YAAY,kBAAkB;AAC9B,YAAY,UAAU,0HAA0H;AAChJ,cAAc,UAAU,uCAAuC,+BAA+B;AAC9F;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,oBAAoB;AACrC;AACA,qDAAqD;AACrD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AAAA;AAAA;;;;;;;;;AC3xCA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AAAA;AAAA;;;;;;;;;ACtFA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AAAA;AAAA;;;;;;;;AClEA;AAAA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA,qCAAqC;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAsB;AACrD;AACA;AACA,KAAK;AACL;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,+BAA+B,sBAAsB;AACrD;AACA,iBAAiB,YAAY;AAC7B,sBAAsB;AACtB;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,OAAO;AACnB,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;;AAEA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA,0CAA0C;AAC1C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;ACrmBA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;ACpByB;AACP;;AAElB;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD,mBAAmB,cAAc;AACjC,kCAAkC,8BAA8B,EAAE;AAClE;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,SAAS,gCAAgC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,QAAQ;AACpB,cAAc,UAAU;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,YAAY,SAAS;AACrB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,cAAc,OAAO,iDAAiD;AACtE;AACA;AACA;AACA,sDAAsD,WAAW;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,yCAAyC,WAAW;AACpD;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,oCAAoC;AACpC,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,iBAAiB;AAC7B,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,iBAAiB;AAC7B,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,IAAI;AAChB,YAAY,KAAK;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,WAAW;AAChE;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AAAA;AAAA;;;;;;;;ACtvBA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;;;;;;ACxCA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA","file":"loki.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 8244cd82aa0b3bd37298","\n/*\n 'listen' is not defined  no-undef\n */\n\n/**\n * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n * constructor that inherits EventEmitter to emit events and trigger\n * listeners that have been added to the event through the on(event, callback) method\n *\n * @constructor LokiEventEmitter\n */\nexport class LokiEventEmitter {\n\n\tconstructor() {\n\t\t/**\n\t\t * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.events = {};\n\n\t\t/**\n\t\t * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n\t\t * should happen in an async fashion or not\n\t\t * Default is false, which means events are synchronous\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.asyncListeners = false;\n\t}\n\n\t/**\n\t * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\ton(eventName, listener) {\n\t\tvar event;\n\t\tvar self = this;\n\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach(function(currentEventName) {\n\t\t\t\tself.on(currentEventName, listener);\n\t\t\t});\n\t\t\treturn listener;\n\t\t}\n\n\t\tevent = this.events[eventName];\n\t\tif (!event) {\n\t\t\tevent = this.events[eventName] = [];\n\t\t}\n\t\tevent.push(listener);\n\t\treturn listener;\n\t}\n\n\t/**\n\t * emit(eventName, data) - emits a particular event\n\t * with the option of passing optional parameters which are going to be processed by the callback\n\t * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n\t * @param {string} eventName - the name of the event\n\t * @param {object=} data - optional object passed with the event\n\t * @memberof LokiEventEmitter\n\t */\n\temit(eventName, data) {\n\t\tvar self = this;\n\t\tif (eventName && this.events[eventName]) {\n\t\t\tthis.events[eventName].forEach(function(listener) {\n\t\t\t\tif (self.asyncListeners) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tlistener(data);\n\t\t\t\t\t}, 1);\n\t\t\t\t} else {\n\t\t\t\t\tlistener(data);\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Alias of LokiEventEmitter.prototype.on\n\t * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\taddListener(eventName, listener) {\n\t\treturn this.on(eventName, listener);\n\t}\n\n\t/**\n\t * removeListener() - removes the listener at position 'index' from the event 'eventName'\n\t * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n\t * @param {function} listener - the listener callback function to remove from emitter\n\t * @memberof LokiEventEmitter\n\t */\n\tremoveListener(eventName, listener) {\n\t\tvar self = this;\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach(function(currentEventName) {\n\t\t\t\tself.removeListener(currentEventName, listen);\n\t\t\t});\n\t\t}\n\n\t\tif (this.events[eventName]) {\n\t\t\tvar listeners = this.events[eventName];\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t}\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/event_emitter.js\n// module id = 0\n// module chunks = 0","import {LokiEventEmitter} from './event_emitter';\nimport {UniqueIndex} from './unique_index';\nimport {ExactIndex} from './exact_index';\nimport {Resultset} from './resultset';\nimport {DynamicView} from './dynamic_view';\nimport {clone, cloneObjectArray} from './clone';\nimport {ltHelper, gtHelper} from './helper';\nimport {Loki} from './loki';\n\n/*\n 'isDeepProperty' is not defined              no-undef\n 'deepProperty' is not defined                no-undef\n 'average' is not defined                     no-undef\n 'standardDeviation' is not defined           no-undef\n 'sub' is not defined                         no-undef\n\n byExample?\n indexing -> own class?\n remove data only?\n */\n\n/**\n * General utils, including statistical functions\n */\nfunction isDeepProperty(field) {\n\treturn field.indexOf('.') !== -1;\n}\n\nfunction parseBase10(num) {\n\treturn parseFloat(num, 10);\n}\n\nfunction add(a, b) {\n\treturn a + b;\n}\n\nfunction sub(a, b) {\n\treturn a - b;\n}\n\nfunction average(array) {\n\treturn (array.reduce(add, 0)) / array.length;\n}\n\nfunction standardDeviation(values) {\n\tvar avg = average(values);\n\tvar squareDiffs = values.map(function(value) {\n\t\tvar diff = value - avg;\n\t\tvar sqrDiff = diff * diff;\n\t\treturn sqrDiff;\n\t});\n\n\tvar avgSquareDiff = average(squareDiffs);\n\n\tvar stdDev = Math.sqrt(avgSquareDiff);\n\treturn stdDev;\n}\n\nfunction deepProperty(obj, property, isDeep) {\n\tif (isDeep === false) {\n\t\t// pass without processing\n\t\treturn obj[property];\n\t}\n\tvar pieces = property.split('.'),\n\t\troot = obj;\n\twhile (pieces.length > 0) {\n\t\troot = root[pieces.shift()];\n\t}\n\treturn root;\n}\n\n/**\n * Collection class that handles documents of same type\n * @constructor Collection\n * @implements LokiEventEmitter\n * @param {string} name - collection name\n * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n * @param {array} options.unique - array of property names to define unique constraints for\n * @param {array} options.exact - array of property names to define exact constraints for\n * @param {array} options.indices - array property names to define binary indexes for\n * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily (default: true)\n * @param {boolean} options.asyncListeners - default is false\n * @param {boolean} options.disableChangesApi - default is true\n * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n * @see {@link Loki#addCollection} for normal creation of collections\n */\nexport class Collection extends LokiEventEmitter {\n\n\tconstructor(name, options) {\n\t\tsuper();\n\t\t// the name of the collection\n\n\t\tthis.name = name;\n\t\t// the data held by the collection\n\t\tthis.data = [];\n\t\tthis.idIndex = []; // index of id\n\t\tthis.binaryIndices = {}; // user defined indexes\n\t\tthis.constraints = {\n\t\t\tunique: {},\n\t\t\texact: {}\n\t\t};\n\n\t\t// unique contraints contain duplicate object references, so they are not persisted.\n\t\t// we will keep track of properties which have unique contraint applied here, and regenerate on load\n\t\tthis.uniqueNames = [];\n\n\t\t// transforms will be used to store frequently used query chains as a series of steps\n\t\t// which itself can be stored along with the database.\n\t\tthis.transforms = {};\n\n\t\t// the object type of the collection\n\t\tthis.objType = name;\n\n\t\t// in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n\t\t// currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n\t\t// defaulting to true since this is called from addCollection and adding a collection should trigger save\n\t\tthis.dirty = true;\n\n\t\t// private holders for cached data\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\t\tvar self = this;\n\n\t\t/* OPTIONS */\n\t\toptions = options || {};\n\n\t\t// exact match and unique constraints\n\t\tif (options.hasOwnProperty('unique')) {\n\t\t\tif (!Array.isArray(options.unique)) {\n\t\t\t\toptions.unique = [options.unique];\n\t\t\t}\n\t\t\toptions.unique.forEach(function (prop) {\n\t\t\t\tself.uniqueNames.push(prop); // used to regenerate on subsequent database loads\n\t\t\t\tself.constraints.unique[prop] = new UniqueIndex(prop);\n\t\t\t});\n\t\t}\n\n\t\tif (options.hasOwnProperty('exact')) {\n\t\t\toptions.exact.forEach(function (prop) {\n\t\t\t\tself.constraints.exact[prop] = new ExactIndex(prop);\n\t\t\t});\n\t\t}\n\n\t\t// Inverted index\n\t\tthis._fullTextSearch = null;\n\t\tif (Loki.FullTextSearch !== undefined) {\n\t\t\tthis._fullTextSearch = options.hasOwnProperty('fullTextSearch')\n\t\t\t\t? new (Loki.FullTextSearch.FullTextSearch)(options.fullTextSearch) : null;\n\t\t}\n\n\t\t// if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n\t\t// if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n\t\tthis.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;\n\n\t\t// is collection transactional\n\t\tthis.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;\n\n\t\t// options to clone objects when inserting them\n\t\tthis.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;\n\n\t\t// default clone method (if enabled) is parse-stringify\n\t\tthis.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : \"parse-stringify\";\n\n\t\t// option to make event listeners async, default is sync\n\t\tthis.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;\n\n\t\t// disable track changes\n\t\tthis.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;\n\n\t\t// option to observe objects and update them automatically, ignored if Object.observe is not supported\n\t\tthis.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;\n\n\t\t//option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n\t\tthis.ttl = {\n\t\t\tage: null,\n\t\t\tttlInterval: null,\n\t\t\tdaemon: null\n\t\t};\n\t\tthis.setTTL(options.ttl || -1, options.ttlInterval);\n\n\t\t// currentMaxId - change manually at your own peril!\n\t\tthis.maxId = 0;\n\n\t\tthis.DynamicViews = [];\n\n\t\t// events\n\t\tthis.events = {\n\t\t\t'insert': [],\n\t\t\t'update': [],\n\t\t\t'pre-insert': [],\n\t\t\t'pre-update': [],\n\t\t\t'close': [],\n\t\t\t'flushbuffer': [],\n\t\t\t'error': [],\n\t\t\t'delete': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\t// changes are tracked by collection and aggregated by the db\n\t\tthis.changes = [];\n\n\t\t// initialize the id index\n\t\tthis.ensureId();\n\t\tvar indices = [];\n\t\t// initialize optional user-supplied indices array ['age', 'lname', 'zip']\n\t\tif (options && options.indices) {\n\t\t\tif (Object.prototype.toString.call(options.indices) === '[object Array]') {\n\t\t\t\tindices = options.indices;\n\t\t\t} else if (typeof options.indices === 'string') {\n\t\t\t\tindices = [options.indices];\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Indices needs to be a string or an array of strings');\n\t\t\t}\n\t\t}\n\n\t\tfor (var idx = 0; idx < indices.length; idx++) {\n\t\t\tthis.ensureIndex(indices[idx]);\n\t\t}\n\n\t\tfunction observerCallback(changes) {\n\n\t\t\tvar changedObjects = typeof Set === 'function' ? new Set() : [];\n\n\t\t\tif (!changedObjects.add)\n\t\t\t\tchangedObjects.add = function (object) {\n\t\t\t\t\tif (this.indexOf(object) === -1)\n\t\t\t\t\t\tthis.push(object);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\n\t\t\tchanges.forEach(function (change) {\n\t\t\t\tchangedObjects.add(change.object);\n\t\t\t});\n\n\t\t\tchangedObjects.forEach(function (object) {\n\t\t\t\tif (!hasOwnProperty.call(object, '$loki'))\n\t\t\t\t\treturn self.removeAutoUpdateObserver(object);\n\t\t\t\ttry {\n\t\t\t\t\tself.update(object);\n\t\t\t\t} catch (err) {\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.observerCallback = observerCallback;\n\n\t\t/*\n\t\t * This method creates a clone of the current status of an object and associates operation and collection name,\n\t\t * so the parent db can aggregate and generate a changes object for the entire db\n\t\t */\n\t\tfunction createChange(name, op, obj) {\n\t\t\tself.changes.push({\n\t\t\t\tname: name,\n\t\t\t\toperation: op,\n\t\t\t\tobj: JSON.parse(JSON.stringify(obj))\n\t\t\t});\n\t\t}\n\n\t\t// clear all the changes\n\t\tfunction flushChanges() {\n\t\t\tself.changes = [];\n\t\t}\n\n\t\tthis.getChanges = function () {\n\t\t\treturn self.changes;\n\t\t};\n\n\t\tthis.flushChanges = flushChanges;\n\n\t\t/**\n\t\t * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled\n\t\t */\n\t\tfunction insertMeta(obj) {\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!obj.meta) {\n\t\t\t\tobj.meta = {};\n\t\t\t}\n\n\t\t\tobj.meta.created = (new Date()).getTime();\n\t\t\tobj.meta.revision = 0;\n\t\t}\n\n\t\tfunction updateMeta(obj) {\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tobj.meta.updated = (new Date()).getTime();\n\t\t\tobj.meta.revision += 1;\n\t\t}\n\n\t\tfunction createInsertChange(obj) {\n\t\t\tcreateChange(self.name, 'I', obj);\n\t\t}\n\n\t\tfunction createUpdateChange(obj) {\n\t\t\tcreateChange(self.name, 'U', obj);\n\t\t}\n\n\t\tfunction insertMetaWithChange(obj) {\n\t\t\tinsertMeta(obj);\n\t\t\tcreateInsertChange(obj);\n\t\t}\n\n\t\tfunction updateMetaWithChange(obj) {\n\t\t\tupdateMeta(obj);\n\t\t\tcreateUpdateChange(obj);\n\t\t}\n\n\n\t\t/* assign correct handler based on ChangesAPI flag */\n\t\tvar insertHandler, updateHandler;\n\n\t\tfunction setHandlers() {\n\t\t\tinsertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;\n\t\t\tupdateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;\n\t\t}\n\n\t\tsetHandlers();\n\n\t\tthis.setChangesApi = function (enabled) {\n\t\t\tself.disableChangesApi = !enabled;\n\t\t\tsetHandlers();\n\t\t};\n\t\t/**\n\t\t * built-in events\n\t\t */\n\t\tthis.on('insert', function insertCallback(obj) {\n\t\t\tinsertHandler(obj);\n\t\t});\n\n\t\tthis.on('update', function updateCallback(obj) {\n\t\t\tupdateHandler(obj);\n\t\t});\n\n\t\tthis.on('delete', function deleteCallback(obj) {\n\t\t\tif (!self.disableChangesApi) {\n\t\t\t\tcreateChange(self.name, 'R', obj);\n\t\t\t}\n\t\t});\n\n\t\tthis.on('warning', function (warning) {\n\t\t\tself.console.warn(warning);\n\t\t});\n\t\t// for de-serialization purposes\n\t\tflushChanges();\n\n\t\tthis.console = {\n\t\t\tlog: function () {\n\t\t\t},\n\t\t\twarn: function () {\n\t\t\t},\n\t\t\terror: function () {\n\t\t\t},\n\t\t};\n\n\t\t/* ------ STAGING API -------- */\n\t\t/**\n\t\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t\t * manipulated without affecting the data in the original collection\n\t\t */\n\t\tthis.stages = {};\n\t\tthis.commitLog = [];\n\t}\n\n\taddAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n\t}\n\n\tremoveAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.unobserve(object, this.observerCallback);\n\t}\n\n\t/**\n\t * Adds a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {array} transform - an array of transformation 'step' objects to save into the collection\n\t * @memberof Collection\n\t */\n\taddTransform(name, transform) {\n\t\tif (this.transforms.hasOwnProperty(name)) {\n\t\t\tthrow new Error(\"a transform by that name already exists\");\n\t\t}\n\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Updates a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {object} transform - a transformation object to save into collection\n\t * @memberof Collection\n\t */\n\tsetTransform(name, transform) {\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Removes a named collection transform from the collection\n\t * @param {string} name - name of collection transform to remove\n\t * @memberof Collection\n\t */\n\tremoveTransform(name) {\n\t\tdelete this.transforms[name];\n\t}\n\n\tbyExample(template) {\n\t\tvar k, obj, query;\n\t\tquery = [];\n\t\tfor (k in template) {\n\t\t\tif (!template.hasOwnProperty(k)) continue;\n\t\t\tquery.push((\n\t\t\t\tobj = {},\n\t\t\t\t\tobj[k] = template[k],\n\t\t\t\t\tobj\n\t\t\t));\n\t\t}\n\t\treturn {\n\t\t\t'$and': query\n\t\t};\n\t}\n\n\tfindObject(template) {\n\t\treturn this.findOne(this.byExample(template));\n\t}\n\n\tfindObjects(template) {\n\t\treturn this.find(this.byExample(template));\n\t}\n\n\t/*----------------------------+\n\t | TTL daemon                  |\n\t +----------------------------*/\n\tttlDaemonFuncGen() {\n\t\tvar collection = this;\n\t\tvar age = this.ttl.age;\n\t\treturn function ttlDaemon() {\n\t\t\tvar now = Date.now();\n\t\t\tvar toRemove = collection.chain().where(function daemonFilter(member) {\n\t\t\t\tvar timestamp = member.meta.updated || member.meta.created;\n\t\t\t\tvar diff = now - timestamp;\n\t\t\t\treturn age < diff;\n\t\t\t});\n\t\t\ttoRemove.remove();\n\t\t};\n\t}\n\n\tsetTTL(age, interval) {\n\t\tif (age < 0) {\n\t\t\tclearInterval(this.ttl.daemon);\n\t\t} else {\n\t\t\tthis.ttl.age = age;\n\t\t\tthis.ttl.ttlInterval = interval;\n\t\t\tthis.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n\t\t}\n\t}\n\n\t/*----------------------------+\n\t | INDEXING                    |\n\t +----------------------------*/\n\n\t/**\n\t * create a row filter that covers all documents in the collection\n\t */\n\tprepareFullDocIndex() {\n\t\tvar len = this.data.length;\n\t\tvar indexes = new Array(len);\n\t\tfor (var i = 0; i < len; i += 1) {\n\t\t\tindexes[i] = i;\n\t\t}\n\t\treturn indexes;\n\t}\n\n\t/**\n\t * Will allow reconfiguring certain collection options.\n\t * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n\t * @memberof Collection\n\t */\n\tconfigureOptions(options) {\n\t\toptions = options || {};\n\n\t\tif (options.hasOwnProperty('adaptiveBinaryIndices')) {\n\t\t\tthis.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\n\t\t\t// if switching to adaptive binary indices, make sure none are 'dirty'\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\tthis.ensureAllIndexes();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ensure binary index on a certain field\n\t * @param {string} property - name of property to create binary index on\n\t * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n\t * @memberof Collection\n\t */\n\tensureIndex(property, force) {\n\t\t// optional parameter to force rebuild whether flagged as dirty or not\n\t\tif (typeof(force) === 'undefined') {\n\t\t\tforce = false;\n\t\t}\n\n\t\tif (property === null || property === undefined) {\n\t\t\tthrow new Error('Attempting to set index without an associated property');\n\t\t}\n\n\t\tif (this.binaryIndices[property] && !force) {\n\t\t\tif (!this.binaryIndices[property].dirty) return;\n\t\t}\n\n\t\t// if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n\t\tif (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar index = {\n\t\t\t'name': property,\n\t\t\t'dirty': true,\n\t\t\t'values': this.prepareFullDocIndex()\n\t\t};\n\t\tthis.binaryIndices[property] = index;\n\n\t\tvar wrappedComparer =\n\t\t\t(function (p, data) {\n\t\t\t\treturn function (a, b) {\n\t\t\t\t\tvar objAp = data[a][p],\n\t\t\t\t\t\tobjBp = data[b][p];\n\t\t\t\t\tif (objAp !== objBp) {\n\t\t\t\t\t\tif (ltHelper(objAp, objBp, false)) return -1;\n\t\t\t\t\t\tif (gtHelper(objAp, objBp, false)) return 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\t})(property, this.data);\n\n\t\tindex.values.sort(wrappedComparer);\n\t\tindex.dirty = false;\n\n\t\tthis.dirty = true; // for autosave scenarios\n\t}\n\n\tgetSequencedIndexValues(property) {\n\t\tvar idx, idxvals = this.binaryIndices[property].values;\n\t\tvar result = \"\";\n\n\t\tfor (idx = 0; idx < idxvals.length; idx++) {\n\t\t\tresult += \" [\" + idx + \"] \" + this.data[idxvals[idx]][property];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tensureUniqueIndex(field) {\n\t\tvar index = this.constraints.unique[field];\n\t\tif (!index) {\n\t\t\t// keep track of new unique index for regenerate after database (re)load.\n\t\t\tif (this.uniqueNames.indexOf(field) == -1) {\n\t\t\t\tthis.uniqueNames.push(field);\n\t\t\t}\n\t\t}\n\n\t\t// if index already existed, (re)loading it will likely cause collisions, rebuild always\n\t\tthis.constraints.unique[field] = index = new UniqueIndex(field);\n\t\tthis.data.forEach(function (obj) {\n\t\t\tindex.set(obj);\n\t\t});\n\t\treturn index;\n\t}\n\n\t/**\n\t * Ensure all binary indices\n\t */\n\tensureAllIndexes(force) {\n\t\tvar key, bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\tthis.ensureIndex(key, force);\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexesDirty() {\n\t\tvar key, bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\tbIndices[key].dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexDirty(index) {\n\t\tif (this.binaryIndices[index])\n\t\t\tthis.binaryIndices[index].dirty = true;\n\t}\n\n\t/**\n\t * Quickly determine number of documents in collection (or query)\n\t * @param {object=} query - (optional) query object to count results of\n\t * @returns {number} number of documents in the collection\n\t * @memberof Collection\n\t */\n\tcount(query) {\n\t\tif (!query) {\n\t\t\treturn this.data.length;\n\t\t}\n\n\t\treturn this.chain().find(query).filteredrows.length;\n\t}\n\n\t/**\n\t * Rebuild idIndex\n\t */\n\tensureId() {\n\t\tvar len = this.data.length,\n\t\t\ti = 0;\n\n\t\tthis.idIndex = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tthis.idIndex.push(this.data[i].$loki);\n\t\t}\n\t}\n\n\t/**\n\t * Add a dynamic view to the collection\n\t * @param {string} name - name of dynamic view to add\n\t * @param {object=} options - (optional) options to configure dynamic view with\n\t * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t * @returns {DynamicView} reference to the dynamic view added\n\t * @memberof Collection\n\t **/\n\taddDynamicView(name, options) {\n\t\tvar dv = new DynamicView(this, name, options);\n\t\tthis.DynamicViews.push(dv);\n\n\t\treturn dv;\n\t}\n\n\t/**\n\t * Remove a dynamic view from the collection\n\t * @param {string} name - name of dynamic view to remove\n\t * @memberof Collection\n\t **/\n\tremoveDynamicView(name) {\n\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\tthis.DynamicViews.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Look up dynamic view reference from within the collection\n\t * @param {string} name - name of dynamic view to retrieve reference of\n\t * @returns {DynamicView} A reference to the dynamic view with that name\n\t * @memberof Collection\n\t **/\n\tgetDynamicView(name) {\n\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\treturn this.DynamicViews[idx];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object and passes all results to an update function.\n\t * For filter function querying you should migrate to [\n\t * Where()]{@link Collection#updateWhere}.\n\t *\n\t * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tfindAndUpdate(filterObject, updateFunction) {\n\t\tif (typeof(filterObject) === \"function\") {\n\t\t\tthis.updateWhere(filterObject, updateFunction);\n\t\t} else {\n\t\t\tthis.chain().find(filterObject).update(updateFunction);\n\t\t}\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object removes all documents which match that filter.\n\t *\n\t * @param {object} filterObject - 'mongo-like' query object\n\t * @memberof Collection\n\t */\n\tfindAndRemove(filterObject) {\n\t\tthis.chain().find(filterObject).remove();\n\t}\n\n\t/**\n\t * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n\t * @param {(object|array)} doc - the document (or array of documents) to be inserted\n\t * @returns {(object|array)} document or documents inserted\n\t * @memberof Collection\n\t */\n\tinsert(doc) {\n\t\tif (!Array.isArray(doc)) {\n\t\t\treturn this.insertOne(doc);\n\t\t}\n\n\t\t// holder to the clone of the object inserted if collections is set to clone objects\n\t\tvar obj;\n\t\tvar results = [];\n\n\t\tthis.emit('pre-insert', doc);\n\t\tfor (var i = 0, len = doc.length; i < len; i++) {\n\t\t\tobj = this.insertOne(doc[i], true);\n\t\t\tif (!obj) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tresults.push(obj);\n\t\t}\n\t\tthis.emit('insert', doc);\n\t\treturn results.length === 1 ? results[0] : results;\n\t}\n\n\t/**\n\t * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n\t * @param {object} doc - the document to be inserted\n\t * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n\t * @returns {object} document or 'undefined' if there was a problem inserting it\n\t * @memberof Collection\n\t */\n\tinsertOne(doc, bulkInsert) {\n\t\tvar err = null;\n\t\tvar returnObj;\n\n\t\tif (typeof doc !== 'object') {\n\t\t\terr = new TypeError('Document needs to be an object');\n\t\t} else if (doc === null) {\n\t\t\terr = new TypeError('Object cannot be null');\n\t\t}\n\n\t\tif (err !== null) {\n\t\t\tthis.emit('error', err);\n\t\t\tthrow err;\n\t\t}\n\n\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\tvar obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n\t\tif (typeof obj.meta === 'undefined') {\n\t\t\tobj.meta = {\n\t\t\t\trevision: 0,\n\t\t\t\tcreated: 0\n\t\t\t};\n\t\t}\n\n\t\t// allow pre-insert to modify actual collection reference even if cloning\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('pre-insert', obj);\n\t\t}\n\t\tif (!this.add(obj)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// FullTextSearch.\n\t\tif (this._fullTextSearch !== null) {\n\t\t\tthis._fullTextSearch.addDocument(doc);\n\t\t}\n\n\t\t// if cloning, give user back clone of 'cloned' object with $loki and meta\n\t\treturnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\n\t\tthis.addAutoUpdateObserver(returnObj);\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('insert', returnObj);\n\t\t}\n\t\treturn returnObj;\n\t}\n\n\t/**\n\t * Empties the collection.\n\t * @param {object=} options - configure clear behavior\n\t * @param {bool=} options.removeIndices - (default: false)\n\t * @memberof Collection\n\t */\n\tclear(options) {\n\t\tvar self = this;\n\n\t\toptions = options || {};\n\n\t\tthis.data = [];\n\t\tthis.idIndex = [];\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\t\tthis.maxId = 0;\n\t\tthis.DynamicViews = [];\n\t\tthis.dirty = true;\n\n\t\t// if removing indices entirely\n\t\tif (options.removeIndices === true) {\n\t\t\tthis.binaryIndices = {};\n\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\t\t\tthis.uniqueNames = [];\n\t\t}\n\t\t// clear indices but leave definitions in place\n\t\telse {\n\t\t\t// clear binary indices\n\t\t\tvar keys = Object.keys(this.binaryIndices);\n\t\t\tkeys.forEach(function (biname) {\n\t\t\t\tself.binaryIndices[biname].dirty = false;\n\t\t\t\tself.binaryIndices[biname].values = [];\n\t\t\t});\n\n\t\t\t// clear entire unique indices definition\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\n\t\t\t// add definitions back\n\t\t\tthis.uniqueNames.forEach(function (uiname) {\n\t\t\t\tself.ensureUniqueIndex(uiname);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Updates an object and notifies collection that the document has changed.\n\t * @param {object} doc - document to update within the collection\n\t * @memberof Collection\n\t */\n\tupdate(doc) {\n\t\tif (Array.isArray(doc)) {\n\t\t\tvar k = 0,\n\t\t\t\tlen = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.update(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify object is a properly formed document\n\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\tthrow new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n\t\t}\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tvar arr = this.get(doc.$loki, true),\n\t\t\t\toldInternal, // ref to existing obj\n\t\t\t\tnewInternal, // ref to new internal obj\n\t\t\t\tposition,\n\t\t\t\tself = this;\n\n\t\t\tif (!arr) {\n\t\t\t\tthrow new Error('Trying to update a document not in collection.');\n\t\t\t}\n\n\t\t\toldInternal = arr[0]; // -internal- obj ref\n\t\t\tposition = arr[1]; // position in data array\n\n\t\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\t\tnewInternal = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n\t\t\tthis.emit('pre-update', doc);\n\n\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\tself.constraints.unique[key].update(oldInternal, newInternal);\n\t\t\t});\n\n\t\t\t// operate the update\n\t\t\tthis.data[position] = newInternal;\n\n\t\t\tif (newInternal !== doc) {\n\t\t\t\tthis.addAutoUpdateObserver(doc);\n\t\t\t}\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].evaluateDocument(position, false);\n\t\t\t}\n\n\t\t\tvar key;\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexUpdate(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.idIndex[position] = newInternal.$loki;\n\t\t\t//this.flagBinaryIndexesDirty();\n\n\t\t\t// FullTextSearch.\n\t\t\tif (this._fullTextSearch !== null) {\n\t\t\t\tthis._fullTextSearch.updateDocument(doc);\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\tthis.emit('update', doc, this.cloneObjects ? clone(oldInternal, this.cloneMethod) : null);\n\t\t\treturn doc;\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Add object to collection\n\t */\n\tadd(obj) {\n\t\t// if parameter isn't object exit with throw\n\t\tif ('object' !== typeof obj) {\n\t\t\tthrow new TypeError('Object being added needs to be an object');\n\t\t}\n\t\t// if object you are adding already has id column it is either already in the collection\n\t\t// or the object is carrying its own 'id' property.  If it also has a meta property,\n\t\t// then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n\t\tif (typeof(obj.$loki) !== 'undefined') {\n\t\t\tthrow new Error('Document is already in collection, please use update()');\n\t\t}\n\n\t\t/*\n\t\t * try adding object to collection\n\t\t */\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tthis.maxId++;\n\n\t\t\tif (isNaN(this.maxId)) {\n\t\t\t\tthis.maxId = (this.data[this.data.length - 1].$loki + 1);\n\t\t\t}\n\n\t\t\tobj.$loki = this.maxId;\n\t\t\tobj.meta.version = 0;\n\n\t\t\tvar key, constrUnique = this.constraints.unique;\n\t\t\tfor (key in constrUnique) {\n\t\t\t\tif (hasOwnProperty.call(constrUnique, key)) {\n\t\t\t\t\tconstrUnique[key].set(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add new obj id to idIndex\n\t\t\tthis.idIndex.push(obj.$loki);\n\n\t\t\t// add the object\n\t\t\tthis.data.push(obj);\n\n\t\t\tvar addedPos = this.data.length - 1;\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tvar dvlen = this.DynamicViews.length;\n\t\t\tfor (var i = 0; i < dvlen; i++) {\n\t\t\t\tthis.DynamicViews[i].evaluateDocument(addedPos, true);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexInsert(addedPos, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\treturn (this.cloneObjects) ? (clone(obj, this.cloneMethod)) : (obj);\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Applies a filter function and passes all results to an update function.\n\t *\n\t * @param {function} filterFunction - filter function whose results will execute update\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tupdateWhere(filterFunction, updateFunction) {\n\t\tvar results = this.where(filterFunction),\n\t\t\ti = 0,\n\t\t\tobj;\n\t\ttry {\n\t\t\tfor (i; i < results.length; i++) {\n\t\t\t\tobj = updateFunction(results[i]);\n\t\t\t\tthis.update(obj);\n\t\t\t}\n\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t}\n\t}\n\n\t/**\n\t * Remove all documents matching supplied filter function.\n\t * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n\t * @param {function|object} query - query object to filter on\n\t * @memberof Collection\n\t */\n\tremoveWhere(query) {\n\t\tvar list;\n\t\tif (typeof query === 'function') {\n\t\t\tlist = this.data.filter(query);\n\t\t\tthis.remove(list);\n\t\t} else {\n\t\t\tthis.chain().find(query).remove();\n\t\t}\n\t}\n\n\tremoveDataOnly() {\n\t\tthis.remove(this.data.slice());\n\t}\n\n\t/**\n\t * Remove a document from the collection\n\t * @param {object} doc - document to remove from collection\n\t * @memberof Collection\n\t */\n\tremove(doc) {\n\t\tif (typeof doc === 'number') {\n\t\t\tdoc = this.get(doc);\n\t\t}\n\n\t\tif ('object' !== typeof doc) {\n\t\t\tthrow new Error('Parameter is not an object');\n\t\t}\n\t\tif (Array.isArray(doc)) {\n\t\t\tvar k = 0,\n\t\t\t\tlen = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.remove(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\tthrow new Error('Object is not a document stored in the collection');\n\t\t}\n\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tvar arr = this.get(doc.$loki, true),\n\t\t\t\t// obj = arr[0],\n\t\t\t\tposition = arr[1];\n\t\t\tvar self = this;\n\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\tif (doc[key] !== null && typeof doc[key] !== 'undefined') {\n\t\t\t\t\tself.constraints.unique[key].remove(doc[key]);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to remove\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].removeDocument(position);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar key, bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexRemove(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.data.splice(position, 1);\n\t\t\tthis.removeAutoUpdateObserver(doc);\n\n\t\t\t// remove id from idIndex\n\t\t\tthis.idIndex.splice(position, 1);\n\n\t\t\t// FullTextSearch.\n\t\t\tif (this._fullTextSearch != null) {\n\t\t\t\tthis._fullTextSearch.removeDocument(doc);\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\t\t\tthis.emit('delete', arr[0]);\n\t\t\tdelete doc.$loki;\n\t\t\tdelete doc.meta;\n\t\t\treturn doc;\n\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/*---------------------+\n\t | Finding methods     |\n\t +----------------------*/\n\n\t/**\n\t * Get by Id - faster than other methods because of the searching algorithm\n\t * @param {int} id - $loki id of document you want to retrieve\n\t * @param {boolean} returnPosition - if 'true' we will return [object, position]\n\t * @returns {(object|array|null)} Object reference if document was found, null if not,\n\t *     or an array if 'returnPosition' was passed.\n\t * @memberof Collection\n\t */\n\tget(id, returnPosition) {\n\t\tvar retpos = returnPosition || false,\n\t\t\tdata = this.idIndex,\n\t\t\tmax = data.length - 1,\n\t\t\tmin = 0,\n\t\t\tmid = (min + max) >> 1;\n\n\t\tid = typeof id === 'number' ? id : parseInt(id, 10);\n\n\t\tif (isNaN(id)) {\n\t\t\tthrow new TypeError('Passed id is not an integer');\n\t\t}\n\n\t\twhile (data[min] < data[max]) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (data[mid] < id) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tif (max === min && data[min] === id) {\n\t\t\tif (retpos) {\n\t\t\t\treturn [this.data[min], min];\n\t\t\t}\n\t\t\treturn this.data[min];\n\t\t}\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n\t *    Since multiple documents may contain the same value (which the index is sorted on),\n\t *    we hone in on range and then linear scan range to find exact index array position.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tgetBinaryIndexPosition(dataPosition, binaryIndexName) {\n\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\n\t\t// i think calculateRange can probably be moved to collection\n\t\t// as it doesn't seem to need resultset.  need to verify\n\t\t//var rs = new Resultset(this, null, null);\n\t\tvar range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n\t\tif (range[0] === 0 && range[1] === -1) {\n\t\t\t// uhoh didn't find range\n\t\t\treturn null;\n\t\t}\n\n\t\tvar min = range[0];\n\t\tvar max = range[1];\n\n\t\t// narrow down the sub-segment of index values\n\t\t// where the indexed property value exactly matches our\n\t\t// value and then linear scan to find exact -index- position\n\t\tfor (var idx = min; idx <= max; idx++) {\n\t\t\tif (index[idx] === dataPosition) return idx;\n\t\t}\n\n\t\t// uhoh\n\t\treturn null;\n\t}\n\n\t/**\n\t * Adaptively insert a selected item to the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexInsert(dataPosition, binaryIndexName) {\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\t//var rs = new Resultset(this, null, null);\n\t\tvar idxPos = this.calculateRangeStart(binaryIndexName, val);\n\n\t\t// insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n\t\t// doing this after adjusting dataPositions so no clash with previous item at that position.\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n\t}\n\n\t/**\n\t * Adaptively update a selected item within an index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexUpdate(dataPosition, binaryIndexName) {\n\t\t// linear scan needed to find old position within index unless we optimize for clone scenarios later\n\t\t// within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n\t\tvar idxPos,\n\t\t\tindex = this.binaryIndices[binaryIndexName].values,\n\t\t\tlen = index.length;\n\n\t\tfor (idxPos = 0; idxPos < len; idxPos++) {\n\t\t\tif (index[idxPos] === dataPosition) break;\n\t\t}\n\n\t\t//var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t//this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n\t\tthis.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n\t}\n\n\t/**\n\t * Adaptively remove a selected item from the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexRemove(dataPosition, binaryIndexName, removedFromIndexOnly) {\n\t\tvar idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\tvar len,\n\t\t\tidx;\n\n\t\tif (idxPos === null) {\n\t\t\t// throw new Error('unable to determine binary index position');\n\t\t\treturn null;\n\t\t}\n\n\t\t// remove document from index\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t// if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n\t\t// in which case data positions stay the same.\n\t\tif (removedFromIndexOnly === true) {\n\t\t\treturn;\n\t\t}\n\n\t\t// since index stores data array positions, if we remove a document\n\t\t// we need to adjust array positions -1 for all document positions greater than removed position\n\t\tlen = index.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tif (index[idx] > dataPosition) {\n\t\t\t\tindex[idx]--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method used for index maintenance.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the proper location where it can be added.\n\t */\n\tcalculateRangeStart(prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(rcd[index[mid]][prop], val, false)) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tvar lbound = min;\n\n\t\tif (ltHelper(rcd[index[lbound]][prop], val, false)) {\n\t\t\treturn lbound + 1;\n\t\t} else {\n\t\t\treturn lbound;\n\t\t}\n\t}\n\n\t/**\n\t * Internal method used for indexed $between.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the final position of that upper range value.\n\t */\n\tcalculateRangeEnd(prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(val, rcd[index[mid]][prop], false)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tvar ubound = max;\n\n\t\tif (gtHelper(rcd[index[ubound]][prop], val, false)) {\n\t\t\treturn ubound - 1;\n\t\t} else {\n\t\t\treturn ubound;\n\t\t}\n\t}\n\n\t/**\n\t * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n\t *    this is used for collection.find() and first find filter of resultset/dynview\n\t *    slightly different than get() binary search in that get() hones in on 1 value,\n\t *    but we have to hone in on many (range)\n\t * @param {string} op - operation, such as $eq\n\t * @param {string} prop - name of property to calculate range for\n\t * @param {object} val - value to use for range calculation.\n\t * @returns {array} [start, end] index array positions\n\t */\n\tcalculateRange(op, prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\t// when no documents are in collection, return empty range condition\n\t\tif (rcd.length === 0) {\n\t\t\treturn [0, -1];\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// if value falls outside of our range return [0, -1] to designate no results\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\tcase '$aeq':\n\t\t\t\tif (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$dteq':\n\t\t\t\tif (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gt':\n\t\t\t\tif (gtHelper(val, maxVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gte':\n\t\t\t\tif (gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lt':\n\t\t\t\tif (ltHelper(val, minVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (ltHelper(maxVal, val, false)) {\n\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lte':\n\t\t\t\tif (ltHelper(val, minVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (ltHelper(maxVal, val, true)) {\n\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$between':\n\t\t\t\treturn ([this.calculateRangeStart(prop, val[0]), this.calculateRangeEnd(prop, val[1])]);\n\t\t\tcase '$in':\n\t\t\t\tvar idxset = [],\n\t\t\t\t\tsegResult = [];\n\t\t\t\t// query each value '$eq' operator and merge the seqment results.\n\t\t\t\tfor (var j = 0, len = val.length; j < len; j++) {\n\t\t\t\t\tvar seg = this.calculateRange('$eq', prop, val[j]);\n\n\t\t\t\t\tfor (var i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\tif (idxset[i] === undefined) {\n\t\t\t\t\t\t\tidxset[i] = true;\n\t\t\t\t\t\t\tsegResult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn segResult;\n\t\t}\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(rcd[index[mid]][prop], val, false)) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tvar lbound = min;\n\n\t\t// do not reset min, as the upper bound cannot be prior to the found low bound\n\t\tmax = index.length - 1;\n\n\t\t// hone in on end position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(val, rcd[index[mid]][prop], false)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tvar ubound = max;\n\n\t\tvar lval = rcd[index[lbound]][prop];\n\t\tvar uval = rcd[index[ubound]][prop];\n\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\t\tif (lval !== val) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (uval !== val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, ubound];\n\t\t\tcase '$dteq':\n\t\t\t\tif (lval > val || lval < val) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (uval > val || uval < val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, ubound];\n\n\n\t\t\tcase '$gt':\n\t\t\t\tif (ltHelper(uval, val, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\treturn [ubound, rcd.length - 1];\n\n\t\t\tcase '$gte':\n\t\t\t\tif (ltHelper(lval, val, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, rcd.length - 1];\n\n\t\t\tcase '$lt':\n\t\t\t\tif (lbound === 0 && ltHelper(lval, val, false)) {\n\t\t\t\t\treturn [0, 0];\n\t\t\t\t}\n\t\t\t\treturn [0, lbound - 1];\n\n\t\t\tcase '$lte':\n\t\t\t\tif (uval !== val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\tif (ubound === 0 && ltHelper(uval, val, false)) {\n\t\t\t\t\treturn [0, 0];\n\t\t\t\t}\n\t\t\t\treturn [0, ubound];\n\n\t\t\tdefault:\n\t\t\t\treturn [0, rcd.length - 1];\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve doc by Unique index\n\t * @param {string} field - name of uniquely indexed property to use when doing lookup\n\t * @param {value} value - unique value to search for\n\t * @returns {object} document matching the value passed\n\t * @memberof Collection\n\t */\n\tby(field, value) {\n\t\tvar self;\n\t\tif (value === undefined) {\n\t\t\tself = this;\n\t\t\treturn function (value) {\n\t\t\t\treturn self.by(field, value);\n\t\t\t};\n\t\t}\n\n\t\tvar result = this.constraints.unique[field].get(value);\n\t\tif (!this.cloneObjects) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn clone(result, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Find one object by index property, by property equal to value\n\t * @param {object} query - query object used to perform search with\n\t * @returns {(object|null)} First matching document, or null if none\n\t * @memberof Collection\n\t */\n\tfindOne(query) {\n\t\tquery = query || {};\n\n\t\t// Instantiate Resultset and exec find op passing firstOnly = true param\n\t\tvar result = new Resultset(this, {\n\t\t\tqueryObj: query,\n\t\t\tfirstOnly: true\n\t\t});\n\n\t\tif (Array.isArray(result) && result.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif (!this.cloneObjects) {\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn clone(result, this.cloneMethod);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Chain method, used for beginning a series of chained find() and/or view() operations\n\t * on a collection.\n\t *\n\t * @param {array} transform - Ordered array of transform step objects similar to chain\n\t * @param {object} parameters - Object containing properties representing parameters to substitute\n\t * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n\t * @memberof Collection\n\t */\n\tchain(transform, parameters) {\n\t\tvar rs = new Resultset(this);\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t}\n\n\t/**\n\t * Find method, api is similar to mongodb.\n\t * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n\t * @example {@tutorial Query Examples}\n\t * @param {object} query - 'mongo-like' query object\n\t * @returns {array} Array of matching documents\n\t * @memberof Collection\n\t */\n\tfind(query) {\n\t\tif (typeof(query) === 'undefined') {\n\t\t\tquery = 'getAll';\n\t\t}\n\n\t\tvar results = new Resultset(this, {\n\t\t\tqueryObj: query\n\t\t});\n\t\tif (!this.cloneObjects) {\n\t\t\treturn results;\n\t\t} else {\n\t\t\treturn cloneObjectArray(results, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Find object by unindexed field by property equal to value,\n\t * simply iterates and returns the first element matching the query\n\t */\n\tfindOneUnindexed(prop, value) {\n\t\tvar i = this.data.length,\n\t\t\tdoc;\n\t\twhile (i--) {\n\t\t\tif (this.data[i][prop] === value) {\n\t\t\t\tdoc = this.data[i];\n\t\t\t\treturn doc;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Transaction methods\n\t */\n\n\t/** start the transation */\n\tstartTransaction() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = clone(this.data, this.cloneMethod);\n\t\t\tthis.cachedIndex = this.idIndex;\n\t\t\tthis.cachedBinaryIndex = this.binaryIndices;\n\n\t\t\t// propagate startTransaction to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].startTransaction();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** commit the transation */\n\tcommit() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = null;\n\t\t\tthis.cachedIndex = null;\n\t\t\tthis.cachedBinaryIndex = null;\n\n\t\t\t// propagate commit to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].commit();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** roll back the transation */\n\trollback() {\n\t\tif (this.transactional) {\n\t\t\tif (this.cachedData !== null && this.cachedIndex !== null) {\n\t\t\t\tthis.data = this.cachedData;\n\t\t\t\tthis.idIndex = this.cachedIndex;\n\t\t\t\tthis.binaryIndices = this.cachedBinaryIndex;\n\t\t\t}\n\n\t\t\t// propagate rollback to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].rollback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query the collection by supplying a javascript filter function.\n\t * @example\n\t * var results = coll.where(function(obj) {\n\t *   return obj.legs === 8;\n\t * });\n\t *\n\t * @param {function} fun - filter function to run against all collection docs\n\t * @returns {array} all documents which pass your filter function\n\t * @memberof Collection\n\t */\n\twhere(fun) {\n\t\tvar results = new Resultset(this, {\n\t\t\tqueryFunc: fun\n\t\t});\n\t\tif (!this.cloneObjects) {\n\t\t\treturn results;\n\t\t} else {\n\t\t\treturn cloneObjectArray(results, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Map Reduce operation\n\t *\n\t * @param {function} mapFunction - function to use as map function\n\t * @param {function} reduceFunction - function to use as reduce function\n\t * @returns {data} The result of your mapReduce operation\n\t * @memberof Collection\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data.map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Join two collections on specified properties\n\t *\n\t * @param {array} joinData - array of documents to 'join' to this collection\n\t * @param {string} leftJoinProp - property name in collection\n\t * @param {string} rightJoinProp - property name in joinData\n\t * @param {function=} mapFun - (Optional) map function to use\n\t * @returns {Resultset} Result of the mapping operation\n\t * @memberof Collection\n\t */\n\teqJoin(joinData, leftJoinProp, rightJoinProp, mapFun) {\n\t\t// logic in Resultset class\n\t\treturn new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);\n\t}\n\n\t/* ------ STAGING API -------- */\n\t/**\n\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t * manipulated without affecting the data in the original collection\n\t */\n\n\n\t/**\n\t * (Staging API) create a stage and/or retrieve it\n\t * @memberof Collection\n\t */\n\tgetStage(name) {\n\t\tif (!this.stages[name]) {\n\t\t\tthis.stages[name] = {};\n\t\t}\n\t\treturn this.stages[name];\n\t}\n\n\t/**\n\t * a collection of objects recording the changes applied through a commmitStage\n\t */\n\n\t/**\n\t * (Staging API) create a copy of an object and insert it into a stage\n\t * @memberof Collection\n\t */\n\tstage(stageName, obj) {\n\t\tvar copy = JSON.parse(JSON.stringify(obj));\n\t\tthis.getStage(stageName)[obj.$loki] = copy;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n\t * then create a message to be inserted in the commitlog\n\t * @param {string} stageName - name of stage\n\t * @param {string} message\n\t * @memberof Collection\n\t */\n\tcommitStage(stageName, message) {\n\t\tvar stage = this.getStage(stageName),\n\t\t\tprop,\n\t\t\ttimestamp = new Date().getTime();\n\n\t\tfor (prop in stage) {\n\n\t\t\tthis.update(stage[prop]);\n\t\t\tthis.commitLog.push({\n\t\t\t\ttimestamp: timestamp,\n\t\t\t\tmessage: message,\n\t\t\t\tdata: JSON.parse(JSON.stringify(stage[prop]))\n\t\t\t});\n\t\t}\n\t\tthis.stages[stageName] = {};\n\t}\n\n\tno_op() {\n\t\treturn;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textract(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tisDotNotation = isDeepProperty(field),\n\t\t\tresult = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tresult.push(deepProperty(this.data[i], field, isDotNotation));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmax(field) {\n\t\treturn Math.max.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmin(field) {\n\t\treturn Math.min.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmaxRecord(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tdeep = isDeepProperty(field),\n\t\t\tresult = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\tmax;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (max !== undefined) {\n\t\t\t\tif (max < deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = max;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tminRecord(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tdeep = isDeepProperty(field),\n\t\t\tresult = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\tmin;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (min !== undefined) {\n\t\t\t\tif (min > deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = min;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textractNumerical(field) {\n\t\treturn this.extract(field).map(parseBase10).filter(Number).filter(function (n) {\n\t\t\treturn !(isNaN(n));\n\t\t});\n\t}\n\n\t/**\n\t * Calculates the average numerical value of a property\n\t *\n\t * @param {string} field - name of property in docs to average\n\t * @returns {number} average of property in all docs in the collection\n\t * @memberof Collection\n\t */\n\tavg(field) {\n\t\treturn average(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * Calculate standard deviation of a field\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tstdDev(field) {\n\t\treturn standardDeviation(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tmode(field) {\n\t\tvar dict = {},\n\t\t\tdata = this.extract(field);\n\t\tdata.forEach(function (obj) {\n\t\t\tif (dict[obj]) {\n\t\t\t\tdict[obj] += 1;\n\t\t\t} else {\n\t\t\t\tdict[obj] = 1;\n\t\t\t}\n\t\t});\n\t\tvar max,\n\t\t\tprop, mode;\n\t\tfor (prop in dict) {\n\t\t\tif (max) {\n\t\t\t\tif (max < dict[prop]) {\n\t\t\t\t\tmode = prop;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmode = prop;\n\t\t\t\tmax = dict[prop];\n\t\t\t}\n\t\t}\n\t\treturn mode;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field - property name\n\t */\n\tmedian(field) {\n\t\tvar values = this.extractNumerical(field);\n\t\tvalues.sort(sub);\n\n\t\tvar half = Math.floor(values.length / 2);\n\n\t\tif (values.length % 2) {\n\t\t\treturn values[half];\n\t\t} else {\n\t\t\treturn (values[half - 1] + values[half]) / 2.0;\n\t\t}\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/collection.js\n// module id = 1\n// module chunks = 0","/**\n * Created by toni on 1/27/17.\n */\n\n\nexport var Utils = {\n\tcopyProperties: function(src, dest) {\n\t\tvar prop;\n\t\tfor (prop in src) {\n\t\t\tdest[prop] = src[prop];\n\t\t}\n\t},\n\t// used to recursively scan hierarchical transform step object for param substitution\n\tresolveTransformObject: function(subObj, params, depth) {\n\t\tvar prop,\n\t\t\tpname;\n\n\t\tif (typeof depth !== 'number') {\n\t\t\tdepth = 0;\n\t\t}\n\n\t\tif (++depth >= 10) return subObj;\n\n\t\tfor (prop in subObj) {\n\t\t\tif (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n\t\t\t\tpname = subObj[prop].substring(8);\n\t\t\t\tif (params.hasOwnProperty(pname)) {\n\t\t\t\t\tsubObj[prop] = params[pname];\n\t\t\t\t}\n\t\t\t} else if (typeof subObj[prop] === \"object\") {\n\t\t\t\tsubObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n\t\t\t}\n\t\t}\n\n\t\treturn subObj;\n\t},\n\t// top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\n\tresolveTransformParams: function(transform, params) {\n\t\tvar idx,\n\t\t\tclonedStep,\n\t\t\tresolvedTransform = [];\n\n\t\tif (typeof params === 'undefined') return transform;\n\n\t\t// iterate all steps in the transform array\n\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\t// clone transform so our scan and replace can operate directly on cloned transform\n\t\t\tclonedStep = JSON.parse(JSON.stringify(transform[idx]));\n\t\t\tresolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));\n\t\t}\n\n\t\treturn resolvedTransform;\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/utils.js\n// module id = 2\n// module chunks = 0","export function clone(data, method) {\n\tif (data === null || data === undefined) {\n\t\treturn null;\n\t}\n\n\tvar cloneMethod = method || 'parse-stringify',\n\t\tcloned;\n\n\tswitch (cloneMethod) {\n\t\tcase \"parse-stringify\":\n\t\t\tcloned = JSON.parse(JSON.stringify(data));\n\t\t\tbreak;\n\t\tcase \"jquery-extend-deep\":\n\t\t\tcloned = jQuery.extend(true, {}, data);\n\t\t\tbreak;\n\t\tcase \"shallow\":\n\t\t\tcloned = Object.create(data.prototype || null);\n\t\t\tObject.keys(data).map(function(i) {\n\t\t\t\tcloned[i] = data[i];\n\t\t\t});\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn cloned;\n}\n\nexport function cloneObjectArray(objarray, method) {\n\tvar i,\n\t\tresult = [];\n\n\tif (method == \"parse-stringify\") {\n\t\treturn clone(objarray, method);\n\t}\n\n\ti = objarray.length - 1;\n\n\tfor (; i <= 0; i--) {\n\t\tresult.push(clone(objarray[i], method));\n\t}\n\n\treturn result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/clone.js\n// module id = 3\n// module chunks = 0","/**\n * Created by toni on 1/27/17.\n */\n\n\n/** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n */\nexport function ltHelper(prop1, prop2, equal) {\n\tvar cv1, cv2;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\tif (equal) {\n\t\t\t\treturn prop1 === prop2;\n\t\t\t} else {\n\t\t\t\tif (prop1) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn prop2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\treturn equal;\n\t\t}\n\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (prop1 === prop2) {\n\t\treturn equal;\n\t}\n\n\tif (prop1 < prop2) {\n\t\treturn true;\n\t}\n\n\tif (prop1 > prop2) {\n\t\treturn false;\n\t}\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\tif (cv1 < cv2) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nexport function gtHelper(prop1, prop2, equal) {\n\tvar cv1, cv2;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\tif (equal) {\n\t\t\t\treturn prop1 === prop2;\n\t\t\t} else {\n\t\t\t\tif (prop1) {\n\t\t\t\t\treturn !prop2;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\treturn equal;\n\t\t}\n\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (prop1 === prop2) {\n\t\treturn equal;\n\t}\n\n\tif (prop1 > prop2) {\n\t\treturn true;\n\t}\n\n\tif (prop1 < prop2) {\n\t\treturn false;\n\t}\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\tif (cv1 > cv2) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/helper.js\n// module id = 4\n// module chunks = 0","\nimport {LokiEventEmitter} from './event_emitter';\n\nimport {LokiFsAdapter} from './fs_adapter';\nimport {LokiLocalStorageAdapter} from './local_storage_adapter';\nimport {Collection} from './collection';\nimport {Utils} from './utils';\n\n/*\n'LokiFsAdapter' is not defined                 no-undef\tx\n'LokiLocalStorageAdapter' is not defined       no-undef\tx\n'Collection' is not defined                    no-undef\tx\n'delim' is not defined                         no-undef\tx\n'Utils' is not defined                         no-undef\tx\n\nTBD:\n\t* Default persistence should be not available.\n\t* getIndexedAdapter is also obsolet\n\t* Make some functions private.\n\t* Inflate? -> Utils.copyProperties\n */\n\n/**\n * Loki: The main database class\n * @constructor Loki\n * @implements LokiEventEmitter\n * @param {string} filename - name of the file to be saved to\n * @param {object=} options - (Optional) config options object\n * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n * @param {boolean} options.verbose - enable console output (default is 'false')\n */\nexport class Loki extends LokiEventEmitter {\n\n\tconstructor(filename, options) {\n\t\tsuper();\n\t\tthis.filename = filename || 'loki.db';\n\t\tthis.collections = [];\n\n\t\t// persist version of code which created the database to the database.\n\t\t// could use for upgrade scenarios\n\t\tthis.databaseVersion = 1.1;\n\t\tthis.engineVersion = 1.1;\n\n\t\t// autosave support (disabled by default)\n\t\t// pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n\t\tthis.autosave = false;\n\t\tthis.autosaveInterval = 5000;\n\t\tthis.autosaveHandle = null;\n\n\t\tthis.options = {\n\t\t\tserializationMethod: options && options.hasOwnProperty('serializationMethod') ? options.serializationMethod : 'normal',\n\t\t\tdestructureDelimiter: options && options.hasOwnProperty('destructureDelimiter') ? options.destructureDelimiter : '$<\\n'\n\t\t};\n\n\t\t// currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n\t\t// will not or cannot be deserialized.  You are required to configure persistence every time\n\t\t// you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\n\t\t// persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n\t\t// this is optional option param, otherwise environment detection will be used\n\t\t// if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n\t\tthis.persistenceMethod = null;\n\n\t\t// retain reference to optional (non-serializable) persistenceAdapter 'instance'\n\t\tthis.persistenceAdapter = null;\n\n\t\t// enable console output if verbose flag is set (disabled by default)\n\t\tthis.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;\n\n\t\tthis.events = {\n\t\t\t'init': [],\n\t\t\t'loaded': [],\n\t\t\t'flushChanges': [],\n\t\t\t'close': [],\n\t\t\t'changes': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\tvar getENV = function() {\n\t\t\tif (typeof window === 'undefined') {\n\t\t\t\treturn 'NODEJS';\n\t\t\t}\n\n\t\t\tif (typeof global !== 'undefined' && global.window) {\n\t\t\t\treturn 'NODEJS'; //node-webkit\n\t\t\t}\n\n\t\t\tif (typeof document !== 'undefined') {\n\t\t\t\tif (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n\t\t\t\t\treturn 'CORDOVA';\n\t\t\t\t}\n\t\t\t\treturn 'BROWSER';\n\t\t\t}\n\t\t\treturn 'CORDOVA';\n\t\t};\n\n\t\t// refactored environment detection due to invalid detection for browser environments.\n\t\t// if they do not specify an options.env we want to detect env rather than default to nodejs.\n\t\t// currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n\t\t//   might want to review whether we can consolidate.\n\t\tif (options && options.hasOwnProperty('env')) {\n\t\t\tthis.ENV = options.env;\n\t\t} else {\n\t\t\tthis.ENV = getENV();\n\t\t}\n\n\t\tthis.on('init', this.clearChanges);\n\t}\n\n\t// experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n\t// Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n\tgetIndexedAdapter() {\n\t\tvar adapter;\n\n\t\tif (typeof require === 'function') {\n\t\t\tadapter = require(\"./loki-indexed-adapter.js\");\n\t\t}\n\n\t\treturn adapter;\n\t}\n\n\n\t/**\n\t * configures options related to database persistence.\n\t *\n\t * @param {object} options - configuration options to apply to loki db object\n\t * @param {adapter} options.adapter - an instance of a loki persistence adapter\n\t * @param {boolean} options.autosave - enables autosave\n\t * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n\t * @param {boolean} options.autoload - enables autoload on loki instantiation\n\t * @param {object} options.inflate - options that are passed to loadDatabase if autoload enabled\n\t * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']\n\t * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n\t * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n\t * @memberof Loki\n\t */\n\tinitializePersistence(options) {\n\t\tvar self = this;\n\t\tvar defaultPersistence = {\n\t\t\t\t'NODEJS': 'fs',\n\t\t\t\t'BROWSER': 'localStorage',\n\t\t\t\t'CORDOVA': 'localStorage'\n\t\t\t},\n\t\t\tpersistenceMethods = {\n\t\t\t\t'fs': LokiFsAdapter,\n\t\t\t\t'localStorage': LokiLocalStorageAdapter\n\t\t\t};\n\n\t\tthis.options = options || {};\n\n\t\tthis.persistenceMethod = null;\n\t\t// retain reference to optional persistence adapter 'instance'\n\t\t// currently keeping outside options because it can't be serialized\n\t\tthis.persistenceAdapter = null;\n\n\t\t// process the options\n\t\tif (this.options.hasOwnProperty('persistenceMethod')) {\n\t\t\t// check if the specified persistence method is known\n\t\t\tif (typeof(persistenceMethods[this.options.persistenceMethod]) === 'function') {\n\t\t\t\tthis.persistenceMethod = this.options.persistenceMethod;\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.options.persistenceMethod]();\n\t\t\t}\n\t\t\t// should be throw an error here, or just fall back to defaults ??\n\t\t}\n\n\t\t// ensure defaults exists for options which were not set\n\t\tif (!this.options.hasOwnProperty('serializationMethod')) {\n\t\t\tthis.options.serializationMethod = 'normal';\n\t\t}\n\n\t\t// ensure passed or default option exists\n\t\tif (!this.options.hasOwnProperty('destructureDelimiter')) {\n\t\t\tthis.options.destructureDelimiter = '$<\\n';\n\t\t}\n\n\t\t// if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n\t\tif (this.persistenceAdapter === null) {\n\t\t\tthis.persistenceMethod = defaultPersistence[this.ENV];\n\t\t\tif (this.persistenceMethod) {\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n\t\t\t}\n\t\t}\n\n\t\t// if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n\t\tif (this.options.hasOwnProperty('adapter')) {\n\t\t\tthis.persistenceMethod = 'adapter';\n\t\t\tthis.persistenceAdapter = this.options.adapter;\n\t\t}\n\n\t\tif (this.options.hasOwnProperty('autosaveInterval')) {\n\t\t\tthis.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n\t\t}\n\n\t\tthis.autosaveDisable();\n\n\t\tvar loaded;\n\n\t\t// if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n\t\tif (this.options.autoload) {\n\t\t\tloaded = this.loadDatabase(this.options.inflate);\n\t\t} else {\n\t\t\tloaded = Promise.resolve();\n\t\t}\n\n\t\treturn loaded.then(function() {\n\t\t\tif (self.options.autosave) {\n\t\t\t\tself.autosaveEnable();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n\t *\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n\t * @memberof Loki\n\t */\n\tcopy(options) {\n\t\tvar databaseCopy = new Loki(this.filename);\n\t\tvar clen, idx;\n\n\t\toptions = options || {};\n\n\t\t// currently inverting and letting loadJSONObject do most of the work\n\t\tdatabaseCopy.loadJSONObject(this, {\n\t\t\tretainDirtyFlags: true\n\t\t});\n\n\t\t// since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic\n\t\tif (options.hasOwnProperty(\"removeNonSerializable\") && options.removeNonSerializable === true) {\n\t\t\tdatabaseCopy.autosaveHandle = null;\n\t\t\tdatabaseCopy.persistenceAdapter = null;\n\n\t\t\tclen = databaseCopy.collections.length;\n\t\t\tfor (idx = 0; idx < clen; idx++) {\n\t\t\t\tdatabaseCopy.collections[idx].constraints = null;\n\t\t\t\tdatabaseCopy.collections[idx].ttl = null;\n\t\t\t}\n\t\t}\n\n\t\treturn databaseCopy;\n\t}\n\n\t/**\n\t * Shorthand method for quickly creating and populating an anonymous collection.\n\t *    This collection is not referenced internally so upon losing scope it will be garbage collected.\n\t *\n\t * @example\n\t * var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });\n\t *\n\t * @param {Array} docs - document array to initialize the anonymous collection with\n\t * @param {object} options - configuration object, see {@link Loki#addCollection} options\n\t * @returns {Collection} New collection which you can query or chain\n\t * @memberof Loki\n\t */\n\tanonym(docs, options) {\n\t\tvar collection = new Collection('anonym', options);\n\t\tcollection.insert(docs);\n\n\t\tif (this.verbose)\n\t\t\tcollection.console = console;\n\n\t\treturn collection;\n\t}\n\n\t/**\n\t * Adds a collection to the database.\n\t * @param {string} name - name of collection to add\n\t * @param {object=} options - (optional) options to configure collection with.\n\t * @param {array} options.unique - array of property names to define unique constraints for\n\t * @param {array} options.exact - array of property names to define exact constraints for\n\t * @param {array} options.indices - array property names to define binary indexes for\n\t * @param {boolean} options.asyncListeners - default is false\n\t * @param {boolean} options.disableChangesApi - default is true\n\t * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n\t * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n\t * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n\t * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n\t * @returns {Collection} a reference to the collection which was just added\n\t * @memberof Loki\n\t */\n\taddCollection(name, options) {\n\t\tvar collection = new Collection(name, options);\n\t\tthis.collections.push(collection);\n\n\t\tif (this.verbose)\n\t\t\tcollection.console = console;\n\n\t\treturn collection;\n\t}\n\n\tloadCollection(collection) {\n\t\tif (!collection.name) {\n\t\t\tthrow new Error('Collection must have a name property to be loaded');\n\t\t}\n\t\tthis.collections.push(collection);\n\t}\n\n\t/**\n\t * Retrieves reference to a collection by name.\n\t * @param {string} collectionName - name of collection to look up\n\t * @returns {Collection} Reference to collection in database by that name, or null if not found\n\t * @memberof Loki\n\t */\n\tgetCollection(collectionName) {\n\t\tvar i,\n\t\t\tlen = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\treturn this.collections[i];\n\t\t\t}\n\t\t}\n\n\t\t// no such collection\n\t\tthis.emit('warning', 'collection ' + collectionName + ' not found');\n\t\treturn null;\n\t}\n\n\tlistCollections() {\n\n\t\tvar i = this.collections.length,\n\t\t\tcolls = [];\n\n\t\twhile (i--) {\n\t\t\tcolls.push({\n\t\t\t\tname: this.collections[i].name,\n\t\t\t\ttype: this.collections[i].objType,\n\t\t\t\tcount: this.collections[i].data.length\n\t\t\t});\n\t\t}\n\t\treturn colls;\n\t}\n\n\t/**\n\t * Removes a collection from the database.\n\t * @param {string} collectionName - name of collection to remove\n\t * @memberof Loki\n\t */\n\tremoveCollection(collectionName) {\n\t\tvar i,\n\t\t\tlen = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\tvar tmpcol = new Collection(collectionName, {});\n\t\t\t\tvar curcol = this.collections[i];\n\t\t\t\tfor (var prop in curcol) {\n\t\t\t\t\tif (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n\t\t\t\t\t\tcurcol[prop] = tmpcol[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.collections.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * serializeReplacer - used to prevent certain properties from being serialized\n\t *\n\t */\n\tserializeReplacer(key, value) {\n\t\tswitch (key) {\n\t\t\tcase 'autosaveHandle':\n\t\t\tcase 'persistenceAdapter':\n\t\t\tcase 'constraints':\n\t\t\tcase 'ttl':\n\t\t\t\treturn null;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n\t *\n\t * @returns {string} Stringified representation of the loki database.\n\t * @memberof Loki\n\t */\n\tserialize(options) {\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"serializationMethod\")) {\n\t\t\toptions.serializationMethod = this.options.serializationMethod;\n\t\t}\n\n\t\tswitch (options.serializationMethod) {\n\t\t\tcase \"normal\":\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t\tcase \"pretty\":\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer, 2);\n\t\t\tcase \"destructured\":\n\t\t\t\treturn this.serializeDestructured(); // use default options\n\t\t\tdefault:\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t}\n\t}\n\n\t// alias of serialize\n\ttoJson() {\n\t\treturn this.serialize;\n\t}\n\n\t/**\n\t * Destructured JSON serialization routine to allow alternate serialization methods.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {object=} options - output format options for use externally to loki\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {string|array} A custom, restructured aggregation of independent serializations.\n\t * @memberof Loki\n\t */\n\tserializeDestructured(options) {\n\t\tvar idx, sidx, result, resultlen;\n\t\tvar reconstruct = [];\n\t\tvar dbcopy;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n\t\tif (options.partitioned === true && options.hasOwnProperty(\"partition\") && options.partition >= 0) {\n\t\t\treturn this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: options.partition\n\t\t\t});\n\t\t}\n\n\t\t// not just an individual collection, so we will need to serialize db container via shallow copy\n\t\tdbcopy = new Loki(this.filename);\n\t\tdbcopy.loadJSONObject(this);\n\n\t\tfor (idx = 0; idx < dbcopy.collections.length; idx++) {\n\t\t\tdbcopy.collections[idx].data = [];\n\t\t}\n\n\t\t// if we -only- wanted the db container portion, return it now\n\t\tif (options.partitioned === true && options.partition === -1) {\n\t\t\t// since we are deconstructing, override serializationMethod to normal for here\n\t\t\treturn dbcopy.serialize({\n\t\t\t\tserializationMethod: \"normal\"\n\t\t\t});\n\t\t}\n\n\t\t// at this point we must be deconstructing the entire database\n\t\t// start by pushing db serialization into first array element\n\t\treconstruct.push(dbcopy.serialize({\n\t\t\tserializationMethod: \"normal\"\n\t\t}));\n\n\t\tdbcopy = null;\n\n\t\t// push collection data into subsequent elements\n\t\tfor (idx = 0; idx < this.collections.length; idx++) {\n\t\t\tresult = this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: idx\n\t\t\t});\n\n\t\t\t// NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n\t\t\tif (options.partitioned === false && options.delimited === false) {\n\t\t\t\tif (!Array.isArray(result)) {\n\t\t\t\t\tthrow new Error(\"a nondelimited, non partitioned collection serialization did not return an expected array\");\n\t\t\t\t}\n\n\t\t\t\t// Array.concat would probably duplicate memory overhead for copying strings.\n\t\t\t\t// Instead copy each individually, and clear old value after each copy.\n\t\t\t\t// Hopefully this will allow g.c. to reduce memory pressure, if needed.\n\t\t\t\tresultlen = result.length;\n\n\t\t\t\tfor (sidx = 0; sidx < resultlen; sidx++) {\n\t\t\t\t\treconstruct.push(result[sidx]);\n\t\t\t\t\tresult[sidx] = null;\n\t\t\t\t}\n\n\t\t\t\treconstruct.push(\"\");\n\t\t\t} else {\n\t\t\t\treconstruct.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n\t\tif (options.partitioned) {\n\t\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t\t// useful for simple future adaptations of existing persistence adapters to save collections separately\n\t\t\tif (options.delimited) {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t\t// This format might be the most versatile for 'rolling your own' partitioned sync or save.\n\t\t\t// Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n\t\t\telse {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t} else {\n\t\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t\t// This is the method Loki will use internally if 'destructured'.\n\t\t\t// Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n\t\t\tif (options.delimited) {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct.join(options.delimiter);\n\t\t\t}\n\t\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\t\t\t// This format might be best candidate for custom synchronous syncs or saves\n\t\t\telse {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t}\n\n\t\treconstruct.push(\"\");\n\n\t\treturn reconstruct.join(delim);\n\t}\n\n\t/**\n\t * Utility method to serialize a collection in a 'destructured' format\n\t *\n\t * @param {object} options - used to determine output of method\n\t * @param {int=} options.delimited - whether to return single delimited string or an array\n\t * @param {string=} options.delimiter - (optional) if delimited, this is delimiter to use\n\t * @param {int} options.collectionIndex -  specify which collection to serialize data for\n\t *\n\t * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n\t * @memberof Loki\n\t */\n\tserializeCollection(options) {\n\t\tvar doccount,\n\t\t\tdocidx,\n\t\t\tresultlines = [];\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"collectionIndex\")) {\n\t\t\tthrow new Error(\"serializeCollection called without 'collectionIndex' option\");\n\t\t}\n\n\t\tdoccount = this.collections[options.collectionIndex].data.length;\n\n\t\tresultlines = [];\n\n\t\tfor (docidx = 0; docidx < doccount; docidx++) {\n\t\t\tresultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));\n\t\t}\n\n\t\t// D and DA\n\t\tif (options.delimited) {\n\t\t\t// indicate no more documents in collection (via empty delimited string)\n\t\t\tresultlines.push(\"\");\n\n\t\t\treturn resultlines.join(options.delimiter);\n\t\t} else {\n\t\t\t// NDAA and NDA\n\t\t\treturn resultlines;\n\t\t}\n\t}\n\n\t/**\n\t * Destructured JSON deserialization routine to minimize memory overhead.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {string|array} destructuredSource - destructured json or array to deserialize from\n\t * @param {object=} options - source format options\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to deserialize only a single partition\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n\t * @memberof Loki\n\t */\n\tdeserializeDestructured(destructuredSource, options) {\n\t\tvar workarray = [];\n\t\tvar len, cdb;\n\t\tvar idx, collIndex = 0,\n\t\t\tcollCount, lineIndex = 1,\n\t\t\tdone = false;\n\t\tvar currLine, currObject;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// Partitioned\n\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t// -or- single partition\n\t\tif (options.partitioned) {\n\t\t\t// handle single partition\n\t\t\tif (options.hasOwnProperty('partition')) {\n\t\t\t\t// db only\n\t\t\t\tif (options.partition === -1) {\n\t\t\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\n\t\t\t\t\treturn cdb;\n\t\t\t\t}\n\n\t\t\t\t// single collection, return doc array\n\t\t\t\treturn this.deserializeCollection(destructuredSource[options.partition + 1], options);\n\t\t\t}\n\n\t\t\t// Otherwise we are restoring an entire partitioned db\n\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\t\t\tcollCount = cdb.collections.length;\n\t\t\tfor (collIndex = 0; collIndex < collCount; collIndex++) {\n\t\t\t\t// attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n\t\t\t\tcdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n\t\t\t}\n\n\t\t\treturn cdb;\n\t\t}\n\n\t\t// Non-Partitioned\n\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\n\t\t// D\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tdestructuredSource = null; // lower memory pressure\n\t\t\tlen = workarray.length;\n\n\t\t\tif (len === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// NDA\n\t\telse {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\t// first line is database and collection shells\n\t\tcdb = JSON.parse(workarray[0]);\n\t\tcollCount = cdb.collections.length;\n\t\tworkarray[0] = null;\n\n\t\twhile (!done) {\n\t\t\tcurrLine = workarray[lineIndex];\n\n\t\t\t// empty string indicates either end of collection or end of file\n\t\t\tif (workarray[lineIndex] === \"\") {\n\t\t\t\t// if no more collections to load into, we are done\n\t\t\t\tif (++collIndex > collCount) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrObject = JSON.parse(workarray[lineIndex]);\n\t\t\t\tcdb.collections[collIndex].data.push(currObject);\n\t\t\t}\n\n\t\t\t// lower memory pressure and advance iterator\n\t\t\tworkarray[lineIndex++] = null;\n\t\t}\n\n\t\treturn cdb;\n\t}\n\n\t/**\n\t * Deserializes a destructured collection.\n\t *\n\t * @param {string|array} destructuredSource - destructured representation of collection to inflate\n\t * @param {object} options - used to describe format of destructuredSource input\n\t * @param {int} options.delimited - whether source is delimited string or an array\n\t * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n\t *\n\t * @returns {array} an array of documents to attach to collection.data.\n\t * @memberof Loki\n\t */\n\tdeserializeCollection(destructuredSource, options) {\n\t\tvar workarray = [];\n\t\tvar idx, len;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tworkarray.pop();\n\t\t} else {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\tlen = workarray.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tworkarray[idx] = JSON.parse(workarray[idx]);\n\t\t}\n\n\t\treturn workarray;\n\t}\n\n\t/**\n\t * Inflates a loki database from a serialized JSON string\n\t *\n\t * @param {string} serializedDb - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t * @memberof Loki\n\t */\n\tloadJSON(serializedDb, options) {\n\t\tvar dbObject;\n\t\tif (serializedDb.length === 0) {\n\t\t\tdbObject = {};\n\t\t} else {\n\t\t\t// using option defined in instantiated db not what was in serialized db\n\t\t\tswitch (this.options.serializationMethod) {\n\t\t\t\tcase \"normal\":\n\t\t\t\tcase \"pretty\":\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"destructured\":\n\t\t\t\t\tdbObject = this.deserializeDestructured(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.loadJSONObject(dbObject, options);\n\t}\n\n\t/**\n\t * Inflates a loki database from a JS object\n\t *\n\t * @param {object} dbObject - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool?} options.retainDirtyFlags - whether collection dirty flags will be preserved\n\t * @memberof Loki\n\t */\n\tloadJSONObject(dbObject, options) {\n\t\tvar i = 0,\n\t\t\tlen = dbObject.collections ? dbObject.collections.length : 0,\n\t\t\tcoll,\n\t\t\tcopyColl,\n\t\t\tclen,\n\t\t\tj,\n\t\t\tloader,\n\t\t\tcollObj;\n\n\t\tthis.name = dbObject.name;\n\n\t\t// restore database version\n\t\tthis.databaseVersion = 1.0;\n\t\tif (dbObject.hasOwnProperty('databaseVersion')) {\n\t\t\tthis.databaseVersion = dbObject.databaseVersion;\n\t\t}\n\n\t\tthis.collections = [];\n\n\t\tfunction makeLoader(coll) {\n\t\t\tvar collOptions = options[coll.name];\n\t\t\tvar inflater;\n\n\t\t\tif (collOptions.proto) {\n\t\t\t\tinflater = collOptions.inflate || Utils.copyProperties;\n\n\t\t\t\treturn function(data) {\n\t\t\t\t\tvar collObj = new(collOptions.proto)();\n\t\t\t\t\tinflater(data, collObj);\n\t\t\t\t\treturn collObj;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn collOptions.inflate;\n\t\t}\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tcoll = dbObject.collections[i];\n\t\t\tcopyColl = this.addCollection(coll.name);\n\n\t\t\tcopyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? (coll.adaptiveBinaryIndices === true) : false;\n\t\t\tcopyColl.transactional = coll.transactional;\n\t\t\tcopyColl.asyncListeners = coll.asyncListeners;\n\t\t\tcopyColl.disableChangesApi = coll.disableChangesApi;\n\t\t\tcopyColl.cloneObjects = coll.cloneObjects;\n\t\t\tcopyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n\t\t\tcopyColl.autoupdate = coll.autoupdate;\n\t\t\tcopyColl.changes = coll.changes;\n\n\t\t\tif (options && options.retainDirtyFlags === true) {\n\t\t\t\tcopyColl.dirty = coll.dirty;\n\t\t\t} else {\n\t\t\t\tcopyColl.dirty = false;\n\t\t\t}\n\n\t\t\t// load each element individually\n\t\t\tclen = coll.data.length;\n\t\t\tj = 0;\n\t\t\tif (options && options.hasOwnProperty(coll.name)) {\n\t\t\t\tloader = makeLoader(coll);\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcollObj = loader(coll.data[j]);\n\t\t\t\t\tcopyColl.data[j] = collObj;\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(collObj);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcopyColl.data[j] = coll.data[j];\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(copyColl.data[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcopyColl.maxId = (coll.data.length === 0) ? 0 : coll.maxId;\n\t\t\tcopyColl.idIndex = coll.idIndex;\n\t\t\tif (typeof(coll.binaryIndices) !== 'undefined') {\n\t\t\t\tcopyColl.binaryIndices = coll.binaryIndices;\n\t\t\t}\n\t\t\tif (typeof coll.transforms !== 'undefined') {\n\t\t\t\tcopyColl.transforms = coll.transforms;\n\t\t\t}\n\n\t\t\tcopyColl.ensureId();\n\n\t\t\t// regenerate unique indexes\n\t\t\tcopyColl.uniqueNames = [];\n\t\t\tif (coll.hasOwnProperty(\"uniqueNames\")) {\n\t\t\t\tcopyColl.uniqueNames = coll.uniqueNames;\n\t\t\t\tfor (j = 0; j < copyColl.uniqueNames.length; j++) {\n\t\t\t\t\tcopyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case they are loading a database created before we added dynamic views, handle undefined\n\t\t\tif (typeof(coll.DynamicViews) === 'undefined') continue;\n\n\t\t\t// reinflate DynamicViews and attached Resultsets\n\t\t\tfor (var idx = 0; idx < coll.DynamicViews.length; idx++) {\n\t\t\t\tvar colldv = coll.DynamicViews[idx];\n\n\t\t\t\tvar dv = copyColl.addDynamicView(colldv.name, colldv.options);\n\t\t\t\tdv.resultdata = colldv.resultdata;\n\t\t\t\tdv.resultsdirty = colldv.resultsdirty;\n\t\t\t\tdv.filterPipeline = colldv.filterPipeline;\n\n\t\t\t\tdv.sortCriteria = colldv.sortCriteria;\n\t\t\t\tdv.sortFunction = null;\n\n\t\t\t\tdv.sortDirty = colldv.sortDirty;\n\t\t\t\tdv.resultset.filteredrows = colldv.resultset.filteredrows;\n\t\t\t\tdv.resultset.searchIsChained = colldv.resultset.searchIsChained;\n\t\t\t\tdv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\n\t\t\t\tdv.rematerialize({\n\t\t\t\t\tremoveWhereFilters: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n\t * Does not actually destroy the db.\n\t *\n\t * @returns {Promise} a Promise that resolves after closing the database succeeded\n\t * @memberof Loki\n\t */\n\tclose() {\n\t\tvar self = this;\n\t\tvar saved;\n\n\t\t// for autosave scenarios, we will let close perform final save (if dirty)\n\t\t// For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n\t\tif (this.autosave) {\n\t\t\tthis.autosaveDisable();\n\t\t\tif (this.autosaveDirty()) {\n\t\t\t\tsaved = this.saveDatabase();\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(function() {\n\t\t\tself.emit('close');\n\t\t});\n\t}\n\n\t/**-------------------------+\n\t | Changes API               |\n\t +--------------------------*/\n\n\t/**\n\t * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n\t * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n\t */\n\n\t/**\n\t * (Changes API) : takes all the changes stored in each\n\t * collection and creates a single array for the entire database. If an array of names\n\t * of collections is passed then only the included collections will be tracked.\n\t *\n\t * @param {array=} optional array of collection names. No arg means all collections are processed.\n\t * @returns {array} array of changes\n\t * @see private method createChange() in Collection\n\t * @memberof Loki\n\t */\n\tgenerateChangesNotification(arrayOfCollectionNames) {\n\t\tfunction getCollName(coll) {\n\t\t\treturn coll.name;\n\t\t}\n\t\tvar changes = [],\n\t\t\tselectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\n\t\tthis.collections.forEach(function(coll) {\n\t\t\tif (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n\t\t\t\tchanges = changes.concat(coll.getChanges());\n\t\t\t}\n\t\t});\n\t\treturn changes;\n\t}\n\n\t/**\n\t * (Changes API) - stringify changes for network transmission\n\t * @returns {string} string representation of the changes\n\t * @memberof Loki\n\t */\n\tserializeChanges(collectionNamesArray) {\n\t\treturn JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n\t}\n\n\t/**\n\t * (Changes API) : clears all the changes in all collections.\n\t * @memberof Loki\n\t */\n\tclearChanges() {\n\t\tthis.collections.forEach(function(coll) {\n\t\t\tif (coll.flushChanges) {\n\t\t\t\tcoll.flushChanges();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Handles loading from file system, local storage, or adapter (indexeddb).\n\t *\n\t * @param {object} options - an object containing inflation options for each collection\n\t * @returns {Promise} a Promise that resolves after the database is loaded\n\t * @memberof Loki\n\t */\n\tloadDatabase(options) {\n\t\tvar self = this;\n\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.loadDatabase(this.filename))\n\t\t\t.then(function loadDatabaseCallback(dbString) {\n\t\t\t\tif (typeof(dbString) === 'string') {\n\t\t\t\t\tself.loadJSON(dbString, options || {});\n\t\t\t\t\tself.emit('load', self);\n\t\t\t\t} else {\n\t\t\t\t\t// if adapter has returned an js object (other than null or error) attempt to load from JSON object\n\t\t\t\t\tif (typeof(dbString) === \"object\" && dbString !== null && !(dbString instanceof Error)) {\n\t\t\t\t\t\tself.loadJSONObject(dbString, options || {});\n\t\t\t\t\t\tself.emit('load', self);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dbString instanceof Error)\n\t\t\t\t\t\t\tthrow dbString;\n\n\t\t\t\t\t\tthrow new TypeError('The persistence adapter did not load a serialized DB string or object.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles saving to file system, local storage, or adapter (indexeddb)\n\t *\n\t * @memberof Loki\n\t * @returns {Promise} a Promise that resolves after the database is persisted\n\t */\n\tsaveDatabase() {\n\t\tvar self = this;\n\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\tvar saved;\n\n\t\t// check if the adapter is requesting (and supports) a 'reference' mode export\n\t\tif (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n\t\t\t// filename may seem redundant but loadDatabase will need to expect this same filename\n\t\t\tsaved = this.persistenceAdapter.exportDatabase(this.filename, this.copy({\n\t\t\t\tremoveNonSerializable: true\n\t\t\t}));\n\t\t}\n\t\t// otherwise just pass the serialized database to adapter\n\t\telse {\n\t\t\tsaved = this.persistenceAdapter.saveDatabase(this.filename, self.serialize());\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(function() {\n\t\t\tself.autosaveClearFlags();\n\t\t\tself.emit(\"save\");\n\t\t});\n\t}\n\n\t// alias\n\tsave() {\n\t\treturn this.saveDatabase();\n\t}\n\n\t/**\n\t * Handles deleting a database from file system, local storage, or adapter (indexeddb)\n\t *\n\t * @returns {Promise} a Promise that resolves after the database is deleted\n\t * @memberof Loki\n\t */\n\tdeleteDatabase() {\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.deleteDatabase(this.filename));\n\t}\n\n\t/**\n\t * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n\t *\n\t * @returns {boolean} - true if database has changed since last autosave, false if not.\n\t */\n\tautosaveDirty() {\n\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\tif (this.collections[idx].dirty) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * autosaveClearFlags - resets dirty flags on all collections.\n\t *    Called from saveDatabase() after db is saved.\n\t *\n\t */\n\tautosaveClearFlags() {\n\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\tthis.collections[idx].dirty = false;\n\t\t}\n\t}\n\n\t/**\n\t * autosaveEnable - begin a javascript interval to periodically save the database.\n\t *\n\t */\n\tautosaveEnable() {\n\t\tif (this.autosaveHandle) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this;\n\t\tvar running = true;\n\n\t\tthis.autosave = true;\n\t\tthis.autosaveHandle = function() {\n\t\t\trunning = false;\n\t\t\tself.autosaveHandle = undefined;\n\t\t};\n\n\t\t(function saveDatabase() {\n\t\t\tsetTimeout(function() {\n\t\t\t\tif (running) {\n\t\t\t\t\tself.saveDatabase().then(saveDatabase, saveDatabase);\n\t\t\t\t}\n\t\t\t}, self.autosaveInterval);\n\t\t})();\n\t}\n\n\t/**\n\t * autosaveDisable - stop the autosave interval timer.\n\t *\n\t */\n\tautosaveDisable() {\n\t\tthis.autosave = false;\n\n\t\tif (this.autosaveHandle) {\n\t\t\tthis.autosaveHandle();\n\t\t}\n\t}\n}\n\nLoki.Plugins = {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/loki.js\n// module id = 5\n// module chunks = 0","import {clone} from './clone';\nimport {Collection} from './collection';\nimport {Utils} from './utils';\nimport {ltHelper, gtHelper} from './helper';\n\n/*\n 'Utils' is not defined                 no-undef\t(resolveTransformParams)\n 'sortHelper' is not defined            no-undef\n 'compoundeval' is not defined          no-undef\n 'indexedOpsList' is not defined        no-undef\n 'LokiOps' is not defined               no-undef\n 'dotSubScan' is not defined            no-undef\n 'clone' is not defined                 no-undef\n\n\n */\n\nfunction containsCheckFn(a) {\n\tif (typeof a === 'string' || Array.isArray(a)) {\n\t\treturn function(b) {\n\t\t\treturn a.indexOf(b) !== -1;\n\t\t};\n\t} else if (typeof a === 'object' && a !== null) {\n\t\treturn function(b) {\n\t\t\treturn hasOwnProperty.call(a, b);\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction doQueryOp(val, op) {\n\tfor (var p in op) {\n\t\tif (hasOwnProperty.call(op, p)) {\n\t\t\treturn LokiOps[p](val, op[p]);\n\t\t}\n\t}\n\treturn false;\n}\n\n\nexport var LokiOps = {\n\t// comparison operators\n\t// a is the value in the collection\n\t// b is the query value\n\t$eq: function(a, b) {\n\t\treturn a === b;\n\t},\n\n\t// abstract/loose equality\n\t$aeq: function(a, b) {\n\t\treturn a == b;\n\t},\n\n\t$ne: function(a, b) {\n\t\t// ecma 5 safe test for NaN\n\t\tif (b !== b) {\n\t\t\t// ecma 5 test value is not NaN\n\t\t\treturn (a === a);\n\t\t}\n\n\t\treturn a !== b;\n\t},\n\n\t$dteq: function(a, b) {\n\t\tif (ltHelper(a, b, false)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !gtHelper(a, b, false);\n\t},\n\n\t$gt: function(a, b) {\n\t\treturn gtHelper(a, b, false);\n\t},\n\n\t$gte: function(a, b) {\n\t\treturn gtHelper(a, b, true);\n\t},\n\n\t$lt: function(a, b) {\n\t\treturn ltHelper(a, b, false);\n\t},\n\n\t$lte: function(a, b) {\n\t\treturn ltHelper(a, b, true);\n\t},\n\n\t// ex : coll.find({'orderCount': {$between: [10, 50]}});\n\t$between: function(a, vals) {\n\t\tif (a === undefined || a === null) return false;\n\t\treturn (gtHelper(a, vals[0], true) && ltHelper(a, vals[1], true));\n\t},\n\n\t$in: function(a, b) {\n\t\treturn b.indexOf(a) !== -1;\n\t},\n\n\t$nin: function(a, b) {\n\t\treturn b.indexOf(a) === -1;\n\t},\n\n\t$keyin: function(a, b) {\n\t\treturn a in b;\n\t},\n\n\t$nkeyin: function(a, b) {\n\t\treturn !(a in b);\n\t},\n\n\t$definedin: function(a, b) {\n\t\treturn b[a] !== undefined;\n\t},\n\n\t$undefinedin: function(a, b) {\n\t\treturn b[a] === undefined;\n\t},\n\n\t$regex: function(a, b) {\n\t\treturn b.test(a);\n\t},\n\n\t$containsString: function(a, b) {\n\t\treturn (typeof a === 'string') && (a.indexOf(b) !== -1);\n\t},\n\n\t$containsNone: function(a, b) {\n\t\treturn !LokiOps.$containsAny(a, b);\n\t},\n\n\t$containsAny: function(a, b) {\n\t\tvar checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$contains: function(a, b) {\n\t\tvar checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$type: function(a, b) {\n\t\tvar type = typeof a;\n\t\tif (type === 'object') {\n\t\t\tif (Array.isArray(a)) {\n\t\t\t\ttype = 'array';\n\t\t\t} else if (a instanceof Date) {\n\t\t\t\ttype = 'date';\n\t\t\t}\n\t\t}\n\t\treturn (typeof b !== 'object') ? (type === b) : doQueryOp(type, b);\n\t},\n\n\t$size: function(a, b) {\n\t\tif (Array.isArray(a)) {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$len: function(a, b) {\n\t\tif (typeof a === 'string') {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$where: function(a, b) {\n\t\treturn b(a) === true;\n\t},\n\n\t// field-level logical operators\n\t// a is the value in the collection\n\t// b is the nested query operation (for '$not')\n\t//   or an array of nested query operations (for '$and' and '$or')\n\t$not: function(a, b) {\n\t\treturn !doQueryOp(a, b);\n\t},\n\n\t$and: function(a, b) {\n\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (!doQueryOp(a, b[idx])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t$or: function(a, b) {\n\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (doQueryOp(a, b[idx])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\n// making indexing opt-in... our range function knows how to deal with these ops :\nvar indexedOpsList = ['$eq', '$aeq', '$dteq', '$gt', '$gte', '$lt', '$lte', '$in', '$between'];\n\n\nfunction sortHelper(prop1, prop2, desc) {\n\tif (prop1 === prop2) {\n\t\treturn 0;\n\t}\n\n\tif (ltHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (1) : (-1);\n\t}\n\n\tif (gtHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (-1) : (1);\n\t}\n\n\t// not lt, not gt so implied equality-- date compatible\n\treturn 0;\n}\n\n/**\n * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n *\n * @param {array} properties - array of property names, in order, by which to evaluate sort order\n * @param {object} obj1 - first object to compare\n * @param {object} obj2 - second object to compare\n * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n */\nfunction compoundeval(properties, obj1, obj2) {\n\tvar res = 0;\n\tvar prop, field;\n\tfor (var i = 0, len = properties.length; i < len; i++) {\n\t\tprop = properties[i];\n\t\tfield = prop[0];\n\t\tres = sortHelper(obj1[field], obj2[field], prop[1]);\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n/**\n * dotSubScan - helper function used for dot notation queries.\n *\n * @param {object} root - object to traverse\n * @param {array} paths - array of properties to drill into\n * @param {function} fun - evaluation function to test with\n * @param {any} value - comparative value to also pass to (compare) fun\n * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n */\nfunction dotSubScan(root, paths, fun, value, poffset) {\n\tvar pathOffset = poffset || 0;\n\tvar path = paths[pathOffset];\n\tif (root === undefined || root === null || !hasOwnProperty.call(root, path)) {\n\t\treturn false;\n\t}\n\n\tvar valueFound = false;\n\tvar element = root[path];\n\tif (pathOffset + 1 >= paths.length) {\n\t\t// if we have already expanded out the dot notation,\n\t\t// then just evaluate the test function and value on the element\n\t\tvalueFound = fun(element, value);\n\t} else if (Array.isArray(element)) {\n\t\tfor (var index = 0, len = element.length; index < len; index += 1) {\n\t\t\tvalueFound = dotSubScan(element[index], paths, fun, value, pathOffset + 1);\n\t\t\tif (valueFound === true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvalueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);\n\t}\n\n\treturn valueFound;\n}\n\n/**\n * Resultset class allowing chainable queries.  Intended to be instanced internally.\n *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n *\n * @example\n *    mycollection.chain()\n *      .find({ 'doors' : 4 })\n *      .where(function(obj) { return obj.name === 'Toyota' })\n *      .data();\n *\n * @constructor Resultset\n * @param {Collection} collection - The collection which this Resultset will query against.\n * @param {Object=} options - Object containing one or more options.\n * @param {string} options.queryObj - Optional mongo-style query object to initialize resultset with.\n * @param {function} options.queryFunc - Optional javascript filter function to initialize resultset with.\n * @param {bool} options.firstOnly - Optional boolean used by collection.findOne().\n */\nexport class Resultset {\n\n\tconstructor(collection, options) {\n\t\toptions = options || {};\n\n\t\toptions.queryObj = options.queryObj || null;\n\t\toptions.queryFunc = options.queryFunc || null;\n\t\toptions.firstOnly = options.firstOnly || false;\n\n\t\t// retain reference to collection we are querying against\n\t\tthis.collection = collection;\n\n\t\t// if chain() instantiates with null queryObj and queryFunc, so we will keep flag for later\n\t\tthis.searchIsChained = (!options.queryObj && !options.queryFunc);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\t// if user supplied initial queryObj or queryFunc, apply it\n\t\tif (typeof(options.queryObj) !== \"undefined\" && options.queryObj !== null) {\n\t\t\treturn this.find(options.queryObj, options.firstOnly);\n\t\t}\n\t\tif (typeof(options.queryFunc) !== \"undefined\" && options.queryFunc !== null) {\n\t\t\treturn this.where(options.queryFunc);\n\t\t}\n\n\t\t// otherwise return unfiltered Resultset for future filtering\n\t\treturn this;\n\t}\n\n\t/**\n\t * reset() - Reset the resultset to its initial state.\n\t *\n\t * @returns {Resultset} Reference to this resultset, for future chain operations.\n\t */\n\treset() {\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tthis.filteredrows = [];\n\t\t}\n\t\tthis.filterInitialized = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tvar copy = this.copy();\n\t\tcopy.collection = null;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Allows you to limit the number of documents passed to next chain operation.\n\t *    A resultset copy() is made to avoid altering original resultset.\n\t *\n\t * @param {int} qty - The number of documents to return.\n\t * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\tlimit(qty) {\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar rscopy = new Resultset(this.collection);\n\t\trscopy.filteredrows = this.filteredrows.slice(0, qty);\n\t\trscopy.filterInitialized = true;\n\t\treturn rscopy;\n\t}\n\n\t/**\n\t * Used for skipping 'pos' number of documents in the resultset.\n\t *\n\t * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n\t * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\toffset(pos) {\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar rscopy = new Resultset(this.collection);\n\t\trscopy.filteredrows = this.filteredrows.slice(pos);\n\t\trscopy.filterInitialized = true;\n\t\treturn rscopy;\n\t}\n\n\t/**\n\t * copy() - To support reuse of resultset in branched query situations.\n\t *\n\t * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n\t * @memberof Resultset\n\t */\n\tcopy() {\n\t\tvar result = new Resultset(this.collection);\n\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tresult.filteredrows = this.filteredrows.slice();\n\t\t}\n\t\tresult.filterInitialized = this.filterInitialized;\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Alias of copy()\n\t * @memberof Resultset\n\t */\n\tbranch() {\n\t\treturn this.copy();\n\t}\n\n\t/**\n\t * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n\t *\n\t * @param transform {(string|array)} - name of collection transform or raw transform array\n\t * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n\t * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n\t * @memberof Resultset\n\t */\n\ttransform(transform, parameters) {\n\t\tvar idx,\n\t\t\tstep,\n\t\t\trs = this;\n\n\t\t// if transform is name, then do lookup first\n\t\tif (typeof transform === 'string') {\n\t\t\tif (this.collection.transforms.hasOwnProperty(transform)) {\n\t\t\t\ttransform = this.collection.transforms[transform];\n\t\t\t}\n\t\t}\n\n\t\t// either they passed in raw transform array or we looked it up, so process\n\t\tif (typeof transform !== 'object' || !Array.isArray(transform)) {\n\t\t\tthrow new Error(\"Invalid transform\");\n\t\t}\n\n\t\tif (typeof parameters !== 'undefined') {\n\t\t\ttransform = Utils.resolveTransformParams(transform, parameters);\n\t\t}\n\n\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\tstep = transform[idx];\n\n\t\t\tswitch (step.type) {\n\t\t\t\tcase \"find\":\n\t\t\t\t\trs.find(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"where\":\n\t\t\t\t\trs.where(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"simplesort\":\n\t\t\t\t\trs.simplesort(step.property, step.desc);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"compoundsort\":\n\t\t\t\t\trs.compoundsort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sort\":\n\t\t\t\t\trs.sort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"limit\":\n\t\t\t\t\trs = rs.limit(step.value);\n\t\t\t\t\tbreak; // limit makes copy so update reference\n\t\t\t\tcase \"offset\":\n\t\t\t\t\trs = rs.offset(step.value);\n\t\t\t\t\tbreak; // offset makes copy so update reference\n\t\t\t\tcase \"map\":\n\t\t\t\t\trs = rs.map(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"eqJoin\":\n\t\t\t\t\trs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases break chain by returning array data so make any of these last in transform steps\n\t\t\t\tcase \"mapReduce\":\n\t\t\t\t\trs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases update documents in current filtered resultset (use carefully)\n\t\t\t\tcase \"update\":\n\t\t\t\t\trs.update(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\trs.remove();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn rs;\n\t}\n\n\t/**\n\t * Instances a new anonymous collection with the documents contained in the current resultset.\n\t *\n\t * @param {object} collectionOptions - Options to pass to new anonymous collection construction.\n\t * @returns {Collection} A reference to an anonymous collection initialized with resultset data().\n\t * @memberof Resultset\n\t */\n\tinstance(collectionOptions) {\n\t\tvar docs = this.data();\n\t\tvar idx,\n\t\t\tdoc;\n\n\t\tcollectionOptions = collectionOptions || {};\n\n\t\tvar instanceCollection = new Collection(collectionOptions);\n\n\t\tfor (idx = 0; idx < docs.length; idx++) {\n\t\t\tif (this.collection.cloneObjects) {\n\t\t\t\tdoc = docs[idx];\n\t\t\t} else {\n\t\t\t\tdoc = clone(docs[idx], this.collection.cloneMethod);\n\t\t\t}\n\n\t\t\tdelete doc.$loki;\n\t\t\tdelete doc.meta;\n\n\t\t\tinstanceCollection.insert(doc);\n\t\t}\n\n\t\treturn instanceCollection;\n\t}\n\n\t/**\n\t * User supplied compare function is provided two documents to compare. (chainable)\n\t * @example\n\t *    rslt.sort(function(obj1, obj2) {\n\t *      if (obj1.name === obj2.name) return 0;\n\t *      if (obj1.name > obj2.name) return 1;\n\t *      if (obj1.name < obj2.name) return -1;\n\t *    });\n\t *\n\t * @param {function} comparefun - A javascript compare function used for sorting.\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsort(comparefun) {\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(userComparer, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn userComparer(data[a], data[b]);\n\t\t\t\t};\n\t\t\t})(comparefun, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n\t *    Sorting based on the same lt/gt helper functions used for binary indices.\n\t *\n\t * @param {string} propname - name of property to sort by.\n\t * @param {bool=} isdesc - (Optional) If true, the property will be sorted in descending order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsimplesort(propname, isdesc) {\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t// if we have a binary index and no other filters applied, we can use that instead of sorting (again)\n\t\t\tif (this.collection.binaryIndices.hasOwnProperty(propname)) {\n\t\t\t\t// make sure index is up-to-date\n\t\t\t\tthis.collection.ensureIndex(propname);\n\t\t\t\t// copy index values into filteredrows\n\t\t\t\tthis.filteredrows = this.collection.binaryIndices[propname].values.slice(0);\n\t\t\t\t// we are done, return this (resultset) for further chain ops\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t// otherwise initialize array for sort below\n\t\t\telse {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(isdesc) === 'undefined') {\n\t\t\tisdesc = false;\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(prop, desc, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn sortHelper(data[a][prop], data[b][prop], desc);\n\t\t\t\t};\n\t\t\t})(propname, isdesc, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * rs.compoundsort(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * rs.compoundsort(['age', ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tcompoundsort(properties) {\n\t\tif (properties.length === 0) {\n\t\t\tthrow new Error(\"Invalid call to compoundsort, need at least one property\");\n\t\t}\n\n\t\tvar prop;\n\t\tif (properties.length === 1) {\n\t\t\tprop = properties[0];\n\t\t\tif (Array.isArray(prop)) {\n\t\t\t\treturn this.simplesort(prop[0], prop[1]);\n\t\t\t}\n\t\t\treturn this.simplesort(prop, false);\n\t\t}\n\n\t\t// unify the structure of 'properties' to avoid checking it repeatedly while sorting\n\t\tfor (var i = 0, len = properties.length; i < len; i += 1) {\n\t\t\tprop = properties[i];\n\t\t\tif (!Array.isArray(prop)) {\n\t\t\t\tproperties[i] = [prop, false];\n\t\t\t}\n\t\t}\n\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(props, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn compoundeval(props, data[a], data[b]);\n\t\t\t\t};\n\t\t\t})(properties, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * findOr() - oversee the operation of OR'ed query expressions.\n\t *    OR'ed expression evaluation runs each expression individually against the full collection,\n\t *    and finally does a set OR on each expression's results.\n\t *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindOr(expressionArray) {\n\t\tvar fr = null,\n\t\t\tfri = 0,\n\t\t\tfrlen = 0,\n\t\t\tdocset = [],\n\t\t\tidxset = [],\n\t\t\tidx = 0,\n\t\t\torigCount = this.count();\n\n\t\t// If filter is already initialized, then we query against only those items already in filter.\n\t\t// This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n\t\tfor (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n\t\t\t// we need to branch existing query to run each filter separately and combine results\n\t\t\tfr = this.branch().find(expressionArray[ei]).filteredrows;\n\t\t\tfrlen = fr.length;\n\t\t\t// if the find operation did not reduce the initial set, then the initial set is the actual result\n\t\t\tif (frlen === origCount) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// add any document 'hits'\n\t\t\tfor (fri = 0; fri < frlen; fri++) {\n\t\t\t\tidx = fr[fri];\n\t\t\t\tif (idxset[idx] === undefined) {\n\t\t\t\t\tidxset[idx] = true;\n\t\t\t\t\tdocset.push(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.filteredrows = docset;\n\t\tthis.filterInitialized = true;\n\n\t\treturn this;\n\t}\n\t$or() {\n\t\treturn this.findOr(...arguments);\n\t}\n\n\t/**\n\t * findAnd() - oversee the operation of AND'ed query expressions.\n\t *    AND'ed expression evaluation runs each expression progressively against the full collection,\n\t *    internally utilizing existing chained resultset functionality.\n\t *    Only the first filter can utilize a binary index.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindAnd(expressionArray) {\n\t\t// we have already implementing method chaining in this (our Resultset class)\n\t\t// so lets just progressively apply user supplied and filters\n\t\tfor (var i = 0, len = expressionArray.length; i < len; i++) {\n\t\t\tif (this.count() === 0) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis.find(expressionArray[i]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t$and() {\n\t\treturn this.findAnd(...arguments);\n\t}\n\n\t/**\n\t * Used for querying via a mongo-style query object.\n\t *\n\t * @param {object} query - A mongo-style query object used for filtering current results.\n\t * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tfind(query, firstOnly) {\n\t\tif (this.collection.data.length === 0) {\n\t\t\tif (this.searchIsChained) {\n\t\t\t\tthis.filteredrows = [];\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tvar queryObject = query || 'getAll',\n\t\t\tp,\n\t\t\tproperty,\n\t\t\tqueryObjectOp,\n\t\t\toperator,\n\t\t\tvalue,\n\t\t\tkey,\n\t\t\tsearchByIndex = false,\n\t\t\tresult = [],\n\t\t\tindex = null;\n\n\t\t// if this was note invoked via findOne()\n\t\tfirstOnly = firstOnly || false;\n\n\t\tif (typeof queryObject === 'object') {\n\t\t\tfor (p in queryObject) {\n\t\t\t\tif (hasOwnProperty.call(queryObject, p)) {\n\t\t\t\t\tproperty = p;\n\t\t\t\t\tqueryObjectOp = queryObject[p];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// apply no filters if they want all\n\t\tif (!property || queryObject === 'getAll') {\n\t\t\t// coll.find(), coll.findOne(), coll.chain().find().data() all path here\n\n\t\t\tif (firstOnly) {\n\t\t\t\treturn (this.collection.data.length > 0) ? this.collection.data[0] : null;\n\t\t\t}\n\n\t\t\treturn (this.searchIsChained) ? (this) : (this.collection.data.slice());\n\t\t}\n\n\t\t// injecting $and and $or expression tree evaluation here.\n\t\tif (property === '$and' || property === '$or') {\n\t\t\tif (this.searchIsChained) {\n\t\t\t\tthis[property](queryObjectOp);\n\n\t\t\t\t// for chained find with firstonly,\n\t\t\t\tif (firstOnly && this.filteredrows.length > 1) {\n\t\t\t\t\tthis.filteredrows = this.filteredrows.slice(0, 1);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\t// our $and operation internally chains filters\n\t\t\t\tresult = this.collection.chain()[property](queryObjectOp).data();\n\n\t\t\t\t// if this was coll.findOne() return first object or empty array if null\n\t\t\t\t// since this is invoked from a constructor we can't return null, so we will\n\t\t\t\t// make null in coll.findOne();\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\treturn (result.length === 0) ? ([]) : (result[0]);\n\t\t\t\t}\n\n\t\t\t\t// not first only return all results\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// see if query object is in shorthand mode (assuming eq operator)\n\t\tif (queryObjectOp === null || (typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date)) {\n\t\t\toperator = '$eq';\n\t\t\tvalue = queryObjectOp;\n\t\t} else if (typeof queryObjectOp === 'object') {\n\t\t\tfor (key in queryObjectOp) {\n\t\t\t\tif (hasOwnProperty.call(queryObjectOp, key)) {\n\t\t\t\t\toperator = key;\n\t\t\t\t\tvalue = queryObjectOp[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Do not know what you want to do.');\n\t\t}\n\n\t\t// for regex ops, precompile\n\t\tif (operator === '$regex') {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue = new RegExp(value[0], value[1]);\n\t\t\t} else if (!(value instanceof RegExp)) {\n\t\t\t\tvalue = new RegExp(value);\n\t\t\t}\n\t\t}\n\n\t\tif (query.query) {\n\t\t\tlet res = this.collection._fullTextSearch.search(query);\n\t\t\tlet docIds = Object.keys(res);\n\t\t\tlet results = [];\n\t\t\tfor (let i = 0; i < docIds.length; i++) {\n\t\t\t\tlet docId = parseInt(docIds[i]);\n\t\t\t\tfor (let j = 0; j < this.collection.data.length; j++) {\n\t\t\t\t\tif (this.collection.data[j].$loki === docId) {\n\t\t\t\t\t\tresults.push(this.collection.data[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\t// if user is deep querying the object such as find('name.first': 'odin')\n\t\tvar usingDotNotation = (property.indexOf('.') !== -1);\n\n\t\t// if an index exists for the property being queried against, use it\n\t\t// for now only enabling for non-chained query (who's set of docs matches index)\n\t\t// or chained queries where it is the first filter applied and prop is indexed\n\t\tvar doIndexCheck = !usingDotNotation &&\n\t\t\t(!this.searchIsChained || !this.filterInitialized);\n\n\t\tif (doIndexCheck && this.collection.binaryIndices[property] &&\n\t\t\tindexedOpsList.indexOf(operator) !== -1) {\n\t\t\t// this is where our lazy index rebuilding will take place\n\t\t\t// basically we will leave all indexes dirty until we need them\n\t\t\t// so here we will rebuild only the index tied to this property\n\t\t\t// ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n\t\t\tif (this.collection.adaptiveBinaryIndices !== true) {\n\t\t\t\tthis.collection.ensureIndex(property);\n\t\t\t}\n\n\t\t\tsearchByIndex = true;\n\t\t\tindex = this.collection.binaryIndices[property];\n\t\t}\n\n\t\t// the comparison function\n\t\tvar fun = LokiOps[operator];\n\n\t\t// \"shortcut\" for collection data\n\t\tvar t = this.collection.data;\n\t\t// filter data length\n\t\tvar i = 0,\n\t\t\tlen = 0;\n\n\t\t// Query executed differently depending on :\n\t\t//    - whether it is chained or not\n\t\t//    - whether the property being queried has an index defined\n\t\t//    - if chained, we handle first pass differently for initial filteredrows[] population\n\t\t//\n\t\t// For performance reasons, each case has its own if block to minimize in-loop calculations\n\n\t\t// If not a chained query, bypass filteredrows and work directly against data\n\t\tif (!this.searchIsChained) {\n\t\t\tif (!searchByIndex) {\n\t\t\t\ti = t.length;\n\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\t\treturn (t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\t\treturn (t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\t// if using dot notation then treat property as keypath such as 'name.first'.\n\t\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// searching by binary index via calculateRange() utility method\n\t\t\t\tvar seg = this.collection.calculateRange(operator, property, value);\n\n\t\t\t\t// not chained so this 'find' was designated in Resultset constructor\n\t\t\t\t// so return object itself\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\tif (seg[1] !== -1) {\n\t\t\t\t\t\treturn t[index.values[seg[0]]];\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\tfor (i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\tresult.push(t[index.values[i]]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, len = seg.length; i < len; i++) {\n\t\t\t\t\t\tresult.push(t[index.values[seg[i]]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// not a chained query so return result as data[]\n\t\t\treturn result;\n\t\t}\n\n\n\t\t// Otherwise this is a chained query\n\t\t// Chained queries now preserve results ordering at expense on slightly reduced unindexed performance\n\n\t\tvar filter, rowIdx = 0;\n\n\t\t// If the filteredrows[] is already initialized, use it\n\t\tif (this.filterInitialized) {\n\t\t\tfilter = this.filteredrows;\n\t\t\tlen = filter.length;\n\n\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\tif (usingDotNotation) {\n\t\t\t\tproperty = property.split('.');\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (dotSubScan(t[rowIdx], property, fun, value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (fun(t[rowIdx][property], value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// first chained query so work against data[] but put results in filteredrows\n\t\telse {\n\t\t\t// if not searching by index\n\t\t\tif (!searchByIndex) {\n\t\t\t\tlen = t.length;\n\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// search by index\n\t\t\t\tvar segm = this.collection.calculateRange(operator, property, value);\n\n\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\tfor (i = segm[0]; i <= segm[1]; i++) {\n\t\t\t\t\t\tresult.push(index.values[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, len = segm.length; i < len; i++) {\n\t\t\t\t\t\tresult.push(index.values[segm[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.filterInitialized = true; // next time work against filteredrows[]\n\t\t}\n\n\t\tthis.filteredrows = result;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * where() - Used for filtering via a javascript filter function.\n\t *\n\t * @param {function} fun - A javascript function used for filtering current results by.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\twhere(fun) {\n\t\tvar viewFunction,\n\t\t\tresult = [];\n\n\t\tif ('function' === typeof fun) {\n\t\t\tviewFunction = fun;\n\t\t} else {\n\t\t\tthrow new TypeError('Argument is not a stored view or a function');\n\t\t}\n\t\ttry {\n\t\t\t// if not a chained query then run directly against data[] and return object []\n\t\t\tif (!this.searchIsChained) {\n\t\t\t\tvar i = this.collection.data.length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (viewFunction(this.collection.data[i]) === true) {\n\t\t\t\t\t\tresult.push(this.collection.data[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// not a chained query so returning result as data[]\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t// else chained query, so run against filteredrows\n\t\t\telse {\n\t\t\t\t// If the filteredrows[] is already initialized, use it\n\t\t\t\tif (this.filterInitialized) {\n\t\t\t\t\tvar j = this.filteredrows.length;\n\n\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\tif (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n\t\t\t\t\t\t\tresult.push(this.filteredrows[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filteredrows = result;\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\t// otherwise this is initial chained op, work against data, push into filteredrows[]\n\t\t\t\telse {\n\t\t\t\t\tvar k = this.collection.data.length;\n\n\t\t\t\t\twhile (k--) {\n\t\t\t\t\t\tif (viewFunction(this.collection.data[k]) === true) {\n\t\t\t\t\t\t\tresult.push(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\tthis.filterInitialized = true;\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * count() - returns the number of documents in the resultset.\n\t *\n\t * @returns {number} The number of documents in the resultset.\n\t * @memberof Resultset\n\t */\n\tcount() {\n\t\tif (this.searchIsChained && this.filterInitialized) {\n\t\t\treturn this.filteredrows.length;\n\t\t}\n\t\treturn this.collection.count();\n\t}\n\n\t/**\n\t * Terminates the chain and returns array of filtered documents\n\t *\n\t * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n\t * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n\t *        the collection is not configured for clone object.\n\t * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n\t *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'\n\t *\n\t * @returns {array} Array of documents in the resultset\n\t * @memberof Resultset\n\t */\n\tdata(options) {\n\t\tvar result = [],\n\t\t\tdata = this.collection.data,\n\t\t\tlen,\n\t\t\ti,\n\t\t\tmethod;\n\n\t\toptions = options || {};\n\n\t\t// if this is chained resultset with no filters applied, just return collection.data\n\t\tif (this.searchIsChained && !this.filterInitialized) {\n\t\t\tif (this.filteredrows.length === 0) {\n\t\t\t\t// determine whether we need to clone objects or not\n\t\t\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\t\t\tlen = data.length;\n\t\t\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tresult.push(clone(data[i], method));\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t// otherwise we are not cloning so return sliced array with same object references\n\t\t\t\telse {\n\t\t\t\t\treturn data.slice();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// filteredrows must have been set manually, so use it\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t}\n\t\t}\n\n\t\tvar fr = this.filteredrows;\n\t\tlen = fr.length;\n\n\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tresult.push(clone(data[fr[i]], method));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tresult.push(data[fr[i]]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Used to run an update operation on all documents currently in the resultset.\n\t *\n\t * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tupdate(updateFunction) {\n\n\t\tif (typeof(updateFunction) !== \"function\") {\n\t\t\tthrow new TypeError('Argument is not a function');\n\t\t}\n\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar len = this.filteredrows.length,\n\t\t\trcd = this.collection.data;\n\n\t\tfor (var idx = 0; idx < len; idx++) {\n\t\t\t// pass in each document object currently in resultset to user supplied updateFunction\n\t\t\tupdateFunction(rcd[this.filteredrows[idx]]);\n\n\t\t\t// notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate\n\t\t\tthis.collection.update(rcd[this.filteredrows[idx]]);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all document objects which are currently in resultset from collection (as well as resultset)\n\t *\n\t * @returns {Resultset} this (empty) resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tremove() {\n\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tthis.collection.remove(this.data());\n\n\t\tthis.filteredrows = [];\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns {value} The output of your reduceFunction\n\t * @memberof Resultset\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n\t * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n\t * @param {Array} joinData - Data array to join to.\n\t * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n\t * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n\t * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n\t * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n\t * @memberof Resultset\n\t */\n\teqJoin(joinData, leftJoinKey, rightJoinKey, mapFun) {\n\n\t\tvar leftData = [],\n\t\t\tleftDataLength,\n\t\t\trightData = [],\n\t\t\trightDataLength,\n\t\t\tkey,\n\t\t\tresult = [],\n\t\t\tleftKeyisFunction = typeof leftJoinKey === 'function',\n\t\t\trightKeyisFunction = typeof rightJoinKey === 'function',\n\t\t\tjoinMap = {};\n\n\t\t//get the left data\n\t\tleftData = this.data();\n\t\tleftDataLength = leftData.length;\n\n\t\t//get the right data\n\t\tif (joinData instanceof Resultset) {\n\t\t\trightData = joinData.data();\n\t\t} else if (Array.isArray(joinData)) {\n\t\t\trightData = joinData;\n\t\t} else {\n\t\t\tthrow new TypeError('joinData needs to be an array or result set');\n\t\t}\n\t\trightDataLength = rightData.length;\n\n\t\t//construct a lookup table\n\n\t\tfor (var i = 0; i < rightDataLength; i++) {\n\t\t\tkey = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n\t\t\tjoinMap[key] = rightData[i];\n\t\t}\n\n\t\tif (!mapFun) {\n\t\t\tmapFun = function(left, right) {\n\t\t\t\treturn {\n\t\t\t\t\tleft: left,\n\t\t\t\t\tright: right\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\t//Run map function over each object in the resultset\n\t\tfor (var j = 0; j < leftDataLength; j++) {\n\t\t\tkey = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n\t\t\tresult.push(mapFun(leftData[j], joinMap[key] || {}));\n\t\t}\n\n\t\t//return return a new resultset with no filters\n\t\tthis.collection = new Collection('joinData');\n\t\tthis.collection.insert(result);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t}\n\n\tmap(mapFun) {\n\t\tvar data = this.data().map(mapFun);\n\t\t//return return a new resultset with no filters\n\t\tthis.collection = new Collection('mappedData');\n\t\tthis.collection.insert(data);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t}\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/resultset.js\n// module id = 6\n// module chunks = 0","\n/**\n * A loki persistence adapter which persists using node fs module\n * @constructor LokiFsAdapter\n */\nexport class LokiFsAdapter {\n\n\tconstructor() {\n\t\tthis.fs = undefined; //TODO require('fs');\n\t}\n\n\t/**\n\t * loadDatabase() - Load data from file, will throw an error if the file does not exist\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiFsAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tvar self = this;\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.stat(dbname, function(err, stats) {\n\t\t\t\tif (!err && stats.isFile()) {\n\t\t\t\t\tself.fs.readFile(dbname, {\n\t\t\t\t\t\tencoding: 'utf8'\n\t\t\t\t\t}, function readFileCallback(err, data) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * saveDatabase() - save data to file, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiFsAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tvar self = this;\n\t\tvar tmpdbname = dbname + '~';\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.writeFile(tmpdbname, dbstring, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tself.fs.rename(tmpdbname, dbname, function(err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * deleteDatabase() - delete the database file, will throw an error if the\n\t * file can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiFsAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tvar self = this;\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/fs_adapter.js\n// module id = 7\n// module chunks = 0","\nfunction localStorageAvailable() {\n\ttry {\n\t\treturn (window && window.localStorage !== undefined && window.localStorage !== null);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n/*\n 'localStorageAvailable' is not defined\n */\n\n/**\n * A loki persistence adapter which persists to web browser's local storage object\n * @constructor LokiLocalStorageAdapter\n */\nexport class LokiLocalStorageAdapter {\n\n\t/**\n\t * loadDatabase() - Load data from localstorage\n\t * @param {string} dbname - the name of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\treturn Promise.resolve(localStorage.getItem(dbname));\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n\t/**\n\t * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was saved\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.setItem(dbname, dbstring);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n\t/**\n\t * deleteDatabase() - delete the database from localstorage, will throw an error if it\n\t * can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.removeItem(dbname);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/local_storage_adapter.js\n// module id = 8\n// module chunks = 0","/*\nLoki IndexedDb Adapter (need to include this script to use it)\n\nConsole Usage can be used for management/diagnostic, here are a few examples :\nadapter.getDatabaseList(); // with no callback passed, this method will log results to console\nadapter.saveDatabase(\"UserDatabase\", JSON.stringify(myDb));\nadapter.loadDatabase(\"UserDatabase\"); // will log the serialized db to console\nadapter.deleteDatabase(\"UserDatabase\");\n*/\n\n/**\n * Loki persistence adapter class for indexedDb.\n *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n *     Utilizes the included LokiCatalog app/key/value database for actual database persistence.\n *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n *     allow separate contexts for separate apps within a domain.\n *\n * @example\n * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n *\n * @constructor LokiIndexedAdapter\n *\n * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, \"loki\" by default\n */\nexport class LokiIndexedAdapter {\n\n\tconstructor(appname) {\n\t\tthis.app = \"loki\";\n\n\t\tif (typeof(appname) !== \"undefined\") {\n\t\t\tthis.app = appname;\n\t\t}\n\n\t\t// keep reference to catalog class for base AKV operations\n\t\tthis.catalog = null;\n\n\t\tif (!this.checkAvailability()) {\n\t\t\tthrow new Error(\"indexedDB does not seem to be supported for your environment\");\n\t\t}\n\t}\n\n\t/**\n\t * Used to check if adapter is available\n\t *\n\t * @returns {boolean} true if indexeddb is available, false if not.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tcheckAvailability() {\n\t\tif (typeof indexedDB !== \"undefined\" && indexedDB) return true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Retrieves a serialized db string from the catalog.\n\t *\n\t * @example\n\t * // LOAD\n\t * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t * var db = new loki(\"test\", { adapter: idbAdapter });\n\t *   db.loadDatabase(function(result) {\n\t *   console.log(\"done\");\n\t * });\n\t *\n\t * @param {string} dbname - the name of the database to retrieve.\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiIndexedAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tadapter.catalog = new LokiCatalog(function(cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t\tresolve(adapter.loadDatabase(dbname));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// lookup up db string in AKV db\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.catalog.getAppKey(appName, dbname, function(result) {\n\t\t\t\tif (result.id === 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(result.val);\n\t\t\t});\n\t\t});\n\t}\n\n\t// alias\n\tloadKey(dbname) {\n\t\treturn this.loadDatabase(dbname);\n\t}\n\n\t/**\n\t * Saves a serialized db to the catalog.\n\t *\n\t * @example\n\t * // SAVE : will save App/Key/Val as \"finance\"/\"test\"/{serializedDb}\n\t * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t * var db = new loki(\"test\", { adapter: idbAdapter });\n\t * var coll = db.addCollection(\"testColl\");\n\t * coll.insert({test: \"val\"});\n\t * db.saveDatabase();  // could pass callback if needed for async complete\n\t *\n\t * @param {string} dbname - the name to give the serialized database within the catalog.\n\t * @param {string} dbstring - the serialized db string to save.\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiIndexedAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\tvar resolve, reject;\n\t\tvar result = new Promise(function(res, rej) {\n\t\t\tresolve = res;\n\t\t\treject = rej;\n\t\t});\n\n\t\tfunction saveCallback(result) {\n\t\t\tif (result && result.success === true) {\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\treject(new Error(\"Error saving database\"));\n\t\t\t}\n\t\t}\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t// now that catalog has been initialized, set (add/update) the AKV entry\n\t\t\t\tcat.setAppKey(appName, dbname, dbstring, saveCallback);\n\t\t\t});\n\n\t\t\treturn result;\n\t\t}\n\n\t\t// set (add/update) entry to AKV database\n\t\tthis.catalog.setAppKey(appName, dbname, dbstring, saveCallback);\n\n\t\treturn result;\n\t}\n\n\t// alias\n\tsaveKey(dbname, dbstring) {\n\t\treturn this.saveDatabase(dbname, dbstring);\n\t}\n\n\t/**\n\t * Deletes a serialized db from the catalog.\n\t *\n\t * @example\n\t * // DELETE DATABASE\n\t * // delete \"finance\"/\"test\" value from catalog\n\t * idbAdapter.deleteDatabase(\"test\", function {\n\t *   // database deleted\n\t * });\n\t *\n\t * @param {string} dbname - the name of the database to delete from the catalog.\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiIndexedAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference and pass callback ahead\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tadapter.catalog = new LokiCatalog(function(cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t\tresolve(adapter.deleteDatabase(dbname));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// catalog was already initialized, so just lookup object and delete by id\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.catalog.getAppKey(appName, dbname, function(result) {\n\t\t\t\tvar id = result.id;\n\n\t\t\t\tif (id !== 0) {\n\t\t\t\t\tadapter.catalog.deleteAppKey(id);\n\t\t\t\t}\n\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\t// alias\n\tdeleteKey(dbname) {\n\t\treturn this.deleteDatabase(dbname);\n\t}\n\n\t/**\n\t * Removes all database partitions and pages with the base filename passed in.\n\t * This utility method does not (yet) guarantee async deletions will be completed before returning\n\t *\n\t * @param {string} dbname - the base filename which container, partitions, or pages are derived\n\t * @memberof LokiIndexedAdapter\n\t */\n\tdeleteDatabasePartitions(dbname) {\n\t\tvar self = this;\n\t\tthis.getDatabaseList(function(result) {\n\t\t\tresult.forEach(function(str) {\n\t\t\t\tif (str.startsWith(dbname)) {\n\t\t\t\t\tself.deleteDatabase(str);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves object array of catalog entries for current app.\n\t *\n\t * @example\n\t * idbAdapter.getDatabaseList(function(result) {\n\t *   // result is array of string names for that appcontext (\"finance\")\n\t *   result.forEach(function(str) {\n\t *     console.log(str);\n\t *   });\n\t * });\n\t *\n\t * @param {function} callback - should accept array of database names in the catalog for current app.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tgetDatabaseList(callback) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\tadapter.getDatabaseList(callback);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// catalog already initialized\n\t\t// get all keys for current appName, and transpose results so just string array\n\t\tthis.catalog.getAppKeys(appName, function(results) {\n\t\t\tvar names = [];\n\n\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\tnames.push(results[idx].key);\n\t\t\t}\n\n\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\tcallback(names);\n\t\t\t} else {\n\t\t\t\tnames.forEach(function(obj) {\n\t\t\t\t\tconsole.log(obj);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t// alias\n\tgetKeyList(callback) {\n\t\treturn this.getDatabaseList(callback);\n\t}\n\n\t/**\n\t * Allows retrieval of list of all keys in catalog along with size\n\t *\n\t * @param {function} callback - (Optional) callback to accept result array.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tgetCatalogSummary(callback) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\tadapter.getCatalogSummary(callback);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// catalog already initialized\n\t\t// get all keys for current appName, and transpose results so just string array\n\t\tthis.catalog.getAllKeys(function(results) {\n\t\t\tvar entries = [];\n\t\t\tvar obj,\n\t\t\t\tsize,\n\t\t\t\toapp,\n\t\t\t\tokey,\n\t\t\t\toval;\n\n\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\tobj = results[idx];\n\t\t\t\toapp = obj.app || '';\n\t\t\t\tokey = obj.key || '';\n\t\t\t\toval = obj.val || '';\n\n\t\t\t\t// app and key are composited into an appkey column so we will mult by 2\n\t\t\t\tsize = oapp.length * 2 + okey.length * 2 + oval.length + 1;\n\n\t\t\t\tentries.push({\n\t\t\t\t\t\"app\": obj.app,\n\t\t\t\t\t\"key\": obj.key,\n\t\t\t\t\t\"size\": size\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\tcallback(entries);\n\t\t\t} else {\n\t\t\t\tentries.forEach(function(obj) {\n\t\t\t\t\tconsole.log(obj);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * LokiCatalog - underlying App/Key/Value catalog persistence\n *    This non-interface class implements the actual persistence.\n *    Used by the IndexedAdapter class.\n */\nclass LokiCatalog {\n\tconstructor(callback) {\n\t\tthis.db = null;\n\t\tthis.initializeLokiCatalog(callback);\n\t}\n\n\tinitializeLokiCatalog(callback) {\n\t\tvar openRequest = indexedDB.open(\"LokiCatalog\", 1);\n\t\tvar cat = this;\n\n\t\t// If database doesn't exist yet or its version is lower than our version specified above (2nd param in line above)\n\t\topenRequest.onupgradeneeded = function(e) {\n\t\t\tvar thisDB = e.target.result;\n\t\t\tif (thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\tthisDB.deleteObjectStore(\"LokiAKV\");\n\t\t\t}\n\n\t\t\tif (!thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\tvar objectStore = thisDB.createObjectStore(\"LokiAKV\", {\n\t\t\t\t\tkeyPath: \"id\",\n\t\t\t\t\tautoIncrement: true\n\t\t\t\t});\n\t\t\t\tobjectStore.createIndex(\"app\", \"app\", {\n\t\t\t\t\tunique: false\n\t\t\t\t});\n\t\t\t\tobjectStore.createIndex(\"key\", \"key\", {\n\t\t\t\t\tunique: false\n\t\t\t\t});\n\t\t\t\t// hack to simulate composite key since overhead is low (main size should be in val field)\n\t\t\t\t// user (me) required to duplicate the app and key into comma delimited appkey field off object\n\t\t\t\t// This will allow retrieving single record with that composite key as well as\n\t\t\t\t// still supporting opening cursors on app or key alone\n\t\t\t\tobjectStore.createIndex(\"appkey\", \"appkey\", {\n\t\t\t\t\tunique: true\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\topenRequest.onsuccess = function(e) {\n\t\t\tcat.db = e.target.result;\n\n\t\t\tif (typeof(callback) === \"function\") callback(cat);\n\t\t};\n\n\t\topenRequest.onerror = function(e) {\n\t\t\tthrow e;\n\t\t};\n\t}\n\n\tgetAppKey(app, key, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"appkey\");\n\t\tvar appkey = app + \",\" + key;\n\t\tvar request = index.get(appkey);\n\n\t\trequest.onsuccess = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar lres = e.target.result;\n\n\t\t\t\tif (lres === null || typeof(lres) === \"undefined\") {\n\t\t\t\t\tlres = {\n\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(lres);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(lres);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback({\n\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t}\n\n\tgetAppKeyById(id, callback, data) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar request = store.get(id);\n\n\t\trequest.onsuccess = (function(data, usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(e.target.result, data);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(e.target.result);\n\t\t\t\t}\n\t\t\t};\n\t\t})(data, callback);\n\t}\n\n\tsetAppKey(app, key, val, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"appkey\");\n\t\tvar appkey = app + \",\" + key;\n\t\tvar request = index.get(appkey);\n\n\t\t// first try to retrieve an existing object by that key\n\t\t// need to do this because to update an object you need to have id in object, otherwise it will append id with new autocounter and clash the unique index appkey\n\t\trequest.onsuccess = function(e) {\n\t\t\tvar res = e.target.result;\n\n\t\t\tif (res === null || res === undefined) {\n\t\t\t\tres = {\n\t\t\t\t\tapp: app,\n\t\t\t\t\tkey: key,\n\t\t\t\t\tappkey: app + \",\" + key,\n\t\t\t\t\tval: val\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres.val = val;\n\t\t\t}\n\n\t\t\tvar requestPut = store.put(res);\n\n\t\t\trequestPut.onerror = (function(usercallback) {\n\t\t\t\treturn function(e) {\n\t\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (set) onerror\");\n\t\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t})(callback);\n\n\t\t\trequestPut.onsuccess = (function(usercallback) {\n\t\t\t\treturn function(e) {\n\t\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tsuccess: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t})(callback);\n\t\t};\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback({\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (get) onerror\");\n\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t}\n\n\tdeleteAppKey(id, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar request = store.delete(id);\n\n\t\trequest.onsuccess = (function(usercallback) {\n\t\t\treturn function(evt) {\n\t\t\t\tif (typeof(usercallback) === \"function\") usercallback({\n\t\t\t\t\tsuccess: true\n\t\t\t\t});\n\t\t\t};\n\t\t})(callback);\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(evt) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(false);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.deleteAppKey raised onerror\");\n\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t}\n\n\tgetAppKeys(app, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"app\");\n\n\t\t// We want cursor to all values matching our (single) app param\n\t\tvar singleKeyRange = IDBKeyRange.only(app);\n\n\t\t// To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n\t\tvar cursor = index.openCursor(singleKeyRange);\n\n\t\t// cursor internally, pushing results into this.data[] and return\n\t\t// this.data[] when done (similar to service)\n\t\tvar localdata = [];\n\n\t\tcursor.onsuccess = (function(data, callback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar cursor = e.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tvar currObject = cursor.value;\n\n\t\t\t\t\tdata.push(currObject);\n\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})(localdata, callback);\n\n\t\tcursor.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(null);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.getAppKeys raised onerror\");\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\n\t}\n\n\t// Hide \"cursoring\" and return array of { id: id, key: key }\n\tgetAllKeys(callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar cursor = store.openCursor();\n\n\t\tvar localdata = [];\n\n\t\tcursor.onsuccess = (function(data, callback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar cursor = e.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tvar currObject = cursor.value;\n\n\t\t\t\t\tdata.push(currObject);\n\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})(localdata, callback);\n\n\t\tcursor.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") usercallback(null);\n\t\t\t};\n\t\t})(callback);\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/loki-indexed-adapter.js\n// module id = 9\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 10\n// module chunks = 0","import {LokiEventEmitter} from './event_emitter';\nimport {Resultset} from './resultset';\n\n/*\n'LokiEventEmitter' is not defined        no-undef\n'Resultset' is not defined               no-undef\n\napplySortCriteria -> like Resultset::compoundsort\n\nqueueRebuildEvent -> Promise?\n\n */\n\n/**\n * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n *\n * @example\n * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n * mydv.applyFind({ 'doors' : 4 });\n * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n * var results = mydv.data();\n *\n * @constructor DynamicView\n * @implements LokiEventEmitter\n * @param {Collection} collection - A reference to the collection to work against\n * @param {string} name - The name of this dynamic view\n * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n */\nexport class DynamicView extends LokiEventEmitter {\n\n\tconstructor(collection, name, options) {\n\t\tsuper();\n\t\tthis.collection = collection;\n\t\tthis.name = name;\n\t\tthis.rebuildPending = false;\n\t\tthis.options = options || {};\n\n\t\tif (!this.options.hasOwnProperty('persistent')) {\n\t\t\tthis.options.persistent = false;\n\t\t}\n\n\t\t// 'persistentSortPriority':\n\t\t// 'passive' will defer the sort phase until they call data(). (most efficient overall)\n\t\t// 'active' will sort async whenever next idle. (prioritizes read speeds)\n\t\tif (!this.options.hasOwnProperty('sortPriority')) {\n\t\t\tthis.options.sortPriority = 'passive';\n\t\t}\n\n\t\tif (!this.options.hasOwnProperty('minRebuildInterval')) {\n\t\t\tthis.options.minRebuildInterval = 1;\n\t\t}\n\n\t\tthis.resultset = new Resultset(collection);\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = false;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\t// for now just have 1 event for when we finally rebuilt lazy view\n\t\t// once we refactor transactions, i will tie in certain transactional events\n\n\t\tthis.events = {\n\t\t\t'rebuild': []\n\t\t};\n\t}\n\n\t/**\n\t * rematerialize() - intended for use immediately after deserialization (loading)\n\t *    This will clear out and reapply filterPipeline ops, recreating the view.\n\t *    Since where filters do not persist correctly, this method allows\n\t *    restoring the view to state where user can re-apply those where filters.\n\t *\n\t * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n\t * @returns {DynamicView} This dynamic view for further chained ops.\n\t * @memberof DynamicView\n\t * @fires DynamicView.rebuild\n\t */\n\trematerialize(options) {\n\t\tvar fpl,\n\t\t\tfpi,\n\t\t\tidx;\n\n\t\toptions = options || {};\n\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\t\tthis.resultset = new Resultset(this.collection);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.sortDirty = true;\n\t\t}\n\n\t\tif (options.hasOwnProperty('removeWhereFilters')) {\n\t\t\t// for each view see if it had any where filters applied... since they don't\n\t\t\t// serialize those functions lets remove those invalid filters\n\t\t\tfpl = this.filterPipeline.length;\n\t\t\tfpi = fpl;\n\t\t\twhile (fpi--) {\n\t\t\t\tif (this.filterPipeline[fpi].type === 'where') {\n\t\t\t\t\tif (fpi !== this.filterPipeline.length - 1) {\n\t\t\t\t\t\tthis.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filterPipeline.length--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n\t\tvar ofp = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\t// now re-apply 'find' filterPipeline ops\n\t\tfpl = ofp.length;\n\t\tfor (idx = 0; idx < fpl; idx++) {\n\t\t\tthis.applyFind(ofp[idx].val);\n\t\t}\n\n\t\t// during creation of unit tests, i will remove this forced refresh and leave lazy\n\t\tthis.data();\n\n\t\t// emit rebuild event in case user wants to be notified\n\t\tthis.emit('rebuild', this);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * branchResultset() - Makes a copy of the internal resultset for branched queries.\n\t *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n\t *    so your branched query should be immediately resolved and not held for future evaluation.\n\t *\n\t * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n\t * @param {object=} parameters - optional parameters (if optional transform requires them)\n\t * @returns {Resultset} A copy of the internal resultset for branched queries.\n\t * @memberof DynamicView\n\t */\n\tbranchResultset(transform, parameters) {\n\t\tvar rs = this.resultset.branch();\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t}\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tvar copy = new DynamicView(this.collection, this.name, this.options);\n\n\t\tcopy.resultset = this.resultset;\n\t\tcopy.resultdata = []; // let's not save data (copy) to minimize size\n\t\tcopy.resultsdirty = true;\n\t\tcopy.filterPipeline = this.filterPipeline;\n\t\tcopy.sortFunction = this.sortFunction;\n\t\tcopy.sortCriteria = this.sortCriteria;\n\t\tcopy.sortDirty = this.sortDirty;\n\n\t\t// avoid circular reference, reapply in db.loadJSON()\n\t\tcopy.collection = null;\n\n\t\treturn copy;\n\t}\n\n\t/**\n\t * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n\t *     Existing options should be retained.\n\t * @param {object=} options - configure removeFilter behavior\n\t * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n\t * @memberof DynamicView\n\t */\n\tremoveFilters(options) {\n\t\toptions = options || {};\n\n\t\tthis.rebuildPending = false;\n\t\tthis.resultset.reset();\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\tif (options.queueSortPhase === true) {\n\t\t\tthis.queueSortPhase();\n\t\t}\n\t}\n\n\t/**\n\t * applySort() - Used to apply a sort to the dynamic view\n\t * @example\n\t * dv.applySort(function(obj1, obj2) {\n\t *   if (obj1.name === obj2.name) return 0;\n\t *   if (obj1.name > obj2.name) return 1;\n\t *   if (obj1.name < obj2.name) return -1;\n\t * });\n\t *\n\t * @param {function} comparefun - a javascript compare function used for sorting\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySort(comparefun) {\n\t\tthis.sortFunction = comparefun;\n\t\tthis.sortCriteria = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applySimpleSort() - Used to specify a property used for view translation.\n\t * @example\n\t * dv.applySimpleSort(\"name\");\n\t *\n\t * @param {string} propname - Name of property by which to sort.\n\t * @param {boolean=} isdesc - (Optional) If true, the sort will be in descending order.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySimpleSort(propname, isdesc) {\n\t\tthis.sortCriteria = [\n\t\t\t[propname, isdesc || false]\n\t\t];\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * dv.applySortCriteria(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * dv.applySortCriteria(['age', ['name', true]);\n\t * // to sort by age (descending) and then by name (descending)\n\t * dv.applySortCriteria(['age', true], ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n\t * @memberof DynamicView\n\t */\n\tapplySortCriteria(criteria) {\n\t\tthis.sortCriteria = criteria;\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * startTransaction() - marks the beginning of a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tstartTransaction() {\n\t\tthis.cachedresultset = this.resultset.copy();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * commit() - commits a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tcommit() {\n\t\tthis.cachedresultset = null;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * rollback() - rolls back a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\trollback() {\n\t\tthis.resultset = this.cachedresultset;\n\n\t\tif (this.options.persistent) {\n\t\t\t// for now just rebuild the persistent dynamic view data in this worst case scenario\n\t\t\t// (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n\t\t\tthis.resultdata = this.resultset.data();\n\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Implementation detail.\n\t * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter.\n\t * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n\t */\n\t_indexOfFilterWithId(uid) {\n\t\tif (typeof uid === 'string' || typeof uid === 'number') {\n\t\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n\t\t\t\tif (uid === this.filterPipeline[idx].uid) {\n\t\t\t\t\treturn idx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Implementation detail.\n\t * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n\t *\n\t * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n\t */\n\t_addFilter(filter) {\n\t\tthis.filterPipeline.push(filter);\n\t\tthis.resultset[filter.type](filter.val);\n\t}\n\n\t/**\n\t * reapplyFilters() - Reapply all the filters in the current pipeline.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\treapplyFilters() {\n\t\tthis.resultset.reset();\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tvar filters = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\tfor (var idx = 0, len = filters.length; idx < len; idx += 1) {\n\t\t\tthis._addFilter(filters[idx]);\n\t\t}\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n\t *\n\t * @param {object} filter - A filter object to add to the pipeline.\n\t *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFilter(filter) {\n\t\tvar idx = this._indexOfFilterWithId(filter.uid);\n\t\tif (idx >= 0) {\n\t\t\tthis.filterPipeline[idx] = filter;\n\t\t\treturn this.reapplyFilters();\n\t\t}\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tthis._addFilter(filter);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n\t *\n\t * @param {object} query - A mongo-style query object to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFind(query, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'find',\n\t\t\tval: query,\n\t\t\tuid: uid\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n\t *\n\t * @param {function} fun - A javascript filter function to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyWhere(fun, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'where',\n\t\t\tval: fun,\n\t\t\tuid: uid\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter to be removed.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tremoveFilter(uid) {\n\t\tvar idx = this._indexOfFilterWithId(uid);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n\t\t}\n\n\t\tthis.filterPipeline.splice(idx, 1);\n\t\tthis.reapplyFilters();\n\t\treturn this;\n\t}\n\n\t/**\n\t * count() - returns the number of documents representing the current DynamicView contents.\n\t *\n\t * @returns {number} The number of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tcount() {\n\t\t// in order to be accurate we will pay the minimum cost (and not alter dv state management)\n\t\t// recurring resultset data resolutions should know internally its already up to date.\n\t\t// for persistent data this will not update resultdata nor fire rebuild event.\n\t\tif (this.resultsdirty) {\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t}\n\n\t\treturn this.resultset.count();\n\t}\n\n\t/**\n\t * data() - resolves and pending filtering and sorting, then returns document array as result.\n\t *\n\t * @returns {array} An array of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tdata() {\n\t\t// using final sort phase as 'catch all' for a few use cases which require full rebuild\n\t\tif (this.sortDirty || this.resultsdirty) {\n\t\t\tthis.performSortPhase({\n\t\t\t\tsuppressRebuildEvent: true\n\t\t\t});\n\t\t}\n\t\treturn (this.options.persistent) ? (this.resultdata) : (this.resultset.data());\n\t}\n\n\t/**\n\t * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n\t *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n\t */\n\tqueueRebuildEvent() {\n\t\tif (this.rebuildPending) {\n\t\t\treturn;\n\t\t}\n\t\tthis.rebuildPending = true;\n\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tif (self.rebuildPending) {\n\t\t\t\tself.rebuildPending = false;\n\t\t\t\tself.emit('rebuild', self);\n\t\t\t}\n\t\t}, this.options.minRebuildInterval);\n\t}\n\n\t/**\n\t * queueSortPhase : If the view is sorted we will throttle sorting to either :\n\t *    (1) passive - when the user calls data(), or\n\t *    (2) active - once they stop updating and yield js thread control\n\t */\n\tqueueSortPhase() {\n\t\t// already queued? exit without queuing again\n\t\tif (this.sortDirty) {\n\t\t\treturn;\n\t\t}\n\t\tthis.sortDirty = true;\n\n\t\tvar self = this;\n\t\tif (this.options.sortPriority === \"active\") {\n\t\t\t// active sorting... once they are done and yield js thread, run async performSortPhase()\n\t\t\tsetTimeout(function() {\n\t\t\t\tself.performSortPhase();\n\t\t\t}, this.options.minRebuildInterval);\n\t\t} else {\n\t\t\t// must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n\t\t\t// potentially notify user that data has changed.\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\t}\n\n\t/**\n\t * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n\t *\n\t */\n\tperformSortPhase(options) {\n\t\t// async call to this may have been pre-empted by synchronous call to data before async could fire\n\t\tif (!this.sortDirty && !this.resultsdirty) {\n\t\t\treturn;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tif (this.sortDirty) {\n\t\t\tif (this.sortFunction) {\n\t\t\t\tthis.resultset.sort(this.sortFunction);\n\t\t\t} else if (this.sortCriteria) {\n\t\t\t\tthis.resultset.compoundsort(this.sortCriteria);\n\t\t\t}\n\n\t\t\tthis.sortDirty = false;\n\t\t}\n\n\t\tif (this.options.persistent) {\n\t\t\t// persistent view, rebuild local resultdata array\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t\tthis.resultsdirty = false;\n\t\t}\n\n\t\tif (!options.suppressRebuildEvent) {\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\t}\n\n\t/**\n\t * evaluateDocument() - internal method for (re)evaluating document inclusion.\n\t *    Called by : collection.insert() and collection.update().\n\t *\n\t * @param {int} objIndex - index of document to (re)run through filter pipeline.\n\t * @param {bool} isNew - true if the document was just added to the collection.\n\t */\n\tevaluateDocument(objIndex, isNew) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar ofr = this.resultset.filteredrows;\n\t\tvar oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));\n\t\tvar oldlen = ofr.length;\n\n\t\t// creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n\t\t// mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n\t\tvar evalResultset = new Resultset(this.collection);\n\t\tevalResultset.filteredrows = [objIndex];\n\t\tevalResultset.filterInitialized = true;\n\t\tvar filter;\n\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n\t\t\tfilter = this.filterPipeline[idx];\n\t\t\tevalResultset[filter.type](filter.val);\n\t\t}\n\n\t\t// not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n\t\tvar newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;\n\n\t\t// wasn't in old, shouldn't be now... do nothing\n\t\tif (oldPos === -1 && newPos === -1) return;\n\n\t\t// wasn't in resultset, should be now... add\n\t\tif (oldPos === -1 && newPos !== -1) {\n\t\t\tofr.push(objIndex);\n\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata.push(this.collection.data[objIndex]);\n\t\t\t}\n\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, shouldn't be now... delete\n\t\tif (oldPos !== -1 && newPos === -1) {\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr.splice(oldPos, 1);\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.splice(oldPos, 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, should still be now... (update persistent only?)\n\t\tif (oldPos !== -1 && newPos !== -1) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\t// in case document changed, replace persistent view data with the latest collection.data document\n\t\t\t\tthis.resultdata[oldPos] = this.collection.data[objIndex];\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * removeDocument() - internal function called on collection.delete()\n\t */\n\tremoveDocument(objIndex) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar ofr = this.resultset.filteredrows;\n\t\tvar oldPos = ofr.indexOf(+objIndex);\n\t\tvar oldlen = ofr.length;\n\t\tvar idx;\n\n\t\tif (oldPos !== -1) {\n\t\t\t// if not last row in resultdata, swap last to hole and truncate last row\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr[oldPos] = ofr[oldlen - 1];\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata[oldPos] = this.resultdata[oldlen - 1];\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// last row, so just truncate last row\n\t\t\telse {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t}\n\n\t\t// since we are using filteredrows to store data array positions\n\t\t// if they remove a document (whether in our view or not),\n\t\t// we need to adjust array positions -1 for all document array references after that position\n\t\toldlen = ofr.length;\n\t\tfor (idx = 0; idx < oldlen; idx++) {\n\t\t\tif (ofr[idx] > objIndex) {\n\t\t\t\tofr[idx]--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * mapReduce() - data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns The output of your reduceFunction\n\t * @memberof DynamicView\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/dynamic_view.js\n// module id = 11\n// module chunks = 0","export class ExactIndex {\n\n\tconstructor(exactField) {\n\t\tthis.index = {};\n\t\tthis.field = exactField;\n\t}\n\n\t// add the value you want returned to the key in the index\n\tset(key, val) {\n\t\tif (this.index[key]) {\n\t\t\tthis.index[key].push(val);\n\t\t} else {\n\t\t\tthis.index[key] = [val];\n\t\t}\n\t\tconsole.log(\"?\");\n\t}\n\n\t// remove the value from the index, if the value was the last one, remove the key\n\tremove(key, val) {\n\t\tvar idxSet = this.index[key];\n\t\tfor (var i in idxSet) {\n\t\t\tif (idxSet[i] == val) {\n\t\t\t\tidxSet.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\tif (idxSet.length < 1) {\n\t\t\tthis.index[key] = undefined;\n\t\t}\n\t}\n\n\t// get the values related to the key, could be more than one\n\tget(key) {\n\t\tconsole.log(\"!\");\n\t\treturn this.index[key];\n\t}\n\n\t// clear will zap the index\n\tclear(key) {\n\t\tthis.index = {};\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/exact_index.js\n// module id = 12\n// module chunks = 0","export class UniqueIndex {\n\n\tconstructor(uniqueField) {\n\t\tthis.field = uniqueField;\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t}\n\n\tset(obj) {\n\t\tvar fieldValue = obj[this.field];\n\t\tif (fieldValue !== null && typeof(fieldValue) !== 'undefined') {\n\t\t\tif (this.keyMap[fieldValue]) {\n\t\t\t\tthrow new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n\t\t\t} else {\n\t\t\t\tthis.keyMap[fieldValue] = obj;\n\t\t\t\tthis.lokiMap[obj.$loki] = fieldValue;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\treturn this.keyMap[key];\n\t}\n\n\tbyId(id) {\n\t\treturn this.keyMap[this.lokiMap[id]];\n\t}\n\n\t/**\n\t * Updates a document's unique index given an updated object.\n\t * @param  {Object} obj Original document object\n\t * @param  {Object} doc New document object (likely the same as obj)\n\t */\n\tupdate(obj, doc) {\n\t\tif (this.lokiMap[obj.$loki] !== doc[this.field]) {\n\t\t\tvar old = this.lokiMap[obj.$loki];\n\t\t\tthis.set(doc);\n\t\t\t// make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n\t\t\tthis.keyMap[old] = undefined;\n\t\t} else {\n\t\t\tthis.keyMap[obj[this.field]] = doc;\n\t\t}\n\t}\n\tremove(key) {\n\t\tvar obj = this.keyMap[key];\n\t\tif (obj !== null && typeof obj !== 'undefined') {\n\t\t\tthis.keyMap[key] = undefined;\n\t\t\tthis.lokiMap[obj.$loki] = undefined;\n\t\t} else {\n\t\t\tthrow new Error('Key is not in unique index: ' + this.field);\n\t\t}\n\t}\n\tclear() {\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/unique_index.js\n// module id = 13\n// module chunks = 0"],"sourceRoot":""}