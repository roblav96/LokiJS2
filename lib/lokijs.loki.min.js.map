{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///lokijs.loki.min.js","webpack:///webpack/bootstrap da7d1153d4acd55453c4?9a9d","webpack:///./src/lokijs.js","webpack:///external \"fs\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_14__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","0","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","global","apply","undefined","ltHelper","prop1","prop2","equal","cv1","cv2","toString","gtHelper","sortHelper","desc","compoundeval","properties","obj1","obj2","prop","field","res","i","len","length","dotSubScan","paths","fun","value","poffset","pathOffset","path","hasOwnProperty","valueFound","element","Array","isArray","index","containsCheckFn","a","b","indexOf","doQueryOp","val","op","LokiOps","clone","data","method","cloned","cloneMethod","JSON","parse","stringify","jQuery","extend","Object","create","prototype","keys","map","cloneObjectArray","objarray","result","push","localStorageAvailable","window","localStorage","e","LokiEventEmitter","Loki","filename","options","collections","databaseVersion","engineVersion","autosave","autosaveInterval","autosaveHandle","persistenceMethod","persistenceAdapter","verbose","events","init","flushChanges","close","changes","warning","getENV","document","URL","ENV","env","on","clearChanges","LokiFsAdapter","fs","LokiLocalStorageAdapter","Resultset","collection","queryObj","queryFunc","firstOnly","searchIsChained","filteredrows","filterInitialized","find","where","DynamicView","name","rebuildPending","persistent","sortPriority","minRebuildInterval","resultset","resultdata","resultsdirty","cachedresultset","filterPipeline","sortFunction","sortCriteria","sortDirty","rebuild","Collection","observerCallback","changedObjects","Set","add","object","forEach","change","self","removeAutoUpdateObserver","update","err","createChange","obj","operation","insertMeta","meta","created","Date","getTime","revision","updateMeta","updated","createInsertChange","createUpdateChange","insertMetaWithChange","updateMetaWithChange","setHandlers","insertHandler","disableChangesApi","updateHandler","idIndex","binaryIndices","constraints","unique","exact","uniqueNames","transforms","objType","dirty","cachedIndex","cachedBinaryIndex","cachedData","UniqueIndex","ExactIndex","adaptiveBinaryIndices","transactional","cloneObjects","asyncListeners","autoupdate","ttl","age","ttlInterval","daemon","setTTL","maxId","DynamicViews","insert","pre-insert","pre-update","flushbuffer","error","delete","ensureId","indices","TypeError","idx","ensureIndex","getChanges","setChangesApi","enabled","console","warn","isDeepProperty","parseBase10","num","parseFloat","sub","average","array","reduce","standardDeviation","values","avg","squareDiffs","diff","sqrDiff","avgSquareDiff","stdDev","Math","sqrt","deepProperty","property","isDeep","pieces","split","shift","binarySearch","item","compared","mid","lo","hi","found","BSonSort","KeyValueStore","uniqueField","keyMap","lokiMap","exactField","SortedIndex","sortedField","Utils","copyProperties","src","dest","resolveTransformObject","subObj","params","depth","pname","substring","resolveTransformParams","transform","clonedStep","resolvedTransform","$eq","$aeq","$ne","$dteq","$gt","$gte","$lt","$lte","$in","$nin","$keyin","$nkeyin","$definedin","$undefinedin","$regex","test","$containsString","$containsNone","$containsAny","checkFn","some","$contains","every","$type","type","$size","$len","$where","$not","$and","$or","indexedOpsList","eventName","listener","event","currentEventName","emit","setTimeout","removeListener","listen","listeners","splice","getIndexedAdapter","adapter","Error","code","initializePersistence","defaultPersistence","NODEJS","BROWSER","CORDOVA","persistenceMethods","parseInt","autosaveDisable","autoload","loadDatabase","inflate","Promise","resolve","then","autosaveEnable","anonym","docs","addCollection","loadCollection","getCollection","collectionName","listCollections","colls","count","removeCollection","tmpcol","curcol","getName","serializeReplacer","key","serialize","toJson","loadJSON","serializedDb","dbObject","loadJSONObject","makeLoader","coll","inflater","collOptions","proto","collObj","copyColl","clen","j","loader","addAutoUpdateObserver","ensureUniqueIndex","colldv","dv","addDynamicView","rematerialize","removeWhereFilters","saved","autosaveDirty","saveDatabase","generateChangesNotification","arrayOfCollectionNames","getCollName","selectedCollections","concat","serializeChanges","collectionNamesArray","dbname","reject","stat","stats","isFile","readFile","encoding","dbstring","writeFile","deleteDatabase","callback","unlink","getItem","setItem","removeItem","dbString","mode","exportDatabase","autosaveClearFlags","save","running","reset","toJSON","copy","limit","qty","prepareFullDocIndex","rscopy","slice","offset","pos","branch","parameters","step","rs","simplesort","compoundsort","sort","eqJoin","joinData","leftJoinKey","rightJoinKey","mapFun","mapReduce","mapFunction","reduceFunction","remove","comparefun","wrappedComparer","userComparer","propname","isdesc","props","findOr","expressionArray","fr","fri","frlen","docset","idxset","origCount","ei","elen","findAnd","query","queryObjectOp","operator","queryObject","searchByIndex","chain","RegExp","usingDotNotation","doIndexCheck","t","seg","calculateRange","filter","rowIdx","segm","viewFunction","k","forceClones","forceCloneMethod","updateFunction","rcd","leftDataLength","rightDataLength","leftData","rightData","leftKeyisFunction","rightKeyisFunction","joinMap","left","right","fpl","fpi","ofp","applyFind","branchResultset","removeFilters","applySort","queueSortPhase","applySimpleSort","applySortCriteria","criteria","startTransaction","commit","rollback","_indexOfFilterWithId","uid","_addFilter","reapplyFilters","filters","queueRebuildEvent","applyFilter","applyWhere","removeFilter","performSortPhase","suppressRebuildEvent","evaluateDocument","objIndex","isNew","ofr","oldPos","oldlen","evalResultset","newPos","removeDocument","log","observe","unobserve","addTransform","setTransform","removeTransform","byExample","template","findObject","findOne","findObjects","ttlDaemonFuncGen","now","toRemove","member","timestamp","interval","clearInterval","setInterval","indexes","configureOptions","ensureAllIndexes","force","objAp","objBp","getSequencedIndexValues","idxvals","set","bIndices","flagBinaryIndexesDirty","flagBinaryIndexDirty","$loki","removeDynamicView","getDynamicView","findAndUpdate","filterFunction","results","message","doc","insertOne","bulkInsert","returnObj","clear","oldInternal","newInternal","position","arr","get","adaptiveBinaryIndexUpdate","isNaN","version","constrUnique","addedPos","dvlen","adaptiveBinaryIndexInsert","removeWhere","list","removeDataOnly","adaptiveBinaryIndexRemove","returnPosition","retpos","max","min","getBinaryIndexPosition","dataPosition","binaryIndexName","range","idxPos","calculateRangeStart","removedFromIndexOnly","lbound","minVal","maxVal","ubound","lval","uval","by","findOneUnindexed","leftJoinProp","rightJoinProp","stages","getStage","commitLog","stage","stageName","commitStage","no_op","extract","isDotNotation","maxRecord","deep","minRecord","extractNumerical","Number","n","dict","median","half","floor","setSort","bs","fieldValue","byId","old","idxSet","bsr","getLt","getAll","getGt","start","end","getPos","persistenceAdapters","14"],"mappings":"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","file":"lokijs.loki.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"fs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"loki\", [\"fs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"loki\"] = factory(require(\"fs\"));\n\telse\n\t\troot[\"lokijs\"] = root[\"lokijs\"] || {}, root[\"lokijs\"][\"loki\"] = factory(root[\"fs\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_14__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"fs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"loki\", [\"fs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"loki\"] = factory(require(\"fs\"));\n\telse\n\t\troot[\"lokijs\"] = root[\"lokijs\"] || {}, root[\"lokijs\"][\"loki\"] = factory(root[\"fs\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_14__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\t/**\n\t * LokiJS\n\t * @author Joe Minichino <joe.minichino@gmail.com>\n\t *\n\t * A lightweight document oriented javascript database\n\t */\n\t(function (root, factory) {\n\t  if (true) {\n\t    // AMD\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    // CommonJS\n\t    module.exports = factory();\n\t  } else {\n\t    // Browser globals\n\t    root.loki = factory();\n\t  }\n\t})(undefined, function () {\n\t\n\t  return function () {\n\t    'use strict';\n\t\n\t    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\t\n\t    var Utils = {\n\t      copyProperties: function (src, dest) {\n\t        var prop;\n\t        for (prop in src) {\n\t          dest[prop] = src[prop];\n\t        }\n\t      },\n\t      // used to recursively scan hierarchical transform step object for param substitution\n\t      resolveTransformObject: function (subObj, params, depth) {\n\t        var prop, pname;\n\t\n\t        if (typeof depth !== 'number') {\n\t          depth = 0;\n\t        }\n\t\n\t        if (++depth >= 10) return subObj;\n\t\n\t        for (prop in subObj) {\n\t          if (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n\t            pname = subObj[prop].substring(8);\n\t            if (params.hasOwnProperty(pname)) {\n\t              subObj[prop] = params[pname];\n\t            }\n\t          } else if (typeof subObj[prop] === \"object\") {\n\t            subObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n\t          }\n\t        }\n\t\n\t        return subObj;\n\t      },\n\t      // top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\n\t      resolveTransformParams: function (transform, params) {\n\t        var idx,\n\t            clonedStep,\n\t            resolvedTransform = [];\n\t\n\t        if (typeof params === 'undefined') return transform;\n\t\n\t        // iterate all steps in the transform array\n\t        for (idx = 0; idx < transform.length; idx++) {\n\t          // clone transform so our scan and replace can operate directly on cloned transform\n\t          clonedStep = JSON.parse(JSON.stringify(transform[idx]));\n\t          resolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));\n\t        }\n\t\n\t        return resolvedTransform;\n\t      }\n\t    };\n\t\n\t    /** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n\t     *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n\t     *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n\t     *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n\t     */\n\t    function ltHelper(prop1, prop2, equal) {\n\t      var cv1, cv2;\n\t\n\t      // 'falsy' and Boolean handling\n\t      if (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t        if ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t          if (equal) {\n\t            return prop1 === prop2;\n\t          } else {\n\t            if (prop1) {\n\t              return false;\n\t            } else {\n\t              return prop2;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t          return equal;\n\t        }\n\t        if (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t          return true;\n\t        }\n\t      }\n\t\n\t      if (prop1 === prop2) {\n\t        return equal;\n\t      }\n\t\n\t      if (prop1 < prop2) {\n\t        return true;\n\t      }\n\t\n\t      if (prop1 > prop2) {\n\t        return false;\n\t      }\n\t\n\t      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\t      cv1 = prop1.toString();\n\t      cv2 = prop2.toString();\n\t\n\t      if (cv1 == cv2) {\n\t        return equal;\n\t      }\n\t\n\t      if (cv1 < cv2) {\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    }\n\t\n\t    function gtHelper(prop1, prop2, equal) {\n\t      var cv1, cv2;\n\t\n\t      // 'falsy' and Boolean handling\n\t      if (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t        if ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t          if (equal) {\n\t            return prop1 === prop2;\n\t          } else {\n\t            if (prop1) {\n\t              return !prop2;\n\t            } else {\n\t              return false;\n\t            }\n\t          }\n\t        }\n\t\n\t        if (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t          return equal;\n\t        }\n\t        if (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t          return true;\n\t        }\n\t      }\n\t\n\t      if (prop1 === prop2) {\n\t        return equal;\n\t      }\n\t\n\t      if (prop1 > prop2) {\n\t        return true;\n\t      }\n\t\n\t      if (prop1 < prop2) {\n\t        return false;\n\t      }\n\t\n\t      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\t      cv1 = prop1.toString();\n\t      cv2 = prop2.toString();\n\t\n\t      if (cv1 == cv2) {\n\t        return equal;\n\t      }\n\t\n\t      if (cv1 > cv2) {\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    }\n\t\n\t    function sortHelper(prop1, prop2, desc) {\n\t      if (prop1 === prop2) {\n\t        return 0;\n\t      }\n\t\n\t      if (ltHelper(prop1, prop2, false)) {\n\t        return desc ? 1 : -1;\n\t      }\n\t\n\t      if (gtHelper(prop1, prop2, false)) {\n\t        return desc ? -1 : 1;\n\t      }\n\t\n\t      // not lt, not gt so implied equality-- date compatible\n\t      return 0;\n\t    }\n\t\n\t    /**\n\t     * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n\t     *\n\t     * @param {array} properties - array of property names, in order, by which to evaluate sort order\n\t     * @param {object} obj1 - first object to compare\n\t     * @param {object} obj2 - second object to compare\n\t     * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n\t     */\n\t    function compoundeval(properties, obj1, obj2) {\n\t      var res = 0;\n\t      var prop, field;\n\t      for (var i = 0, len = properties.length; i < len; i++) {\n\t        prop = properties[i];\n\t        field = prop[0];\n\t        res = sortHelper(obj1[field], obj2[field], prop[1]);\n\t        if (res !== 0) {\n\t          return res;\n\t        }\n\t      }\n\t      return 0;\n\t    }\n\t\n\t    /**\n\t     * dotSubScan - helper function used for dot notation queries.\n\t     *\n\t     * @param {object} root - object to traverse\n\t     * @param {array} paths - array of properties to drill into\n\t     * @param {function} fun - evaluation function to test with\n\t     * @param {any} value - comparative value to also pass to (compare) fun\n\t     * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n\t     */\n\t    function dotSubScan(root, paths, fun, value, poffset) {\n\t      var pathOffset = poffset || 0;\n\t      var path = paths[pathOffset];\n\t      if (root === undefined || root === null || !hasOwnProperty.call(root, path)) {\n\t        return false;\n\t      }\n\t\n\t      var valueFound = false;\n\t      var element = root[path];\n\t      if (pathOffset + 1 >= paths.length) {\n\t        // if we have already expanded out the dot notation,\n\t        // then just evaluate the test function and value on the element\n\t        valueFound = fun(element, value);\n\t      } else if (Array.isArray(element)) {\n\t        for (var index = 0, len = element.length; index < len; index += 1) {\n\t          valueFound = dotSubScan(element[index], paths, fun, value, pathOffset + 1);\n\t          if (valueFound === true) {\n\t            break;\n\t          }\n\t        }\n\t      } else {\n\t        valueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);\n\t      }\n\t\n\t      return valueFound;\n\t    }\n\t\n\t    function containsCheckFn(a) {\n\t      if (typeof a === 'string' || Array.isArray(a)) {\n\t        return function (b) {\n\t          return a.indexOf(b) !== -1;\n\t        };\n\t      } else if (typeof a === 'object' && a !== null) {\n\t        return function (b) {\n\t          return hasOwnProperty.call(a, b);\n\t        };\n\t      }\n\t      return null;\n\t    }\n\t\n\t    function doQueryOp(val, op) {\n\t      for (var p in op) {\n\t        if (hasOwnProperty.call(op, p)) {\n\t          return LokiOps[p](val, op[p]);\n\t        }\n\t      }\n\t      return false;\n\t    }\n\t\n\t    var LokiOps = {\n\t      // comparison operators\n\t      // a is the value in the collection\n\t      // b is the query value\n\t      $eq: function (a, b) {\n\t        return a === b;\n\t      },\n\t\n\t      // abstract/loose equality\n\t      $aeq: function (a, b) {\n\t        return a == b;\n\t      },\n\t\n\t      $ne: function (a, b) {\n\t        // ecma 5 safe test for NaN\n\t        if (b !== b) {\n\t          // ecma 5 test value is not NaN\n\t          return a === a;\n\t        }\n\t\n\t        return a !== b;\n\t      },\n\t\n\t      $dteq: function (a, b) {\n\t        if (ltHelper(a, b, false)) {\n\t          return false;\n\t        }\n\t        return !gtHelper(a, b, false);\n\t      },\n\t\n\t      $gt: function (a, b) {\n\t        return gtHelper(a, b, false);\n\t      },\n\t\n\t      $gte: function (a, b) {\n\t        return gtHelper(a, b, true);\n\t      },\n\t\n\t      $lt: function (a, b) {\n\t        return ltHelper(a, b, false);\n\t      },\n\t\n\t      $lte: function (a, b) {\n\t        return ltHelper(a, b, true);\n\t      },\n\t\n\t      $in: function (a, b) {\n\t        return b.indexOf(a) !== -1;\n\t      },\n\t\n\t      $nin: function (a, b) {\n\t        return b.indexOf(a) === -1;\n\t      },\n\t\n\t      $keyin: function (a, b) {\n\t        return a in b;\n\t      },\n\t\n\t      $nkeyin: function (a, b) {\n\t        return !(a in b);\n\t      },\n\t\n\t      $definedin: function (a, b) {\n\t        return b[a] !== undefined;\n\t      },\n\t\n\t      $undefinedin: function (a, b) {\n\t        return b[a] === undefined;\n\t      },\n\t\n\t      $regex: function (a, b) {\n\t        return b.test(a);\n\t      },\n\t\n\t      $containsString: function (a, b) {\n\t        return typeof a === 'string' && a.indexOf(b) !== -1;\n\t      },\n\t\n\t      $containsNone: function (a, b) {\n\t        return !LokiOps.$containsAny(a, b);\n\t      },\n\t\n\t      $containsAny: function (a, b) {\n\t        var checkFn = containsCheckFn(a);\n\t        if (checkFn !== null) {\n\t          return Array.isArray(b) ? b.some(checkFn) : checkFn(b);\n\t        }\n\t        return false;\n\t      },\n\t\n\t      $contains: function (a, b) {\n\t        var checkFn = containsCheckFn(a);\n\t        if (checkFn !== null) {\n\t          return Array.isArray(b) ? b.every(checkFn) : checkFn(b);\n\t        }\n\t        return false;\n\t      },\n\t\n\t      $type: function (a, b) {\n\t        var type = typeof a;\n\t        if (type === 'object') {\n\t          if (Array.isArray(a)) {\n\t            type = 'array';\n\t          } else if (a instanceof Date) {\n\t            type = 'date';\n\t          }\n\t        }\n\t        return typeof b !== 'object' ? type === b : doQueryOp(type, b);\n\t      },\n\t\n\t      $size: function (a, b) {\n\t        if (Array.isArray(a)) {\n\t          return typeof b !== 'object' ? a.length === b : doQueryOp(a.length, b);\n\t        }\n\t        return false;\n\t      },\n\t\n\t      $len: function (a, b) {\n\t        if (typeof a === 'string') {\n\t          return typeof b !== 'object' ? a.length === b : doQueryOp(a.length, b);\n\t        }\n\t        return false;\n\t      },\n\t\n\t      $where: function (a, b) {\n\t        return b(a) === true;\n\t      },\n\t\n\t      // field-level logical operators\n\t      // a is the value in the collection\n\t      // b is the nested query operation (for '$not')\n\t      //   or an array of nested query operations (for '$and' and '$or')\n\t      $not: function (a, b) {\n\t        return !doQueryOp(a, b);\n\t      },\n\t\n\t      $and: function (a, b) {\n\t        for (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t          if (!doQueryOp(a, b[idx])) {\n\t            return false;\n\t          }\n\t        }\n\t        return true;\n\t      },\n\t\n\t      $or: function (a, b) {\n\t        for (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t          if (doQueryOp(a, b[idx])) {\n\t            return true;\n\t          }\n\t        }\n\t        return false;\n\t      }\n\t    };\n\t\n\t    // making indexing opt-in... our range function knows how to deal with these ops :\n\t    var indexedOpsList = ['$eq', '$aeq', '$dteq', '$gt', '$gte', '$lt', '$lte'];\n\t\n\t    function clone(data, method) {\n\t      var cloneMethod = method || 'parse-stringify',\n\t          cloned;\n\t\n\t      switch (cloneMethod) {\n\t        case \"parse-stringify\":\n\t          cloned = JSON.parse(JSON.stringify(data));\n\t          break;\n\t        case \"jquery-extend-deep\":\n\t          cloned = jQuery.extend(true, {}, data);\n\t          break;\n\t        case \"shallow\":\n\t          cloned = Object.create(data.prototype || null);\n\t          Object.keys(data).map(function (i) {\n\t            cloned[i] = data[i];\n\t          });\n\t          break;\n\t        default:\n\t          break;\n\t      }\n\t\n\t      //if (cloneMethod === 'parse-stringify') {\n\t      //  cloned = JSON.parse(JSON.stringify(data));\n\t      //}\n\t      return cloned;\n\t    }\n\t\n\t    function cloneObjectArray(objarray, method) {\n\t      var i,\n\t          result = [];\n\t\n\t      if (method == \"parse-stringify\") {\n\t        return clone(objarray, method);\n\t      }\n\t\n\t      i = objarray.length - 1;\n\t\n\t      for (; i <= 0; i--) {\n\t        result.push(clone(objarray[i], method));\n\t      }\n\t\n\t      return result;\n\t    }\n\t\n\t    function localStorageAvailable() {\n\t      try {\n\t        return window && window.localStorage !== undefined && window.localStorage !== null;\n\t      } catch (e) {\n\t        return false;\n\t      }\n\t    }\n\t\n\t    /**\n\t     * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n\t     * constructor that inherits EventEmitter to emit events and trigger\n\t     * listeners that have been added to the event through the on(event, callback) method\n\t     *\n\t     * @constructor LokiEventEmitter\n\t     */\n\t    function LokiEventEmitter() {}\n\t\n\t    /**\n\t     * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n\t     * @memberof LokiEventEmitter\n\t     */\n\t    LokiEventEmitter.prototype.events = {};\n\t\n\t    /**\n\t     * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n\t     * should happen in an async fashion or not\n\t     * Default is false, which means events are synchronous\n\t     * @memberof LokiEventEmitter\n\t     */\n\t    LokiEventEmitter.prototype.asyncListeners = false;\n\t\n\t    /**\n\t     * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t     * @param {function} listener - callback function of listener to attach\n\t     * @returns {int} the index of the callback in the array of listeners for a particular event\n\t     * @memberof LokiEventEmitter\n\t     */\n\t    LokiEventEmitter.prototype.on = function (eventName, listener) {\n\t      var event;\n\t      var self = this;\n\t\n\t      if (Array.isArray(eventName)) {\n\t        eventName.forEach(function (currentEventName) {\n\t          self.on(currentEventName, listener);\n\t        });\n\t        return listener;\n\t      }\n\t\n\t      event = this.events[eventName];\n\t      if (!event) {\n\t        event = this.events[eventName] = [];\n\t      }\n\t      event.push(listener);\n\t      return listener;\n\t    };\n\t\n\t    /**\n\t     * emit(eventName, data) - emits a particular event\n\t     * with the option of passing optional parameters which are going to be processed by the callback\n\t     * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n\t     * @param {string} eventName - the name of the event\n\t     * @param {object=} data - optional object passed with the event\n\t     * @memberof LokiEventEmitter\n\t     */\n\t    LokiEventEmitter.prototype.emit = function (eventName, data) {\n\t      var self = this;\n\t      if (eventName && this.events[eventName]) {\n\t        this.events[eventName].forEach(function (listener) {\n\t          if (self.asyncListeners) {\n\t            setTimeout(function () {\n\t              listener(data);\n\t            }, 1);\n\t          } else {\n\t            listener(data);\n\t          }\n\t        });\n\t      }\n\t    };\n\t\n\t    /**\n\t     * removeListener() - removes the listener at position 'index' from the event 'eventName'\n\t     * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n\t     * @param {function} listener - the listener callback function to remove from emitter\n\t     * @memberof LokiEventEmitter\n\t     */\n\t    LokiEventEmitter.prototype.removeListener = function (eventName, listener) {\n\t      var self = this;\n\t      if (Array.isArray(eventName)) {\n\t        eventName.forEach(function (currentEventName) {\n\t          self.removeListener(currentEventName, listen);\n\t        });\n\t      }\n\t\n\t      if (this.events[eventName]) {\n\t        var listeners = this.events[eventName];\n\t        listeners.splice(listeners.indexOf(listener), 1);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Loki: The main database class\n\t     * @constructor Loki\n\t     * @implements LokiEventEmitter\n\t     * @param {string} filename - name of the file to be saved to\n\t     * @param {object=} options - (Optional) config options object\n\t     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n\t     * @param {boolean} options.verbose - enable console output (default is 'false')\n\t     */\n\t    function Loki(filename, options) {\n\t      this.filename = filename || 'loki.db';\n\t      this.collections = [];\n\t\n\t      // persist version of code which created the database to the database.\n\t      // could use for upgrade scenarios\n\t      this.databaseVersion = 1.1;\n\t      this.engineVersion = 1.1;\n\t\n\t      // autosave support (disabled by default)\n\t      // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n\t      this.autosave = false;\n\t      this.autosaveInterval = 5000;\n\t      this.autosaveHandle = null;\n\t\n\t      this.options = {};\n\t\n\t      // currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n\t      // will not or cannot be deserialized.  You are required to configure persistence every time\n\t      // you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\t\n\t      // persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n\t      // this is optional option param, otherwise environment detection will be used\n\t      // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n\t      this.persistenceMethod = null;\n\t\n\t      // retain reference to optional (non-serializable) persistenceAdapter 'instance'\n\t      this.persistenceAdapter = null;\n\t\n\t      // enable console output if verbose flag is set (disabled by default)\n\t      this.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;\n\t\n\t      this.events = {\n\t        'init': [],\n\t        'loaded': [],\n\t        'flushChanges': [],\n\t        'close': [],\n\t        'changes': [],\n\t        'warning': []\n\t      };\n\t\n\t      var getENV = function () {\n\t        if (typeof window === 'undefined') {\n\t          return 'NODEJS';\n\t        }\n\t\n\t        if (typeof global !== 'undefined' && global.window) {\n\t          return 'NODEJS'; //node-webkit\n\t        }\n\t\n\t        if (typeof document !== 'undefined') {\n\t          if (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n\t            return 'CORDOVA';\n\t          }\n\t          return 'BROWSER';\n\t        }\n\t        return 'CORDOVA';\n\t      };\n\t\n\t      // refactored environment detection due to invalid detection for browser environments.\n\t      // if they do not specify an options.env we want to detect env rather than default to nodejs.\n\t      // currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n\t      //   might want to review whether we can consolidate.\n\t      if (options && options.hasOwnProperty('env')) {\n\t        this.ENV = options.env;\n\t      } else {\n\t        this.ENV = getENV();\n\t      }\n\t\n\t      this.on('init', this.clearChanges);\n\t    }\n\t\n\t    // db class is an EventEmitter\n\t    Loki.prototype = new LokiEventEmitter();\n\t\n\t    // experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n\t    // Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n\t    Loki.prototype.getIndexedAdapter = function () {\n\t      var adapter;\n\t\n\t      if (true) {\n\t        adapter = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"./loki-indexed-adapter.js\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n\t      }\n\t\n\t      return adapter;\n\t    };\n\t\n\t    /**\n\t     * configures options related to database persistence.\n\t     *\n\t     * @param {object} options - configuration options to apply to loki db object\n\t     * @param {adapter} options.adapter - an instance of a loki persistence adapter\n\t     * @param {boolean} options.autosave - enables autosave\n\t     * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n\t     * @param {boolean} options.autoload - enables autoload on loki instantiation\n\t     * @param {object} options.inflate - options that are passed to loadDatabase if autoload enabled\n\t     * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.initializePersistence = function (options) {\n\t      var self = this;\n\t      var defaultPersistence = {\n\t        'NODEJS': 'fs',\n\t        'BROWSER': 'localStorage',\n\t        'CORDOVA': 'localStorage'\n\t      },\n\t          persistenceMethods = {\n\t        'fs': LokiFsAdapter,\n\t        'localStorage': LokiLocalStorageAdapter\n\t      };\n\t\n\t      this.options = options || {};\n\t\n\t      this.persistenceMethod = null;\n\t      // retain reference to optional persistence adapter 'instance'\n\t      // currently keeping outside options because it can't be serialized\n\t      this.persistenceAdapter = null;\n\t\n\t      // process the options\n\t      if (this.options.hasOwnProperty('persistenceMethod')) {\n\t        // check if the specified persistence method is known\n\t        if (typeof persistenceMethods[this.options.persistenceMethod] === 'function') {\n\t          this.persistenceMethod = this.options.persistenceMethod;\n\t          this.persistenceAdapter = new persistenceMethods[this.options.persistenceMethod]();\n\t        }\n\t        // should be throw an error here, or just fall back to defaults ??\n\t      }\n\t\n\t      // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n\t      if (this.persistenceAdapter === null) {\n\t        this.persistenceMethod = defaultPersistence[this.ENV];\n\t        if (this.persistenceMethod) {\n\t          this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n\t        }\n\t      }\n\t\n\t      // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n\t      if (this.options.hasOwnProperty('adapter')) {\n\t        this.persistenceMethod = 'adapter';\n\t        this.persistenceAdapter = this.options.adapter;\n\t      }\n\t\n\t      if (this.options.hasOwnProperty('autosaveInterval')) {\n\t        this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n\t      }\n\t\n\t      this.autosaveDisable();\n\t\n\t      var loaded;\n\t\n\t      // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n\t      if (this.options.autoload) {\n\t        loaded = this.loadDatabase(this.options.inflate);\n\t      } else {\n\t        loaded = Promise.resolve();\n\t      }\n\t\n\t      return loaded.then(function () {\n\t        if (self.options.autosave) {\n\t          self.autosaveEnable();\n\t        }\n\t      });\n\t    };\n\t\n\t    /**\n\t     * Shorthand method for quickly creating and populating an anonymous collection.\n\t     *    This collection is not referenced internally so upon losing scope it will be garbage collected.\n\t     *\n\t     * @example\n\t     * var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });\n\t     *\n\t     * @param {Array} docs - document array to initialize the anonymous collection with\n\t     * @param {object} options - configuration object, see {@link Loki#addCollection} options\n\t     * @returns {Collection} New collection which you can query or chain\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.anonym = function (docs, options) {\n\t      var collection = new Collection('anonym', options);\n\t      collection.insert(docs);\n\t\n\t      if (this.verbose) collection.console = console;\n\t\n\t      return collection;\n\t    };\n\t\n\t    /**\n\t     * Adds a collection to the database.\n\t     * @param {string} name - name of collection to add\n\t     * @param {object=} options - (optional) options to configure collection with.\n\t     * @param {array} options.unique - array of property names to define unique constraints for\n\t     * @param {array} options.exact - array of property names to define exact constraints for\n\t     * @param {array} options.indices - array property names to define binary indexes for\n\t     * @param {boolean} options.asyncListeners - default is false\n\t     * @param {boolean} options.disableChangesApi - default is true\n\t     * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n\t     * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n\t     * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n\t     * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n\t     * @returns {Collection} a reference to the collection which was just added\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.addCollection = function (name, options) {\n\t      var collection = new Collection(name, options);\n\t      this.collections.push(collection);\n\t\n\t      if (this.verbose) collection.console = console;\n\t\n\t      return collection;\n\t    };\n\t\n\t    Loki.prototype.loadCollection = function (collection) {\n\t      if (!collection.name) {\n\t        throw new Error('Collection must have a name property to be loaded');\n\t      }\n\t      this.collections.push(collection);\n\t    };\n\t\n\t    /**\n\t     * Retrieves reference to a collection by name.\n\t     * @param {string} collectionName - name of collection to look up\n\t     * @returns {Collection} Reference to collection in database by that name, or null if not found\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.getCollection = function (collectionName) {\n\t      var i,\n\t          len = this.collections.length;\n\t\n\t      for (i = 0; i < len; i += 1) {\n\t        if (this.collections[i].name === collectionName) {\n\t          return this.collections[i];\n\t        }\n\t      }\n\t\n\t      // no such collection\n\t      this.emit('warning', 'collection ' + collectionName + ' not found');\n\t      return null;\n\t    };\n\t\n\t    Loki.prototype.listCollections = function () {\n\t\n\t      var i = this.collections.length,\n\t          colls = [];\n\t\n\t      while (i--) {\n\t        colls.push({\n\t          name: this.collections[i].name,\n\t          type: this.collections[i].objType,\n\t          count: this.collections[i].data.length\n\t        });\n\t      }\n\t      return colls;\n\t    };\n\t\n\t    /**\n\t     * Removes a collection from the database.\n\t     * @param {string} collectionName - name of collection to remove\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.removeCollection = function (collectionName) {\n\t      var i,\n\t          len = this.collections.length;\n\t\n\t      for (i = 0; i < len; i += 1) {\n\t        if (this.collections[i].name === collectionName) {\n\t          var tmpcol = new Collection(collectionName, {});\n\t          var curcol = this.collections[i];\n\t          for (var prop in curcol) {\n\t            if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n\t              curcol[prop] = tmpcol[prop];\n\t            }\n\t          }\n\t          this.collections.splice(i, 1);\n\t          return;\n\t        }\n\t      }\n\t    };\n\t\n\t    Loki.prototype.getName = function () {\n\t      return this.name;\n\t    };\n\t\n\t    /**\n\t     * serializeReplacer - used to prevent certain properties from being serialized\n\t     *\n\t     */\n\t    Loki.prototype.serializeReplacer = function (key, value) {\n\t      switch (key) {\n\t        case 'autosaveHandle':\n\t        case 'persistenceAdapter':\n\t        case 'constraints':\n\t        case 'ttl':\n\t          return null;\n\t        default:\n\t          return value;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n\t     *\n\t     * @returns {string} Stringified representation of the loki database.\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.serialize = function () {\n\t      return JSON.stringify(this, this.serializeReplacer, 2);\n\t    };\n\t    // alias of serialize\n\t    Loki.prototype.toJson = Loki.prototype.serialize;\n\t\n\t    /**\n\t     * Inflates a loki database from a serialized JSON string\n\t     *\n\t     * @param {string} serializedDb - a serialized loki database string\n\t     * @param {object} options - apply or override collection level settings\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.loadJSON = function (serializedDb, options) {\n\t      var dbObject;\n\t      if (serializedDb.length === 0) {\n\t        dbObject = {};\n\t      } else {\n\t        dbObject = JSON.parse(serializedDb);\n\t      }\n\t\n\t      this.loadJSONObject(dbObject, options);\n\t    };\n\t\n\t    /**\n\t     * Inflates a loki database from a JS object\n\t     *\n\t     * @param {object} dbObject - a serialized loki database string\n\t     * @param {object} options - apply or override collection level settings\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.loadJSONObject = function (dbObject, options) {\n\t      var i = 0,\n\t          len = dbObject.collections ? dbObject.collections.length : 0,\n\t          coll,\n\t          copyColl,\n\t          clen,\n\t          j,\n\t          loader,\n\t          collObj;\n\t\n\t      this.name = dbObject.name;\n\t\n\t      // restore database version\n\t      this.databaseVersion = 1.0;\n\t      if (dbObject.hasOwnProperty('databaseVersion')) {\n\t        this.databaseVersion = dbObject.databaseVersion;\n\t      }\n\t\n\t      this.collections = [];\n\t\n\t      function makeLoader(coll) {\n\t        var collOptions = options[coll.name];\n\t        var inflater;\n\t\n\t        if (collOptions.proto) {\n\t          inflater = collOptions.inflate || Utils.copyProperties;\n\t\n\t          return function (data) {\n\t            var collObj = new collOptions.proto();\n\t            inflater(data, collObj);\n\t            return collObj;\n\t          };\n\t        }\n\t\n\t        return collOptions.inflate;\n\t      }\n\t\n\t      for (i; i < len; i += 1) {\n\t        coll = dbObject.collections[i];\n\t        copyColl = this.addCollection(coll.name);\n\t\n\t        copyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? coll.adaptiveBinaryIndices === true : false;\n\t        copyColl.transactional = coll.transactional;\n\t        copyColl.asyncListeners = coll.asyncListeners;\n\t        copyColl.disableChangesApi = coll.disableChangesApi;\n\t        copyColl.cloneObjects = coll.cloneObjects;\n\t        copyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n\t        copyColl.autoupdate = coll.autoupdate;\n\t\n\t        // load each element individually\n\t        clen = coll.data.length;\n\t        j = 0;\n\t        if (options && options.hasOwnProperty(coll.name)) {\n\t          loader = makeLoader(coll);\n\t\n\t          for (j; j < clen; j++) {\n\t            collObj = loader(coll.data[j]);\n\t            copyColl.data[j] = collObj;\n\t            copyColl.addAutoUpdateObserver(collObj);\n\t          }\n\t        } else {\n\t\n\t          for (j; j < clen; j++) {\n\t            copyColl.data[j] = coll.data[j];\n\t            copyColl.addAutoUpdateObserver(copyColl.data[j]);\n\t          }\n\t        }\n\t\n\t        copyColl.maxId = coll.data.length === 0 ? 0 : coll.maxId;\n\t        copyColl.idIndex = coll.idIndex;\n\t        if (typeof coll.binaryIndices !== 'undefined') {\n\t          copyColl.binaryIndices = coll.binaryIndices;\n\t        }\n\t        if (typeof coll.transforms !== 'undefined') {\n\t          copyColl.transforms = coll.transforms;\n\t        }\n\t\n\t        copyColl.ensureId();\n\t\n\t        // regenerate unique indexes\n\t        copyColl.uniqueNames = [];\n\t        if (coll.hasOwnProperty(\"uniqueNames\")) {\n\t          copyColl.uniqueNames = coll.uniqueNames;\n\t          for (j = 0; j < copyColl.uniqueNames.length; j++) {\n\t            copyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);\n\t          }\n\t        }\n\t\n\t        // in case they are loading a database created before we added dynamic views, handle undefined\n\t        if (typeof coll.DynamicViews === 'undefined') continue;\n\t\n\t        // reinflate DynamicViews and attached Resultsets\n\t        for (var idx = 0; idx < coll.DynamicViews.length; idx++) {\n\t          var colldv = coll.DynamicViews[idx];\n\t\n\t          var dv = copyColl.addDynamicView(colldv.name, colldv.options);\n\t          dv.resultdata = colldv.resultdata;\n\t          dv.resultsdirty = colldv.resultsdirty;\n\t          dv.filterPipeline = colldv.filterPipeline;\n\t\n\t          dv.sortCriteria = colldv.sortCriteria;\n\t          dv.sortFunction = null;\n\t\n\t          dv.sortDirty = colldv.sortDirty;\n\t          dv.resultset.filteredrows = colldv.resultset.filteredrows;\n\t          dv.resultset.searchIsChained = colldv.resultset.searchIsChained;\n\t          dv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\t\n\t          dv.rematerialize({\n\t            removeWhereFilters: true\n\t          });\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n\t     * Does not actually destroy the db.\n\t     *\n\t     * @returns {Promise} a Promise that resolves after closing the database succeeded\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.close = function () {\n\t      var self = this;\n\t      var saved;\n\t\n\t      // for autosave scenarios, we will let close perform final save (if dirty)\n\t      // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n\t      if (this.autosave) {\n\t        this.autosaveDisable();\n\t        if (this.autosaveDirty()) {\n\t          saved = this.saveDatabase();\n\t        }\n\t      }\n\t\n\t      if (!saved) {\n\t        saved = Promise.resolve();\n\t      }\n\t\n\t      return saved.then(function () {\n\t        self.emit('close');\n\t      });\n\t    };\n\t\n\t    /**-------------------------+\n\t    | Changes API               |\n\t    +--------------------------*/\n\t\n\t    /**\n\t     * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n\t     * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n\t     */\n\t\n\t    /**\n\t     * (Changes API) : takes all the changes stored in each\n\t     * collection and creates a single array for the entire database. If an array of names\n\t     * of collections is passed then only the included collections will be tracked.\n\t     *\n\t     * @param {array=} optional array of collection names. No arg means all collections are processed.\n\t     * @returns {array} array of changes\n\t     * @see private method createChange() in Collection\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.generateChangesNotification = function (arrayOfCollectionNames) {\n\t      function getCollName(coll) {\n\t        return coll.name;\n\t      }\n\t      var changes = [],\n\t          selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\t\n\t      this.collections.forEach(function (coll) {\n\t        if (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n\t          changes = changes.concat(coll.getChanges());\n\t        }\n\t      });\n\t      return changes;\n\t    };\n\t\n\t    /**\n\t     * (Changes API) - stringify changes for network transmission\n\t     * @returns {string} string representation of the changes\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.serializeChanges = function (collectionNamesArray) {\n\t      return JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n\t    };\n\t\n\t    /**\n\t     * (Changes API) : clears all the changes in all collections.\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.clearChanges = function () {\n\t      this.collections.forEach(function (coll) {\n\t        if (coll.flushChanges) {\n\t          coll.flushChanges();\n\t        }\n\t      });\n\t    };\n\t\n\t    /*------------------+\n\t    | PERSISTENCE       |\n\t    -------------------*/\n\t\n\t    /** there are two build in persistence adapters for internal use\n\t     * fs             for use in Nodejs type environments\n\t     * localStorage   for use in browser environment\n\t     * defined as helper classes here so its easy and clean to use\n\t     */\n\t\n\t    /**\n\t     * A loki persistence adapter which persists using node fs module\n\t     * @constructor LokiFsAdapter\n\t     */\n\t    function LokiFsAdapter() {\n\t      this.fs = __webpack_require__(14);\n\t    }\n\t\n\t    /**\n\t     * loadDatabase() - Load data from file, will throw an error if the file does not exist\n\t     * @param {string} dbname - the filename of the database to load\n\t     * @returns {Promise} a Promise that resolves after the database was loaded\n\t     * @memberof LokiFsAdapter\n\t     */\n\t    LokiFsAdapter.prototype.loadDatabase = function loadDatabase(dbname) {\n\t      var self = this;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        self.fs.stat(dbname, function (err, stats) {\n\t          if (!err && stats.isFile()) {\n\t            self.fs.readFile(dbname, {\n\t              encoding: 'utf8'\n\t            }, function readFileCallback(err, data) {\n\t              if (err) {\n\t                reject(err);\n\t              } else {\n\t                resolve(data);\n\t              }\n\t            });\n\t          } else {\n\t            reject();\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    /**\n\t     * saveDatabase() - save data to file, will throw an error if the file can't be saved\n\t     * might want to expand this to avoid dataloss on partial save\n\t     * @param {string} dbname - the filename of the database to load\n\t     * @returns {Promise} a Promise that resolves after the database was persisted\n\t     * @memberof LokiFsAdapter\n\t     */\n\t    LokiFsAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring) {\n\t      var self = this;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        self.fs.writeFile(dbname, dbstring, function (err) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            resolve();\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    /**\n\t     * deleteDatabase() - delete the database file, will throw an error if the\n\t     * file can't be deleted\n\t     * @param {string} dbname - the filename of the database to delete\n\t     * @returns {Promise} a Promise that resolves after the database was deleted\n\t     * @memberof LokiFsAdapter\n\t     */\n\t    LokiFsAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {\n\t      var self = this;\n\t\n\t      return new Promise(function (resolve, reject) {\n\t        self.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            resolve();\n\t          }\n\t        });\n\t      });\n\t    };\n\t\n\t    /**\n\t     * A loki persistence adapter which persists to web browser's local storage object\n\t     * @constructor LokiLocalStorageAdapter\n\t     */\n\t    function LokiLocalStorageAdapter() {}\n\t\n\t    /**\n\t     * loadDatabase() - Load data from localstorage\n\t     * @param {string} dbname - the name of the database to load\n\t     * @returns {Promise} a Promise that resolves after the database was loaded\n\t     * @memberof LokiLocalStorageAdapter\n\t     */\n\t    LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(dbname) {\n\t      if (localStorageAvailable()) {\n\t        return Promise.resolve(localStorage.getItem(dbname));\n\t      }\n\t\n\t      return Promise.reject(new Error('localStorage is not available'));\n\t    };\n\t\n\t    /**\n\t     * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n\t     * might want to expand this to avoid dataloss on partial save\n\t     * @param {string} dbname - the filename of the database to load\n\t     * @returns {Promise} a Promise that resolves after the database was saved\n\t     * @memberof LokiLocalStorageAdapter\n\t     */\n\t    LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring) {\n\t      if (localStorageAvailable()) {\n\t        localStorage.setItem(dbname, dbstring);\n\t\n\t        return Promise.resolve();\n\t      }\n\t\n\t      return Promise.reject(new Error('localStorage is not available'));\n\t    };\n\t\n\t    /**\n\t     * deleteDatabase() - delete the database from localstorage, will throw an error if it\n\t     * can't be deleted\n\t     * @param {string} dbname - the filename of the database to delete\n\t     * @returns {Promise} a Promise that resolves after the database was deleted\n\t     * @memberof LokiLocalStorageAdapter\n\t     */\n\t    LokiLocalStorageAdapter.prototype.deleteDatabase = function deleteDatabase(dbname) {\n\t      if (localStorageAvailable()) {\n\t        localStorage.removeItem(dbname);\n\t\n\t        return Promise.resolve();\n\t      }\n\t\n\t      return Promise.reject(new Error('localStorage is not available'));\n\t    };\n\t\n\t    /**\n\t     * Handles loading from file system, local storage, or adapter (indexeddb).\n\t     *\n\t     * @param {object} options - an object containing inflation options for each collection\n\t     * @returns {Promise} a Promise that resolves after the database is loaded\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.loadDatabase = function (options) {\n\t      var self = this;\n\t\n\t      // the persistenceAdapter should be present if all is ok, but check to be sure.\n\t      if (this.persistenceAdapter === null) {\n\t        return Promise.reject(new Error('persistenceAdapter not configured'));\n\t      }\n\t\n\t      return this.persistenceAdapter.loadDatabase(this.filename).then(function loadDatabaseCallback(dbString) {\n\t        if (typeof dbString === 'string') {\n\t          self.loadJSON(dbString, options || {});\n\t          self.emit('load', self);\n\t        } else {\n\t          // if adapter has returned an js object (other than null or error) attempt to load from JSON object\n\t          if (typeof dbString === \"object\" && dbString !== null && !(dbString instanceof Error)) {\n\t            self.loadJSONObject(dbString, options || {});\n\t            self.emit('load', self);\n\t          } else {\n\t            if (dbString instanceof Error) throw dbString;\n\t\n\t            throw new TypeError('The persistence adapter did not load a serialized DB string or object.');\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t    /**\n\t     * Handles saving to file system, local storage, or adapter (indexeddb)\n\t     *\n\t     * @memberof Loki\n\t     * @returns {Promise} a Promise that resolves after the database is persisted\n\t     */\n\t    Loki.prototype.saveDatabase = function () {\n\t      var self = this;\n\t\n\t      // the persistenceAdapter should be present if all is ok, but check to be sure.\n\t      if (this.persistenceAdapter === null) {\n\t        return Promise.reject(new Error('persistenceAdapter not configured'));\n\t      }\n\t\n\t      var saved;\n\t\n\t      // check if the adapter is requesting (and supports) a 'reference' mode export\n\t      if (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n\t        // filename may seem redundant but loadDatabase will need to expect this same filename\n\t        saved = this.persistenceAdapter.exportDatabase(this.filename, this);\n\t      }\n\t      // otherwise just pass the serialized database to adapter\n\t      else {\n\t          saved = this.persistenceAdapter.saveDatabase(this.filename, self.serialize());\n\t        }\n\t\n\t      return saved.then(function () {\n\t        self.autosaveClearFlags();\n\t        self.emit(\"save\");\n\t      });\n\t    };\n\t\n\t    // alias\n\t    Loki.prototype.save = Loki.prototype.saveDatabase;\n\t\n\t    /**\n\t     * Handles deleting a database from file system, local storage, or adapter (indexeddb)\n\t     *\n\t     * @returns {Promise} a Promise that resolves after the database is deleted\n\t     * @memberof Loki\n\t     */\n\t    Loki.prototype.deleteDatabase = function () {\n\t      // the persistenceAdapter should be present if all is ok, but check to be sure.\n\t      if (this.persistenceAdapter === null) {\n\t        return Promise.reject(new Error('persistenceAdapter not configured'));\n\t      }\n\t\n\t      return this.persistenceAdapter.deleteDatabase(this.filename);\n\t    };\n\t\n\t    /**\n\t     * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n\t     *\n\t     * @returns {boolean} - true if database has changed since last autosave, false if not.\n\t     */\n\t    Loki.prototype.autosaveDirty = function () {\n\t      for (var idx = 0; idx < this.collections.length; idx++) {\n\t        if (this.collections[idx].dirty) {\n\t          return true;\n\t        }\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    /**\n\t     * autosaveClearFlags - resets dirty flags on all collections.\n\t     *    Called from saveDatabase() after db is saved.\n\t     *\n\t     */\n\t    Loki.prototype.autosaveClearFlags = function () {\n\t      for (var idx = 0; idx < this.collections.length; idx++) {\n\t        this.collections[idx].dirty = false;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * autosaveEnable - begin a javascript interval to periodically save the database.\n\t     *\n\t     */\n\t    Loki.prototype.autosaveEnable = function () {\n\t      if (this.autosaveHandle) {\n\t        return;\n\t      }\n\t\n\t      var self = this;\n\t      var running = true;\n\t\n\t      this.autosave = true;\n\t      this.autosaveHandle = function () {\n\t        running = false;\n\t        self.autosaveHandle = undefined;\n\t      };\n\t\n\t      (function saveDatabase() {\n\t        setTimeout(function () {\n\t          if (running) {\n\t            self.saveDatabase().then(saveDatabase, saveDatabase);\n\t          }\n\t        }, self.autosaveInterval);\n\t      })();\n\t    };\n\t\n\t    /**\n\t     * autosaveDisable - stop the autosave interval timer.\n\t     *\n\t     */\n\t    Loki.prototype.autosaveDisable = function () {\n\t      this.autosave = false;\n\t\n\t      if (this.autosaveHandle) {\n\t        this.autosaveHandle();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Resultset class allowing chainable queries.  Intended to be instanced internally.\n\t     *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n\t     *\n\t     * @example\n\t     *    mycollection.chain()\n\t     *      .find({ 'doors' : 4 })\n\t     *      .where(function(obj) { return obj.name === 'Toyota' })\n\t     *      .data();\n\t     *\n\t     * @constructor Resultset\n\t     * @param {Collection} collection - The collection which this Resultset will query against.\n\t     * @param {Object=} options - Object containing one or more options.\n\t     * @param {string} options.queryObj - Optional mongo-style query object to initialize resultset with.\n\t     * @param {function} options.queryFunc - Optional javascript filter function to initialize resultset with.\n\t     * @param {bool} options.firstOnly - Optional boolean used by collection.findOne().\n\t     */\n\t    function Resultset(collection, options) {\n\t      options = options || {};\n\t\n\t      options.queryObj = options.queryObj || null;\n\t      options.queryFunc = options.queryFunc || null;\n\t      options.firstOnly = options.firstOnly || false;\n\t\n\t      // retain reference to collection we are querying against\n\t      this.collection = collection;\n\t\n\t      // if chain() instantiates with null queryObj and queryFunc, so we will keep flag for later\n\t      this.searchIsChained = !options.queryObj && !options.queryFunc;\n\t      this.filteredrows = [];\n\t      this.filterInitialized = false;\n\t\n\t      // if user supplied initial queryObj or queryFunc, apply it\n\t      if (typeof options.queryObj !== \"undefined\" && options.queryObj !== null) {\n\t        return this.find(options.queryObj, options.firstOnly);\n\t      }\n\t      if (typeof options.queryFunc !== \"undefined\" && options.queryFunc !== null) {\n\t        return this.where(options.queryFunc);\n\t      }\n\t\n\t      // otherwise return unfiltered Resultset for future filtering\n\t      return this;\n\t    }\n\t\n\t    /**\n\t     * reset() - Reset the resultset to its initial state.\n\t     *\n\t     * @returns {Resultset} Reference to this resultset, for future chain operations.\n\t     */\n\t    Resultset.prototype.reset = function () {\n\t      if (this.filteredrows.length > 0) {\n\t        this.filteredrows = [];\n\t      }\n\t      this.filterInitialized = false;\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * toJSON() - Override of toJSON to avoid circular references\n\t     *\n\t     */\n\t    Resultset.prototype.toJSON = function () {\n\t      var copy = this.copy();\n\t      copy.collection = null;\n\t      return copy;\n\t    };\n\t\n\t    /**\n\t     * Allows you to limit the number of documents passed to next chain operation.\n\t     *    A resultset copy() is made to avoid altering original resultset.\n\t     *\n\t     * @param {int} qty - The number of documents to return.\n\t     * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.limit = function (qty) {\n\t      // if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t        this.filteredrows = this.collection.prepareFullDocIndex();\n\t      }\n\t\n\t      var rscopy = new Resultset(this.collection);\n\t      rscopy.filteredrows = this.filteredrows.slice(0, qty);\n\t      rscopy.filterInitialized = true;\n\t      return rscopy;\n\t    };\n\t\n\t    /**\n\t     * Used for skipping 'pos' number of documents in the resultset.\n\t     *\n\t     * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n\t     * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.offset = function (pos) {\n\t      // if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t        this.filteredrows = this.collection.prepareFullDocIndex();\n\t      }\n\t\n\t      var rscopy = new Resultset(this.collection);\n\t      rscopy.filteredrows = this.filteredrows.slice(pos);\n\t      rscopy.filterInitialized = true;\n\t      return rscopy;\n\t    };\n\t\n\t    /**\n\t     * copy() - To support reuse of resultset in branched query situations.\n\t     *\n\t     * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.copy = function () {\n\t      var result = new Resultset(this.collection);\n\t\n\t      if (this.filteredrows.length > 0) {\n\t        result.filteredrows = this.filteredrows.slice();\n\t      }\n\t      result.filterInitialized = this.filterInitialized;\n\t\n\t      return result;\n\t    };\n\t\n\t    /**\n\t     * Alias of copy()\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.branch = Resultset.prototype.copy;\n\t\n\t    /**\n\t     * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n\t     *\n\t     * @param transform {(string|array)} - name of collection transform or raw transform array\n\t     * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n\t     * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.transform = function (transform, parameters) {\n\t      var idx,\n\t          step,\n\t          rs = this;\n\t\n\t      // if transform is name, then do lookup first\n\t      if (typeof transform === 'string') {\n\t        if (this.collection.transforms.hasOwnProperty(transform)) {\n\t          transform = this.collection.transforms[transform];\n\t        }\n\t      }\n\t\n\t      // either they passed in raw transform array or we looked it up, so process\n\t      if (typeof transform !== 'object' || !Array.isArray(transform)) {\n\t        throw new Error(\"Invalid transform\");\n\t      }\n\t\n\t      if (typeof parameters !== 'undefined') {\n\t        transform = Utils.resolveTransformParams(transform, parameters);\n\t      }\n\t\n\t      for (idx = 0; idx < transform.length; idx++) {\n\t        step = transform[idx];\n\t\n\t        switch (step.type) {\n\t          case \"find\":\n\t            rs.find(step.value);\n\t            break;\n\t          case \"where\":\n\t            rs.where(step.value);\n\t            break;\n\t          case \"simplesort\":\n\t            rs.simplesort(step.property, step.desc);\n\t            break;\n\t          case \"compoundsort\":\n\t            rs.compoundsort(step.value);\n\t            break;\n\t          case \"sort\":\n\t            rs.sort(step.value);\n\t            break;\n\t          case \"limit\":\n\t            rs = rs.limit(step.value);\n\t            break; // limit makes copy so update reference\n\t          case \"offset\":\n\t            rs = rs.offset(step.value);\n\t            break; // offset makes copy so update reference\n\t          case \"map\":\n\t            rs = rs.map(step.value);\n\t            break;\n\t          case \"eqJoin\":\n\t            rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);\n\t            break;\n\t          // following cases break chain by returning array data so make any of these last in transform steps\n\t          case \"mapReduce\":\n\t            rs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n\t            break;\n\t          // following cases update documents in current filtered resultset (use carefully)\n\t          case \"update\":\n\t            rs.update(step.value);\n\t            break;\n\t          case \"remove\":\n\t            rs.remove();\n\t            break;\n\t          default:\n\t            break;\n\t        }\n\t      }\n\t\n\t      return rs;\n\t    };\n\t\n\t    /**\n\t     * User supplied compare function is provided two documents to compare. (chainable)\n\t     * @example\n\t     *    rslt.sort(function(obj1, obj2) {\n\t     *      if (obj1.name === obj2.name) return 0;\n\t     *      if (obj1.name > obj2.name) return 1;\n\t     *      if (obj1.name < obj2.name) return -1;\n\t     *    });\n\t     *\n\t     * @param {function} comparefun - A javascript compare function used for sorting.\n\t     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.sort = function (comparefun) {\n\t      // if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t        this.filteredrows = this.collection.prepareFullDocIndex();\n\t      }\n\t\n\t      var wrappedComparer = function (userComparer, data) {\n\t        return function (a, b) {\n\t          return userComparer(data[a], data[b]);\n\t        };\n\t      }(comparefun, this.collection.data);\n\t\n\t      this.filteredrows.sort(wrappedComparer);\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n\t     *    Sorting based on the same lt/gt helper functions used for binary indices.\n\t     *\n\t     * @param {string} propname - name of property to sort by.\n\t     * @param {bool=} isdesc - (Optional) If true, the property will be sorted in descending order\n\t     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.simplesort = function (propname, isdesc) {\n\t      // if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t        this.filteredrows = this.collection.prepareFullDocIndex();\n\t      }\n\t\n\t      if (typeof isdesc === 'undefined') {\n\t        isdesc = false;\n\t      }\n\t\n\t      var wrappedComparer = function (prop, desc, data) {\n\t        return function (a, b) {\n\t          return sortHelper(data[a][prop], data[b][prop], desc);\n\t        };\n\t      }(propname, isdesc, this.collection.data);\n\t\n\t      this.filteredrows.sort(wrappedComparer);\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Allows sorting a resultset based on multiple columns.\n\t     * @example\n\t     * // to sort by age and then name (both ascending)\n\t     * rs.compoundsort(['age', 'name']);\n\t     * // to sort by age (ascending) and then by name (descending)\n\t     * rs.compoundsort(['age', ['name', true]);\n\t     *\n\t     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.compoundsort = function (properties) {\n\t      if (properties.length === 0) {\n\t        throw new Error(\"Invalid call to compoundsort, need at least one property\");\n\t      }\n\t\n\t      var prop;\n\t      if (properties.length === 1) {\n\t        prop = properties[0];\n\t        if (Array.isArray(prop)) {\n\t          return this.simplesort(prop[0], prop[1]);\n\t        }\n\t        return this.simplesort(prop, false);\n\t      }\n\t\n\t      // unify the structure of 'properties' to avoid checking it repeatedly while sorting\n\t      for (var i = 0, len = properties.length; i < len; i += 1) {\n\t        prop = properties[i];\n\t        if (!Array.isArray(prop)) {\n\t          properties[i] = [prop, false];\n\t        }\n\t      }\n\t\n\t      // if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t        this.filteredrows = this.collection.prepareFullDocIndex();\n\t      }\n\t\n\t      var wrappedComparer = function (props, data) {\n\t        return function (a, b) {\n\t          return compoundeval(props, data[a], data[b]);\n\t        };\n\t      }(properties, this.collection.data);\n\t\n\t      this.filteredrows.sort(wrappedComparer);\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * findOr() - oversee the operation of OR'ed query expressions.\n\t     *    OR'ed expression evaluation runs each expression individually against the full collection,\n\t     *    and finally does a set OR on each expression's results.\n\t     *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n\t     *\n\t     * @param {array} expressionArray - array of expressions\n\t     * @returns {Resultset} this resultset for further chain ops.\n\t     */\n\t    Resultset.prototype.findOr = function (expressionArray) {\n\t      var fr = null,\n\t          fri = 0,\n\t          frlen = 0,\n\t          docset = [],\n\t          idxset = [],\n\t          idx = 0,\n\t          origCount = this.count();\n\t\n\t      // If filter is already initialized, then we query against only those items already in filter.\n\t      // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n\t      for (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n\t        // we need to branch existing query to run each filter separately and combine results\n\t        fr = this.branch().find(expressionArray[ei]).filteredrows;\n\t        frlen = fr.length;\n\t        // if the find operation did not reduce the initial set, then the initial set is the actual result\n\t        if (frlen === origCount) {\n\t          return this;\n\t        }\n\t\n\t        // add any document 'hits'\n\t        for (fri = 0; fri < frlen; fri++) {\n\t          idx = fr[fri];\n\t          if (idxset[idx] === undefined) {\n\t            idxset[idx] = true;\n\t            docset.push(idx);\n\t          }\n\t        }\n\t      }\n\t\n\t      this.filteredrows = docset;\n\t      this.filterInitialized = true;\n\t\n\t      return this;\n\t    };\n\t    Resultset.prototype.$or = Resultset.prototype.findOr;\n\t\n\t    /**\n\t     * findAnd() - oversee the operation of AND'ed query expressions.\n\t     *    AND'ed expression evaluation runs each expression progressively against the full collection,\n\t     *    internally utilizing existing chained resultset functionality.\n\t     *    Only the first filter can utilize a binary index.\n\t     *\n\t     * @param {array} expressionArray - array of expressions\n\t     * @returns {Resultset} this resultset for further chain ops.\n\t     */\n\t    Resultset.prototype.findAnd = function (expressionArray) {\n\t      // we have already implementing method chaining in this (our Resultset class)\n\t      // so lets just progressively apply user supplied and filters\n\t      for (var i = 0, len = expressionArray.length; i < len; i++) {\n\t        if (this.count() === 0) {\n\t          return this;\n\t        }\n\t        this.find(expressionArray[i]);\n\t      }\n\t      return this;\n\t    };\n\t    Resultset.prototype.$and = Resultset.prototype.findAnd;\n\t\n\t    /**\n\t     * Used for querying via a mongo-style query object.\n\t     *\n\t     * @param {object} query - A mongo-style query object used for filtering current results.\n\t     * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n\t     * @returns {Resultset} this resultset for further chain ops.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.find = function (query, firstOnly) {\n\t      if (this.collection.data.length === 0) {\n\t        if (this.searchIsChained) {\n\t          this.filteredrows = [];\n\t          this.filterInitialized = true;\n\t          return this;\n\t        }\n\t        return [];\n\t      }\n\t\n\t      var queryObject = query || 'getAll',\n\t          p,\n\t          property,\n\t          queryObjectOp,\n\t          operator,\n\t          value,\n\t          key,\n\t          searchByIndex = false,\n\t          result = [],\n\t          index = null;\n\t\n\t      // if this was note invoked via findOne()\n\t      firstOnly = firstOnly || false;\n\t\n\t      if (typeof queryObject === 'object') {\n\t        for (p in queryObject) {\n\t          if (hasOwnProperty.call(queryObject, p)) {\n\t            property = p;\n\t            queryObjectOp = queryObject[p];\n\t            break;\n\t          }\n\t        }\n\t      }\n\t\n\t      // apply no filters if they want all\n\t      if (!property || queryObject === 'getAll') {\n\t        // coll.find(), coll.findOne(), coll.chain().find().data() all path here\n\t\n\t        if (firstOnly) {\n\t          return this.collection.data.length > 0 ? this.collection.data[0] : null;\n\t        }\n\t\n\t        return this.searchIsChained ? this : this.collection.data.slice();\n\t      }\n\t\n\t      // injecting $and and $or expression tree evaluation here.\n\t      if (property === '$and' || property === '$or') {\n\t        if (this.searchIsChained) {\n\t          this[property](queryObjectOp);\n\t\n\t          // for chained find with firstonly,\n\t          if (firstOnly && this.filteredrows.length > 1) {\n\t            this.filteredrows = this.filteredrows.slice(0, 1);\n\t          }\n\t\n\t          return this;\n\t        } else {\n\t          // our $and operation internally chains filters\n\t          result = this.collection.chain()[property](queryObjectOp).data();\n\t\n\t          // if this was coll.findOne() return first object or empty array if null\n\t          // since this is invoked from a constructor we can't return null, so we will\n\t          // make null in coll.findOne();\n\t          if (firstOnly) {\n\t            return result.length === 0 ? [] : result[0];\n\t          }\n\t\n\t          // not first only return all results\n\t          return result;\n\t        }\n\t      }\n\t\n\t      // see if query object is in shorthand mode (assuming eq operator)\n\t      if (queryObjectOp === null || typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date) {\n\t        operator = '$eq';\n\t        value = queryObjectOp;\n\t      } else if (typeof queryObjectOp === 'object') {\n\t        for (key in queryObjectOp) {\n\t          if (hasOwnProperty.call(queryObjectOp, key)) {\n\t            operator = key;\n\t            value = queryObjectOp[key];\n\t            break;\n\t          }\n\t        }\n\t      } else {\n\t        throw new Error('Do not know what you want to do.');\n\t      }\n\t\n\t      // for regex ops, precompile\n\t      if (operator === '$regex') {\n\t        if (Array.isArray(value)) {\n\t          value = new RegExp(value[0], value[1]);\n\t        } else if (!(value instanceof RegExp)) {\n\t          value = new RegExp(value);\n\t        }\n\t      }\n\t\n\t      // if user is deep querying the object such as find('name.first': 'odin')\n\t      var usingDotNotation = property.indexOf('.') !== -1;\n\t\n\t      // if an index exists for the property being queried against, use it\n\t      // for now only enabling for non-chained query (who's set of docs matches index)\n\t      // or chained queries where it is the first filter applied and prop is indexed\n\t      var doIndexCheck = !usingDotNotation && (!this.searchIsChained || !this.filterInitialized);\n\t\n\t      if (doIndexCheck && this.collection.binaryIndices[property] && indexedOpsList.indexOf(operator) !== -1) {\n\t        // this is where our lazy index rebuilding will take place\n\t        // basically we will leave all indexes dirty until we need them\n\t        // so here we will rebuild only the index tied to this property\n\t        // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n\t        if (this.collection.adaptiveBinaryIndices !== true) {\n\t          this.collection.ensureIndex(property);\n\t        }\n\t\n\t        searchByIndex = true;\n\t        index = this.collection.binaryIndices[property];\n\t      }\n\t\n\t      // the comparison function\n\t      var fun = LokiOps[operator];\n\t\n\t      // \"shortcut\" for collection data\n\t      var t = this.collection.data;\n\t      // filter data length\n\t      var i = 0;\n\t\n\t      // Query executed differently depending on :\n\t      //    - whether it is chained or not\n\t      //    - whether the property being queried has an index defined\n\t      //    - if chained, we handle first pass differently for initial filteredrows[] population\n\t      //\n\t      // For performance reasons, each case has its own if block to minimize in-loop calculations\n\t\n\t      // If not a chained query, bypass filteredrows and work directly against data\n\t      if (!this.searchIsChained) {\n\t        if (!searchByIndex) {\n\t          i = t.length;\n\t\n\t          if (firstOnly) {\n\t            if (usingDotNotation) {\n\t              property = property.split('.');\n\t              while (i--) {\n\t                if (dotSubScan(t[i], property, fun, value)) {\n\t                  return t[i];\n\t                }\n\t              }\n\t            } else {\n\t              while (i--) {\n\t                if (fun(t[i][property], value)) {\n\t                  return t[i];\n\t                }\n\t              }\n\t            }\n\t\n\t            return [];\n\t          }\n\t\n\t          // if using dot notation then treat property as keypath such as 'name.first'.\n\t          // currently supporting dot notation for non-indexed conditions only\n\t          if (usingDotNotation) {\n\t            property = property.split('.');\n\t            while (i--) {\n\t              if (dotSubScan(t[i], property, fun, value)) {\n\t                result.push(t[i]);\n\t              }\n\t            }\n\t          } else {\n\t            while (i--) {\n\t              if (fun(t[i][property], value)) {\n\t                result.push(t[i]);\n\t              }\n\t            }\n\t          }\n\t        } else {\n\t          // searching by binary index via calculateRange() utility method\n\t          var seg = this.collection.calculateRange(operator, property, value);\n\t\n\t          // not chained so this 'find' was designated in Resultset constructor\n\t          // so return object itself\n\t          if (firstOnly) {\n\t            if (seg[1] !== -1) {\n\t              return t[index.values[seg[0]]];\n\t            }\n\t            return [];\n\t          }\n\t\n\t          for (i = seg[0]; i <= seg[1]; i++) {\n\t            result.push(t[index.values[i]]);\n\t          }\n\t        }\n\t\n\t        // not a chained query so return result as data[]\n\t        return result;\n\t      }\n\t\n\t      // Otherwise this is a chained query\n\t\n\t      var filter,\n\t          rowIdx = 0;\n\t\n\t      // If the filteredrows[] is already initialized, use it\n\t      if (this.filterInitialized) {\n\t        filter = this.filteredrows;\n\t        i = filter.length;\n\t\n\t        // currently supporting dot notation for non-indexed conditions only\n\t        if (usingDotNotation) {\n\t          property = property.split('.');\n\t          while (i--) {\n\t            rowIdx = filter[i];\n\t            if (dotSubScan(t[rowIdx], property, fun, value)) {\n\t              result.push(rowIdx);\n\t            }\n\t          }\n\t        } else {\n\t          while (i--) {\n\t            rowIdx = filter[i];\n\t            if (fun(t[rowIdx][property], value)) {\n\t              result.push(rowIdx);\n\t            }\n\t          }\n\t        }\n\t      }\n\t      // first chained query so work against data[] but put results in filteredrows\n\t      else {\n\t          // if not searching by index\n\t          if (!searchByIndex) {\n\t            i = t.length;\n\t\n\t            if (usingDotNotation) {\n\t              property = property.split('.');\n\t              while (i--) {\n\t                if (dotSubScan(t[i], property, fun, value)) {\n\t                  result.push(i);\n\t                }\n\t              }\n\t            } else {\n\t              while (i--) {\n\t                if (fun(t[i][property], value)) {\n\t                  result.push(i);\n\t                }\n\t              }\n\t            }\n\t          } else {\n\t            // search by index\n\t            var segm = this.collection.calculateRange(operator, property, value);\n\t\n\t            for (i = segm[0]; i <= segm[1]; i++) {\n\t              result.push(index.values[i]);\n\t            }\n\t          }\n\t\n\t          this.filterInitialized = true; // next time work against filteredrows[]\n\t        }\n\t\n\t      this.filteredrows = result;\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * where() - Used for filtering via a javascript filter function.\n\t     *\n\t     * @param {function} fun - A javascript function used for filtering current results by.\n\t     * @returns {Resultset} this resultset for further chain ops.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.where = function (fun) {\n\t      var viewFunction,\n\t          result = [];\n\t\n\t      if ('function' === typeof fun) {\n\t        viewFunction = fun;\n\t      } else {\n\t        throw new TypeError('Argument is not a stored view or a function');\n\t      }\n\t      try {\n\t        // if not a chained query then run directly against data[] and return object []\n\t        if (!this.searchIsChained) {\n\t          var i = this.collection.data.length;\n\t\n\t          while (i--) {\n\t            if (viewFunction(this.collection.data[i]) === true) {\n\t              result.push(this.collection.data[i]);\n\t            }\n\t          }\n\t\n\t          // not a chained query so returning result as data[]\n\t          return result;\n\t        }\n\t        // else chained query, so run against filteredrows\n\t        else {\n\t            // If the filteredrows[] is already initialized, use it\n\t            if (this.filterInitialized) {\n\t              var j = this.filteredrows.length;\n\t\n\t              while (j--) {\n\t                if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n\t                  result.push(this.filteredrows[j]);\n\t                }\n\t              }\n\t\n\t              this.filteredrows = result;\n\t\n\t              return this;\n\t            }\n\t            // otherwise this is initial chained op, work against data, push into filteredrows[]\n\t            else {\n\t                var k = this.collection.data.length;\n\t\n\t                while (k--) {\n\t                  if (viewFunction(this.collection.data[k]) === true) {\n\t                    result.push(k);\n\t                  }\n\t                }\n\t\n\t                this.filteredrows = result;\n\t                this.filterInitialized = true;\n\t\n\t                return this;\n\t              }\n\t          }\n\t      } catch (err) {\n\t        throw err;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * count() - returns the number of documents in the resultset.\n\t     *\n\t     * @returns {number} The number of documents in the resultset.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.count = function () {\n\t      if (this.searchIsChained && this.filterInitialized) {\n\t        return this.filteredrows.length;\n\t      }\n\t      return this.collection.count();\n\t    };\n\t\n\t    /**\n\t     * Terminates the chain and returns array of filtered documents\n\t     *\n\t     * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n\t     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n\t     *        the collection is not configured for clone object.\n\t     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n\t     *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'\n\t     *\n\t     * @returns {array} Array of documents in the resultset\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.data = function (options) {\n\t      var result = [],\n\t          data = this.collection.data,\n\t          len,\n\t          i,\n\t          method;\n\t\n\t      options = options || {};\n\t\n\t      // if this is chained resultset with no filters applied, just return collection.data\n\t      if (this.searchIsChained && !this.filterInitialized) {\n\t        if (this.filteredrows.length === 0) {\n\t          // determine whether we need to clone objects or not\n\t          if (this.collection.cloneObjects || options.forceClones) {\n\t            len = data.length;\n\t            method = options.forceCloneMethod || this.collection.cloneMethod;\n\t\n\t            for (i = 0; i < len; i++) {\n\t              result.push(clone(data[i], method));\n\t            }\n\t            return result;\n\t          }\n\t          // otherwise we are not cloning so return sliced array with same object references\n\t          else {\n\t              return data.slice();\n\t            }\n\t        } else {\n\t          // filteredrows must have been set manually, so use it\n\t          this.filterInitialized = true;\n\t        }\n\t      }\n\t\n\t      var fr = this.filteredrows;\n\t      len = fr.length;\n\t\n\t      if (this.collection.cloneObjects || options.forceClones) {\n\t        method = options.forceCloneMethod || this.collection.cloneMethod;\n\t        for (i = 0; i < len; i++) {\n\t          result.push(clone(data[fr[i]], method));\n\t        }\n\t      } else {\n\t        for (i = 0; i < len; i++) {\n\t          result.push(data[fr[i]]);\n\t        }\n\t      }\n\t      return result;\n\t    };\n\t\n\t    /**\n\t     * Used to run an update operation on all documents currently in the resultset.\n\t     *\n\t     * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n\t     * @returns {Resultset} this resultset for further chain ops.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.update = function (updateFunction) {\n\t\n\t      if (typeof updateFunction !== \"function\") {\n\t        throw new TypeError('Argument is not a function');\n\t      }\n\t\n\t      // if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t        this.filteredrows = this.collection.prepareFullDocIndex();\n\t      }\n\t\n\t      var len = this.filteredrows.length,\n\t          rcd = this.collection.data;\n\t\n\t      for (var idx = 0; idx < len; idx++) {\n\t        // pass in each document object currently in resultset to user supplied updateFunction\n\t        updateFunction(rcd[this.filteredrows[idx]]);\n\t\n\t        // notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate\n\t        this.collection.update(rcd[this.filteredrows[idx]]);\n\t      }\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Removes all document objects which are currently in resultset from collection (as well as resultset)\n\t     *\n\t     * @returns {Resultset} this (empty) resultset for further chain ops.\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.remove = function () {\n\t\n\t      // if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t        this.filteredrows = this.collection.prepareFullDocIndex();\n\t      }\n\t\n\t      this.collection.remove(this.data());\n\t\n\t      this.filteredrows = [];\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * data transformation via user supplied functions\n\t     *\n\t     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t     * @returns {value} The output of your reduceFunction\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.mapReduce = function (mapFunction, reduceFunction) {\n\t      try {\n\t        return reduceFunction(this.data().map(mapFunction));\n\t      } catch (err) {\n\t        throw err;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n\t     * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n\t     * @param {Array} joinData - Data array to join to.\n\t     * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n\t     * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n\t     * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n\t     * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n\t     * @memberof Resultset\n\t     */\n\t    Resultset.prototype.eqJoin = function (joinData, leftJoinKey, rightJoinKey, mapFun) {\n\t\n\t      var leftData = [],\n\t          leftDataLength,\n\t          rightData = [],\n\t          rightDataLength,\n\t          key,\n\t          result = [],\n\t          leftKeyisFunction = typeof leftJoinKey === 'function',\n\t          rightKeyisFunction = typeof rightJoinKey === 'function',\n\t          joinMap = {};\n\t\n\t      //get the left data\n\t      leftData = this.data();\n\t      leftDataLength = leftData.length;\n\t\n\t      //get the right data\n\t      if (joinData instanceof Resultset) {\n\t        rightData = joinData.data();\n\t      } else if (Array.isArray(joinData)) {\n\t        rightData = joinData;\n\t      } else {\n\t        throw new TypeError('joinData needs to be an array or result set');\n\t      }\n\t      rightDataLength = rightData.length;\n\t\n\t      //construct a lookup table\n\t\n\t      for (var i = 0; i < rightDataLength; i++) {\n\t        key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n\t        joinMap[key] = rightData[i];\n\t      }\n\t\n\t      if (!mapFun) {\n\t        mapFun = function (left, right) {\n\t          return {\n\t            left: left,\n\t            right: right\n\t          };\n\t        };\n\t      }\n\t\n\t      //Run map function over each object in the resultset\n\t      for (var j = 0; j < leftDataLength; j++) {\n\t        key = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n\t        result.push(mapFun(leftData[j], joinMap[key] || {}));\n\t      }\n\t\n\t      //return return a new resultset with no filters\n\t      this.collection = new Collection('joinData');\n\t      this.collection.insert(result);\n\t      this.filteredrows = [];\n\t      this.filterInitialized = false;\n\t\n\t      return this;\n\t    };\n\t\n\t    Resultset.prototype.map = function (mapFun) {\n\t      var data = this.data().map(mapFun);\n\t      //return return a new resultset with no filters\n\t      this.collection = new Collection('mappedData');\n\t      this.collection.insert(data);\n\t      this.filteredrows = [];\n\t      this.filterInitialized = false;\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n\t     *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n\t     *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n\t     *\n\t     * @example\n\t     * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n\t     * mydv.applyFind({ 'doors' : 4 });\n\t     * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n\t     * var results = mydv.data();\n\t     *\n\t     * @constructor DynamicView\n\t     * @implements LokiEventEmitter\n\t     * @param {Collection} collection - A reference to the collection to work against\n\t     * @param {string} name - The name of this dynamic view\n\t     * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n\t     * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t     * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t     * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n\t     */\n\t    function DynamicView(collection, name, options) {\n\t      this.collection = collection;\n\t      this.name = name;\n\t      this.rebuildPending = false;\n\t      this.options = options || {};\n\t\n\t      if (!this.options.hasOwnProperty('persistent')) {\n\t        this.options.persistent = false;\n\t      }\n\t\n\t      // 'persistentSortPriority':\n\t      // 'passive' will defer the sort phase until they call data(). (most efficient overall)\n\t      // 'active' will sort async whenever next idle. (prioritizes read speeds)\n\t      if (!this.options.hasOwnProperty('sortPriority')) {\n\t        this.options.sortPriority = 'passive';\n\t      }\n\t\n\t      if (!this.options.hasOwnProperty('minRebuildInterval')) {\n\t        this.options.minRebuildInterval = 1;\n\t      }\n\t\n\t      this.resultset = new Resultset(collection);\n\t      this.resultdata = [];\n\t      this.resultsdirty = false;\n\t\n\t      this.cachedresultset = null;\n\t\n\t      // keep ordered filter pipeline\n\t      this.filterPipeline = [];\n\t\n\t      // sorting member variables\n\t      // we only support one active search, applied using applySort() or applySimpleSort()\n\t      this.sortFunction = null;\n\t      this.sortCriteria = null;\n\t      this.sortDirty = false;\n\t\n\t      // for now just have 1 event for when we finally rebuilt lazy view\n\t      // once we refactor transactions, i will tie in certain transactional events\n\t\n\t      this.events = {\n\t        'rebuild': []\n\t      };\n\t    }\n\t\n\t    DynamicView.prototype = new LokiEventEmitter();\n\t\n\t    /**\n\t     * rematerialize() - intended for use immediately after deserialization (loading)\n\t     *    This will clear out and reapply filterPipeline ops, recreating the view.\n\t     *    Since where filters do not persist correctly, this method allows\n\t     *    restoring the view to state where user can re-apply those where filters.\n\t     *\n\t     * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n\t     * @returns {DynamicView} This dynamic view for further chained ops.\n\t     * @memberof DynamicView\n\t     * @fires DynamicView.rebuild\n\t     */\n\t    DynamicView.prototype.rematerialize = function (options) {\n\t      var fpl, fpi, idx;\n\t\n\t      options = options || {};\n\t\n\t      this.resultdata = [];\n\t      this.resultsdirty = true;\n\t      this.resultset = new Resultset(this.collection);\n\t\n\t      if (this.sortFunction || this.sortCriteria) {\n\t        this.sortDirty = true;\n\t      }\n\t\n\t      if (options.hasOwnProperty('removeWhereFilters')) {\n\t        // for each view see if it had any where filters applied... since they don't\n\t        // serialize those functions lets remove those invalid filters\n\t        fpl = this.filterPipeline.length;\n\t        fpi = fpl;\n\t        while (fpi--) {\n\t          if (this.filterPipeline[fpi].type === 'where') {\n\t            if (fpi !== this.filterPipeline.length - 1) {\n\t              this.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n\t            }\n\t\n\t            this.filterPipeline.length--;\n\t          }\n\t        }\n\t      }\n\t\n\t      // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n\t      var ofp = this.filterPipeline;\n\t      this.filterPipeline = [];\n\t\n\t      // now re-apply 'find' filterPipeline ops\n\t      fpl = ofp.length;\n\t      for (idx = 0; idx < fpl; idx++) {\n\t        this.applyFind(ofp[idx].val);\n\t      }\n\t\n\t      // during creation of unit tests, i will remove this forced refresh and leave lazy\n\t      this.data();\n\t\n\t      // emit rebuild event in case user wants to be notified\n\t      this.emit('rebuild', this);\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * branchResultset() - Makes a copy of the internal resultset for branched queries.\n\t     *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n\t     *    so your branched query should be immediately resolved and not held for future evaluation.\n\t     *\n\t     * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n\t     * @param {object=} parameters - optional parameters (if optional transform requires them)\n\t     * @returns {Resultset} A copy of the internal resultset for branched queries.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.branchResultset = function (transform, parameters) {\n\t      var rs = this.resultset.branch();\n\t\n\t      if (typeof transform === 'undefined') {\n\t        return rs;\n\t      }\n\t\n\t      return rs.transform(transform, parameters);\n\t    };\n\t\n\t    /**\n\t     * toJSON() - Override of toJSON to avoid circular references\n\t     *\n\t     */\n\t    DynamicView.prototype.toJSON = function () {\n\t      var copy = new DynamicView(this.collection, this.name, this.options);\n\t\n\t      copy.resultset = this.resultset;\n\t      copy.resultdata = []; // let's not save data (copy) to minimize size\n\t      copy.resultsdirty = true;\n\t      copy.filterPipeline = this.filterPipeline;\n\t      copy.sortFunction = this.sortFunction;\n\t      copy.sortCriteria = this.sortCriteria;\n\t      copy.sortDirty = this.sortDirty;\n\t\n\t      // avoid circular reference, reapply in db.loadJSON()\n\t      copy.collection = null;\n\t\n\t      return copy;\n\t    };\n\t\n\t    /**\n\t     * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n\t     *     Existing options should be retained.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.removeFilters = function () {\n\t      this.rebuildPending = false;\n\t      this.resultset.reset();\n\t      this.resultdata = [];\n\t      this.resultsdirty = false;\n\t\n\t      this.cachedresultset = null;\n\t\n\t      // keep ordered filter pipeline\n\t      this.filterPipeline = [];\n\t\n\t      // sorting member variables\n\t      // we only support one active search, applied using applySort() or applySimpleSort()\n\t      this.sortFunction = null;\n\t      this.sortCriteria = null;\n\t      this.sortDirty = false;\n\t    };\n\t\n\t    /**\n\t     * applySort() - Used to apply a sort to the dynamic view\n\t     * @example\n\t     * dv.applySort(function(obj1, obj2) {\n\t     *   if (obj1.name === obj2.name) return 0;\n\t     *   if (obj1.name > obj2.name) return 1;\n\t     *   if (obj1.name < obj2.name) return -1;\n\t     * });\n\t     *\n\t     * @param {function} comparefun - a javascript compare function used for sorting\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.applySort = function (comparefun) {\n\t      this.sortFunction = comparefun;\n\t      this.sortCriteria = null;\n\t\n\t      this.queueSortPhase();\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * applySimpleSort() - Used to specify a property used for view translation.\n\t     * @example\n\t     * dv.applySimpleSort(\"name\");\n\t     *\n\t     * @param {string} propname - Name of property by which to sort.\n\t     * @param {boolean=} isdesc - (Optional) If true, the sort will be in descending order.\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.applySimpleSort = function (propname, isdesc) {\n\t      this.sortCriteria = [[propname, isdesc || false]];\n\t      this.sortFunction = null;\n\t\n\t      this.queueSortPhase();\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n\t     * @example\n\t     * // to sort by age and then name (both ascending)\n\t     * dv.applySortCriteria(['age', 'name']);\n\t     * // to sort by age (ascending) and then by name (descending)\n\t     * dv.applySortCriteria(['age', ['name', true]);\n\t     * // to sort by age (descending) and then by name (descending)\n\t     * dv.applySortCriteria(['age', true], ['name', true]);\n\t     *\n\t     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t     * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.applySortCriteria = function (criteria) {\n\t      this.sortCriteria = criteria;\n\t      this.sortFunction = null;\n\t\n\t      this.queueSortPhase();\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * startTransaction() - marks the beginning of a transaction.\n\t     *\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     */\n\t    DynamicView.prototype.startTransaction = function () {\n\t      this.cachedresultset = this.resultset.copy();\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * commit() - commits a transaction.\n\t     *\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     */\n\t    DynamicView.prototype.commit = function () {\n\t      this.cachedresultset = null;\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * rollback() - rolls back a transaction.\n\t     *\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     */\n\t    DynamicView.prototype.rollback = function () {\n\t      this.resultset = this.cachedresultset;\n\t\n\t      if (this.options.persistent) {\n\t        // for now just rebuild the persistent dynamic view data in this worst case scenario\n\t        // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n\t        this.resultdata = this.resultset.data();\n\t\n\t        this.emit('rebuild', this);\n\t      }\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * Implementation detail.\n\t     * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n\t     *\n\t     * @param {(string|number)} uid - The unique ID of the filter.\n\t     * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n\t     */\n\t    DynamicView.prototype._indexOfFilterWithId = function (uid) {\n\t      if (typeof uid === 'string' || typeof uid === 'number') {\n\t        for (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n\t          if (uid === this.filterPipeline[idx].uid) {\n\t            return idx;\n\t          }\n\t        }\n\t      }\n\t      return -1;\n\t    };\n\t\n\t    /**\n\t     * Implementation detail.\n\t     * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n\t     *\n\t     * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n\t     */\n\t    DynamicView.prototype._addFilter = function (filter) {\n\t      this.filterPipeline.push(filter);\n\t      this.resultset[filter.type](filter.val);\n\t    };\n\t\n\t    /**\n\t     * reapplyFilters() - Reapply all the filters in the current pipeline.\n\t     *\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     */\n\t    DynamicView.prototype.reapplyFilters = function () {\n\t      this.resultset.reset();\n\t\n\t      this.cachedresultset = null;\n\t      if (this.options.persistent) {\n\t        this.resultdata = [];\n\t        this.resultsdirty = true;\n\t      }\n\t\n\t      var filters = this.filterPipeline;\n\t      this.filterPipeline = [];\n\t\n\t      for (var idx = 0, len = filters.length; idx < len; idx += 1) {\n\t        this._addFilter(filters[idx]);\n\t      }\n\t\n\t      if (this.sortFunction || this.sortCriteria) {\n\t        this.queueSortPhase();\n\t      } else {\n\t        this.queueRebuildEvent();\n\t      }\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n\t     *\n\t     * @param {object} filter - A filter object to add to the pipeline.\n\t     *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.applyFilter = function (filter) {\n\t      var idx = this._indexOfFilterWithId(filter.uid);\n\t      if (idx >= 0) {\n\t        this.filterPipeline[idx] = filter;\n\t        return this.reapplyFilters();\n\t      }\n\t\n\t      this.cachedresultset = null;\n\t      if (this.options.persistent) {\n\t        this.resultdata = [];\n\t        this.resultsdirty = true;\n\t      }\n\t\n\t      this._addFilter(filter);\n\t\n\t      if (this.sortFunction || this.sortCriteria) {\n\t        this.queueSortPhase();\n\t      } else {\n\t        this.queueRebuildEvent();\n\t      }\n\t\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n\t     *\n\t     * @param {object} query - A mongo-style query object to apply to pipeline\n\t     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.applyFind = function (query, uid) {\n\t      this.applyFilter({\n\t        type: 'find',\n\t        val: query,\n\t        uid: uid\n\t      });\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n\t     *\n\t     * @param {function} fun - A javascript filter function to apply to pipeline\n\t     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.applyWhere = function (fun, uid) {\n\t      this.applyFilter({\n\t        type: 'where',\n\t        val: fun,\n\t        uid: uid\n\t      });\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n\t     *\n\t     * @param {(string|number)} uid - The unique ID of the filter to be removed.\n\t     * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.removeFilter = function (uid) {\n\t      var idx = this._indexOfFilterWithId(uid);\n\t      if (idx < 0) {\n\t        throw new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n\t      }\n\t\n\t      this.filterPipeline.splice(idx, 1);\n\t      this.reapplyFilters();\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * count() - returns the number of documents representing the current DynamicView contents.\n\t     *\n\t     * @returns {number} The number of documents representing the current DynamicView contents.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.count = function () {\n\t      if (this.options.persistent) {\n\t        return this.resultdata.length;\n\t      }\n\t      return this.resultset.count();\n\t    };\n\t\n\t    /**\n\t     * data() - resolves and pending filtering and sorting, then returns document array as result.\n\t     *\n\t     * @returns {array} An array of documents representing the current DynamicView contents.\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.data = function () {\n\t      // using final sort phase as 'catch all' for a few use cases which require full rebuild\n\t      if (this.sortDirty || this.resultsdirty) {\n\t        this.performSortPhase({\n\t          suppressRebuildEvent: true\n\t        });\n\t      }\n\t      return this.options.persistent ? this.resultdata : this.resultset.data();\n\t    };\n\t\n\t    /**\n\t     * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n\t     *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n\t     */\n\t    DynamicView.prototype.queueRebuildEvent = function () {\n\t      if (this.rebuildPending) {\n\t        return;\n\t      }\n\t      this.rebuildPending = true;\n\t\n\t      var self = this;\n\t      setTimeout(function () {\n\t        if (self.rebuildPending) {\n\t          self.rebuildPending = false;\n\t          self.emit('rebuild', self);\n\t        }\n\t      }, this.options.minRebuildInterval);\n\t    };\n\t\n\t    /**\n\t     * queueSortPhase : If the view is sorted we will throttle sorting to either :\n\t     *    (1) passive - when the user calls data(), or\n\t     *    (2) active - once they stop updating and yield js thread control\n\t     */\n\t    DynamicView.prototype.queueSortPhase = function () {\n\t      // already queued? exit without queuing again\n\t      if (this.sortDirty) {\n\t        return;\n\t      }\n\t      this.sortDirty = true;\n\t\n\t      var self = this;\n\t      if (this.options.sortPriority === \"active\") {\n\t        // active sorting... once they are done and yield js thread, run async performSortPhase()\n\t        setTimeout(function () {\n\t          self.performSortPhase();\n\t        }, this.options.minRebuildInterval);\n\t      } else {\n\t        // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n\t        // potentially notify user that data has changed.\n\t        this.queueRebuildEvent();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n\t     *\n\t     */\n\t    DynamicView.prototype.performSortPhase = function (options) {\n\t      // async call to this may have been pre-empted by synchronous call to data before async could fire\n\t      if (!this.sortDirty && !this.resultsdirty) {\n\t        return;\n\t      }\n\t\n\t      options = options || {};\n\t\n\t      if (this.sortDirty) {\n\t        if (this.sortFunction) {\n\t          this.resultset.sort(this.sortFunction);\n\t        } else if (this.sortCriteria) {\n\t          this.resultset.compoundsort(this.sortCriteria);\n\t        }\n\t\n\t        this.sortDirty = false;\n\t      }\n\t\n\t      if (this.options.persistent) {\n\t        // persistent view, rebuild local resultdata array\n\t        this.resultdata = this.resultset.data();\n\t        this.resultsdirty = false;\n\t      }\n\t\n\t      if (!options.suppressRebuildEvent) {\n\t        this.emit('rebuild', this);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * evaluateDocument() - internal method for (re)evaluating document inclusion.\n\t     *    Called by : collection.insert() and collection.update().\n\t     *\n\t     * @param {int} objIndex - index of document to (re)run through filter pipeline.\n\t     * @param {bool} isNew - true if the document was just added to the collection.\n\t     */\n\t    DynamicView.prototype.evaluateDocument = function (objIndex, isNew) {\n\t      // if no filter applied yet, the result 'set' should remain 'everything'\n\t      if (!this.resultset.filterInitialized) {\n\t        if (this.options.persistent) {\n\t          this.resultdata = this.resultset.data();\n\t        }\n\t        // need to re-sort to sort new document\n\t        if (this.sortFunction || this.sortCriteria) {\n\t          this.queueSortPhase();\n\t        } else {\n\t          this.queueRebuildEvent();\n\t        }\n\t        return;\n\t      }\n\t\n\t      var ofr = this.resultset.filteredrows;\n\t      var oldPos = isNew ? -1 : ofr.indexOf(+objIndex);\n\t      var oldlen = ofr.length;\n\t\n\t      // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n\t      // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n\t      var evalResultset = new Resultset(this.collection);\n\t      evalResultset.filteredrows = [objIndex];\n\t      evalResultset.filterInitialized = true;\n\t      var filter;\n\t      for (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n\t        filter = this.filterPipeline[idx];\n\t        evalResultset[filter.type](filter.val);\n\t      }\n\t\n\t      // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n\t      var newPos = evalResultset.filteredrows.length === 0 ? -1 : 0;\n\t\n\t      // wasn't in old, shouldn't be now... do nothing\n\t      if (oldPos === -1 && newPos === -1) return;\n\t\n\t      // wasn't in resultset, should be now... add\n\t      if (oldPos === -1 && newPos !== -1) {\n\t        ofr.push(objIndex);\n\t\n\t        if (this.options.persistent) {\n\t          this.resultdata.push(this.collection.data[objIndex]);\n\t        }\n\t\n\t        // need to re-sort to sort new document\n\t        if (this.sortFunction || this.sortCriteria) {\n\t          this.queueSortPhase();\n\t        } else {\n\t          this.queueRebuildEvent();\n\t        }\n\t\n\t        return;\n\t      }\n\t\n\t      // was in resultset, shouldn't be now... delete\n\t      if (oldPos !== -1 && newPos === -1) {\n\t        if (oldPos < oldlen - 1) {\n\t          ofr.splice(oldPos, 1);\n\t\n\t          if (this.options.persistent) {\n\t            this.resultdata.splice(oldPos, 1);\n\t          }\n\t        } else {\n\t          ofr.length = oldlen - 1;\n\t\n\t          if (this.options.persistent) {\n\t            this.resultdata.length = oldlen - 1;\n\t          }\n\t        }\n\t\n\t        // in case changes to data altered a sort column\n\t        if (this.sortFunction || this.sortCriteria) {\n\t          this.queueSortPhase();\n\t        } else {\n\t          this.queueRebuildEvent();\n\t        }\n\t\n\t        return;\n\t      }\n\t\n\t      // was in resultset, should still be now... (update persistent only?)\n\t      if (oldPos !== -1 && newPos !== -1) {\n\t        if (this.options.persistent) {\n\t          // in case document changed, replace persistent view data with the latest collection.data document\n\t          this.resultdata[oldPos] = this.collection.data[objIndex];\n\t        }\n\t\n\t        // in case changes to data altered a sort column\n\t        if (this.sortFunction || this.sortCriteria) {\n\t          this.queueSortPhase();\n\t        } else {\n\t          this.queueRebuildEvent();\n\t        }\n\t\n\t        return;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * removeDocument() - internal function called on collection.delete()\n\t     */\n\t    DynamicView.prototype.removeDocument = function (objIndex) {\n\t      // if no filter applied yet, the result 'set' should remain 'everything'\n\t      if (!this.resultset.filterInitialized) {\n\t        if (this.options.persistent) {\n\t          this.resultdata = this.resultset.data();\n\t        }\n\t        // in case changes to data altered a sort column\n\t        if (this.sortFunction || this.sortCriteria) {\n\t          this.queueSortPhase();\n\t        } else {\n\t          this.queueRebuildEvent();\n\t        }\n\t        return;\n\t      }\n\t\n\t      var ofr = this.resultset.filteredrows;\n\t      var oldPos = ofr.indexOf(+objIndex);\n\t      var oldlen = ofr.length;\n\t      var idx;\n\t\n\t      if (oldPos !== -1) {\n\t        // if not last row in resultdata, swap last to hole and truncate last row\n\t        if (oldPos < oldlen - 1) {\n\t          ofr[oldPos] = ofr[oldlen - 1];\n\t          ofr.length = oldlen - 1;\n\t\n\t          if (this.options.persistent) {\n\t            this.resultdata[oldPos] = this.resultdata[oldlen - 1];\n\t            this.resultdata.length = oldlen - 1;\n\t          }\n\t        }\n\t        // last row, so just truncate last row\n\t        else {\n\t            ofr.length = oldlen - 1;\n\t\n\t            if (this.options.persistent) {\n\t              this.resultdata.length = oldlen - 1;\n\t            }\n\t          }\n\t\n\t        // in case changes to data altered a sort column\n\t        if (this.sortFunction || this.sortCriteria) {\n\t          this.queueSortPhase();\n\t        } else {\n\t          this.queueRebuildEvent();\n\t        }\n\t      }\n\t\n\t      // since we are using filteredrows to store data array positions\n\t      // if they remove a document (whether in our view or not),\n\t      // we need to adjust array positions -1 for all document array references after that position\n\t      oldlen = ofr.length;\n\t      for (idx = 0; idx < oldlen; idx++) {\n\t        if (ofr[idx] > objIndex) {\n\t          ofr[idx]--;\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * mapReduce() - data transformation via user supplied functions\n\t     *\n\t     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t     * @returns The output of your reduceFunction\n\t     * @memberof DynamicView\n\t     */\n\t    DynamicView.prototype.mapReduce = function (mapFunction, reduceFunction) {\n\t      try {\n\t        return reduceFunction(this.data().map(mapFunction));\n\t      } catch (err) {\n\t        throw err;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Collection class that handles documents of same type\n\t     * @constructor Collection\n\t     * @implements LokiEventEmitter\n\t     * @param {string} name - collection name\n\t     * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n\t     * @param {array} options.unique - array of property names to define unique constraints for\n\t     * @param {array} options.exact - array of property names to define exact constraints for\n\t     * @param {array} options.indices - array property names to define binary indexes for\n\t     * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily (default: true)\n\t     * @param {boolean} options.asyncListeners - default is false\n\t     * @param {boolean} options.disableChangesApi - default is true\n\t     * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n\t     * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n\t     * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n\t     * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n\t     * @see {@link Loki#addCollection} for normal creation of collections\n\t     */\n\t    function Collection(name, options) {\n\t      // the name of the collection\n\t\n\t      this.name = name;\n\t      // the data held by the collection\n\t      this.data = [];\n\t      this.idIndex = []; // index of id\n\t      this.binaryIndices = {}; // user defined indexes\n\t      this.constraints = {\n\t        unique: {},\n\t        exact: {}\n\t      };\n\t\n\t      // unique contraints contain duplicate object references, so they are not persisted.\n\t      // we will keep track of properties which have unique contraint applied here, and regenerate on load\n\t      this.uniqueNames = [];\n\t\n\t      // transforms will be used to store frequently used query chains as a series of steps\n\t      // which itself can be stored along with the database.\n\t      this.transforms = {};\n\t\n\t      // the object type of the collection\n\t      this.objType = name;\n\t\n\t      // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n\t      // currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n\t      // defaulting to true since this is called from addCollection and adding a collection should trigger save\n\t      this.dirty = true;\n\t\n\t      // private holders for cached data\n\t      this.cachedIndex = null;\n\t      this.cachedBinaryIndex = null;\n\t      this.cachedData = null;\n\t      var self = this;\n\t\n\t      /* OPTIONS */\n\t      options = options || {};\n\t\n\t      // exact match and unique constraints\n\t      if (options.hasOwnProperty('unique')) {\n\t        if (!Array.isArray(options.unique)) {\n\t          options.unique = [options.unique];\n\t        }\n\t        options.unique.forEach(function (prop) {\n\t          self.uniqueNames.push(prop); // used to regenerate on subsequent database loads\n\t          self.constraints.unique[prop] = new UniqueIndex(prop);\n\t        });\n\t      }\n\t\n\t      if (options.hasOwnProperty('exact')) {\n\t        options.exact.forEach(function (prop) {\n\t          self.constraints.exact[prop] = new ExactIndex(prop);\n\t        });\n\t      }\n\t\n\t      // if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n\t      // if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n\t      this.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;\n\t\n\t      // is collection transactional\n\t      this.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;\n\t\n\t      // options to clone objects when inserting them\n\t      this.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;\n\t\n\t      // default clone method (if enabled) is parse-stringify\n\t      this.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : \"parse-stringify\";\n\t\n\t      // option to make event listeners async, default is sync\n\t      this.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;\n\t\n\t      // disable track changes\n\t      this.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;\n\t\n\t      // option to observe objects and update them automatically, ignored if Object.observe is not supported\n\t      this.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;\n\t\n\t      //option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n\t      this.ttl = {\n\t        age: null,\n\t        ttlInterval: null,\n\t        daemon: null\n\t      };\n\t      this.setTTL(options.ttl || -1, options.ttlInterval);\n\t\n\t      // currentMaxId - change manually at your own peril!\n\t      this.maxId = 0;\n\t\n\t      this.DynamicViews = [];\n\t\n\t      // events\n\t      this.events = {\n\t        'insert': [],\n\t        'update': [],\n\t        'pre-insert': [],\n\t        'pre-update': [],\n\t        'close': [],\n\t        'flushbuffer': [],\n\t        'error': [],\n\t        'delete': [],\n\t        'warning': []\n\t      };\n\t\n\t      // changes are tracked by collection and aggregated by the db\n\t      this.changes = [];\n\t\n\t      // initialize the id index\n\t      this.ensureId();\n\t      var indices = [];\n\t      // initialize optional user-supplied indices array ['age', 'lname', 'zip']\n\t      if (options && options.indices) {\n\t        if (Object.prototype.toString.call(options.indices) === '[object Array]') {\n\t          indices = options.indices;\n\t        } else if (typeof options.indices === 'string') {\n\t          indices = [options.indices];\n\t        } else {\n\t          throw new TypeError('Indices needs to be a string or an array of strings');\n\t        }\n\t      }\n\t\n\t      for (var idx = 0; idx < indices.length; idx++) {\n\t        this.ensureIndex(indices[idx]);\n\t      }\n\t\n\t      function observerCallback(changes) {\n\t\n\t        var changedObjects = typeof Set === 'function' ? new Set() : [];\n\t\n\t        if (!changedObjects.add) changedObjects.add = function (object) {\n\t          if (this.indexOf(object) === -1) this.push(object);\n\t          return this;\n\t        };\n\t\n\t        changes.forEach(function (change) {\n\t          changedObjects.add(change.object);\n\t        });\n\t\n\t        changedObjects.forEach(function (object) {\n\t          if (!hasOwnProperty.call(object, '$loki')) return self.removeAutoUpdateObserver(object);\n\t          try {\n\t            self.update(object);\n\t          } catch (err) {}\n\t        });\n\t      }\n\t\n\t      this.observerCallback = observerCallback;\n\t\n\t      /*\n\t       * This method creates a clone of the current status of an object and associates operation and collection name,\n\t       * so the parent db can aggregate and generate a changes object for the entire db\n\t       */\n\t      function createChange(name, op, obj) {\n\t        self.changes.push({\n\t          name: name,\n\t          operation: op,\n\t          obj: JSON.parse(JSON.stringify(obj))\n\t        });\n\t      }\n\t\n\t      // clear all the changes\n\t      function flushChanges() {\n\t        self.changes = [];\n\t      }\n\t\n\t      this.getChanges = function () {\n\t        return self.changes;\n\t      };\n\t\n\t      this.flushChanges = flushChanges;\n\t\n\t      /**\n\t       * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled\n\t       */\n\t      function insertMeta(obj) {\n\t        if (!obj) {\n\t          return;\n\t        }\n\t        if (!obj.meta) {\n\t          obj.meta = {};\n\t        }\n\t\n\t        obj.meta.created = new Date().getTime();\n\t        obj.meta.revision = 0;\n\t      }\n\t\n\t      function updateMeta(obj) {\n\t        if (!obj) {\n\t          return;\n\t        }\n\t        obj.meta.updated = new Date().getTime();\n\t        obj.meta.revision += 1;\n\t      }\n\t\n\t      function createInsertChange(obj) {\n\t        createChange(self.name, 'I', obj);\n\t      }\n\t\n\t      function createUpdateChange(obj) {\n\t        createChange(self.name, 'U', obj);\n\t      }\n\t\n\t      function insertMetaWithChange(obj) {\n\t        insertMeta(obj);\n\t        createInsertChange(obj);\n\t      }\n\t\n\t      function updateMetaWithChange(obj) {\n\t        updateMeta(obj);\n\t        createUpdateChange(obj);\n\t      }\n\t\n\t      /* assign correct handler based on ChangesAPI flag */\n\t      var insertHandler, updateHandler;\n\t\n\t      function setHandlers() {\n\t        insertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;\n\t        updateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;\n\t      }\n\t\n\t      setHandlers();\n\t\n\t      this.setChangesApi = function (enabled) {\n\t        self.disableChangesApi = !enabled;\n\t        setHandlers();\n\t      };\n\t      /**\n\t       * built-in events\n\t       */\n\t      this.on('insert', function insertCallback(obj) {\n\t        insertHandler(obj);\n\t      });\n\t\n\t      this.on('update', function updateCallback(obj) {\n\t        updateHandler(obj);\n\t      });\n\t\n\t      this.on('delete', function deleteCallback(obj) {\n\t        if (!self.disableChangesApi) {\n\t          createChange(self.name, 'R', obj);\n\t        }\n\t      });\n\t\n\t      this.on('warning', function (warning) {\n\t        self.console.warn(warning);\n\t      });\n\t      // for de-serialization purposes\n\t      flushChanges();\n\t    }\n\t\n\t    Collection.prototype = new LokiEventEmitter();\n\t\n\t    Collection.prototype.console = {\n\t      log: function () {},\n\t      warn: function () {},\n\t      error: function () {}\n\t    };\n\t\n\t    Collection.prototype.addAutoUpdateObserver = function (object) {\n\t      if (!this.autoupdate || typeof Object.observe !== 'function') return;\n\t\n\t      Object.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n\t    };\n\t\n\t    Collection.prototype.removeAutoUpdateObserver = function (object) {\n\t      if (!this.autoupdate || typeof Object.observe !== 'function') return;\n\t\n\t      Object.unobserve(object, this.observerCallback);\n\t    };\n\t\n\t    /**\n\t     * Adds a named collection transform to the collection\n\t     * @param {string} name - name to associate with transform\n\t     * @param {array} transform - an array of transformation 'step' objects to save into the collection\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.addTransform = function (name, transform) {\n\t      if (this.transforms.hasOwnProperty(name)) {\n\t        throw new Error(\"a transform by that name already exists\");\n\t      }\n\t\n\t      this.transforms[name] = transform;\n\t    };\n\t\n\t    /**\n\t     * Updates a named collection transform to the collection\n\t     * @param {string} name - name to associate with transform\n\t     * @param {object} transform - a transformation object to save into collection\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.setTransform = function (name, transform) {\n\t      this.transforms[name] = transform;\n\t    };\n\t\n\t    /**\n\t     * Removes a named collection transform from the collection\n\t     * @param {string} name - name of collection transform to remove\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.removeTransform = function (name) {\n\t      delete this.transforms[name];\n\t    };\n\t\n\t    Collection.prototype.byExample = function (template) {\n\t      var k, obj, query;\n\t      query = [];\n\t      for (k in template) {\n\t        if (!template.hasOwnProperty(k)) continue;\n\t        query.push((obj = {}, obj[k] = template[k], obj));\n\t      }\n\t      return {\n\t        '$and': query\n\t      };\n\t    };\n\t\n\t    Collection.prototype.findObject = function (template) {\n\t      return this.findOne(this.byExample(template));\n\t    };\n\t\n\t    Collection.prototype.findObjects = function (template) {\n\t      return this.find(this.byExample(template));\n\t    };\n\t\n\t    /*----------------------------+\n\t    | TTL daemon                  |\n\t    +----------------------------*/\n\t    Collection.prototype.ttlDaemonFuncGen = function () {\n\t      var collection = this;\n\t      var age = this.ttl.age;\n\t      return function ttlDaemon() {\n\t        var now = Date.now();\n\t        var toRemove = collection.chain().where(function daemonFilter(member) {\n\t          var timestamp = member.meta.updated || member.meta.created;\n\t          var diff = now - timestamp;\n\t          return age < diff;\n\t        });\n\t        toRemove.remove();\n\t      };\n\t    };\n\t\n\t    Collection.prototype.setTTL = function (age, interval) {\n\t      if (age < 0) {\n\t        clearInterval(this.ttl.daemon);\n\t      } else {\n\t        this.ttl.age = age;\n\t        this.ttl.ttlInterval = interval;\n\t        this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n\t      }\n\t    };\n\t\n\t    /*----------------------------+\n\t    | INDEXING                    |\n\t    +----------------------------*/\n\t\n\t    /**\n\t     * create a row filter that covers all documents in the collection\n\t     */\n\t    Collection.prototype.prepareFullDocIndex = function () {\n\t      var len = this.data.length;\n\t      var indexes = new Array(len);\n\t      for (var i = 0; i < len; i += 1) {\n\t        indexes[i] = i;\n\t      }\n\t      return indexes;\n\t    };\n\t\n\t    /**\n\t     * Will allow reconfiguring certain collection options.\n\t     * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.configureOptions = function (options) {\n\t      options = options || {};\n\t\n\t      if (options.hasOwnProperty('adaptiveBinaryIndices')) {\n\t        this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\t\n\t        // if switching to adaptive binary indices, make sure none are 'dirty'\n\t        if (this.adaptiveBinaryIndices) {\n\t          this.ensureAllIndexes();\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Ensure binary index on a certain field\n\t     * @param {string} property - name of property to create binary index on\n\t     * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.ensureIndex = function (property, force) {\n\t      // optional parameter to force rebuild whether flagged as dirty or not\n\t      if (typeof force === 'undefined') {\n\t        force = false;\n\t      }\n\t\n\t      if (property === null || property === undefined) {\n\t        throw new Error('Attempting to set index without an associated property');\n\t      }\n\t\n\t      if (this.binaryIndices[property] && !force) {\n\t        if (!this.binaryIndices[property].dirty) return;\n\t      }\n\t\n\t      var index = {\n\t        'name': property,\n\t        'dirty': true,\n\t        'values': this.prepareFullDocIndex()\n\t      };\n\t      this.binaryIndices[property] = index;\n\t\n\t      var wrappedComparer = function (p, data) {\n\t        return function (a, b) {\n\t          var objAp = data[a][p],\n\t              objBp = data[b][p];\n\t          if (objAp !== objBp) {\n\t            if (ltHelper(objAp, objBp, false)) return -1;\n\t            if (gtHelper(objAp, objBp, false)) return 1;\n\t          }\n\t          return 0;\n\t        };\n\t      }(property, this.data);\n\t\n\t      index.values.sort(wrappedComparer);\n\t      index.dirty = false;\n\t\n\t      this.dirty = true; // for autosave scenarios\n\t    };\n\t\n\t    Collection.prototype.getSequencedIndexValues = function (property) {\n\t      var idx,\n\t          idxvals = this.binaryIndices[property].values;\n\t      var result = \"\";\n\t\n\t      for (idx = 0; idx < idxvals.length; idx++) {\n\t        result += \" [\" + idx + \"] \" + this.data[idxvals[idx]][property];\n\t      }\n\t\n\t      return result;\n\t    };\n\t\n\t    Collection.prototype.ensureUniqueIndex = function (field) {\n\t      var index = this.constraints.unique[field];\n\t      if (!index) {\n\t        // keep track of new unique index for regenerate after database (re)load.\n\t        if (this.uniqueNames.indexOf(field) == -1) {\n\t          this.uniqueNames.push(field);\n\t        }\n\t      }\n\t\n\t      // if index already existed, (re)loading it will likely cause collisions, rebuild always\n\t      this.constraints.unique[field] = index = new UniqueIndex(field);\n\t      this.data.forEach(function (obj) {\n\t        index.set(obj);\n\t      });\n\t      return index;\n\t    };\n\t\n\t    /**\n\t     * Ensure all binary indices\n\t     */\n\t    Collection.prototype.ensureAllIndexes = function (force) {\n\t      var key,\n\t          bIndices = this.binaryIndices;\n\t      for (key in bIndices) {\n\t        if (hasOwnProperty.call(bIndices, key)) {\n\t          this.ensureIndex(key, force);\n\t        }\n\t      }\n\t    };\n\t\n\t    Collection.prototype.flagBinaryIndexesDirty = function () {\n\t      var key,\n\t          bIndices = this.binaryIndices;\n\t      for (key in bIndices) {\n\t        if (hasOwnProperty.call(bIndices, key)) {\n\t          bIndices[key].dirty = true;\n\t        }\n\t      }\n\t    };\n\t\n\t    Collection.prototype.flagBinaryIndexDirty = function (index) {\n\t      if (this.binaryIndices[index]) this.binaryIndices[index].dirty = true;\n\t    };\n\t\n\t    /**\n\t     * Quickly determine number of documents in collection (or query)\n\t     * @param {object=} query - (optional) query object to count results of\n\t     * @returns {number} number of documents in the collection\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.count = function (query) {\n\t      if (!query) {\n\t        return this.data.length;\n\t      }\n\t\n\t      return this.chain().find(query).filteredrows.length;\n\t    };\n\t\n\t    /**\n\t     * Rebuild idIndex\n\t     */\n\t    Collection.prototype.ensureId = function () {\n\t      var len = this.data.length,\n\t          i = 0;\n\t\n\t      this.idIndex = [];\n\t      for (i; i < len; i += 1) {\n\t        this.idIndex.push(this.data[i].$loki);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Add a dynamic view to the collection\n\t     * @param {string} name - name of dynamic view to add\n\t     * @param {object=} options - (optional) options to configure dynamic view with\n\t     * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t     * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t     * @returns {DynamicView} reference to the dynamic view added\n\t     * @memberof Collection\n\t     **/\n\t\n\t    Collection.prototype.addDynamicView = function (name, options) {\n\t      var dv = new DynamicView(this, name, options);\n\t      this.DynamicViews.push(dv);\n\t\n\t      return dv;\n\t    };\n\t\n\t    /**\n\t     * Remove a dynamic view from the collection\n\t     * @param {string} name - name of dynamic view to remove\n\t     * @memberof Collection\n\t     **/\n\t    Collection.prototype.removeDynamicView = function (name) {\n\t      for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t        if (this.DynamicViews[idx].name === name) {\n\t          this.DynamicViews.splice(idx, 1);\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Look up dynamic view reference from within the collection\n\t     * @param {string} name - name of dynamic view to retrieve reference of\n\t     * @returns {DynamicView} A reference to the dynamic view with that name\n\t     * @memberof Collection\n\t     **/\n\t    Collection.prototype.getDynamicView = function (name) {\n\t      for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t        if (this.DynamicViews[idx].name === name) {\n\t          return this.DynamicViews[idx];\n\t        }\n\t      }\n\t\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * find and update: pass a filtering function to select elements to be updated\n\t     * and apply the updatefunctino to those elements iteratively\n\t     * @param {function} filterFunction - filter function whose results will execute update\n\t     * @param {function} updateFunction - update function to run against filtered documents\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.findAndUpdate = function (filterFunction, updateFunction) {\n\t      var results = this.where(filterFunction),\n\t          i = 0,\n\t          obj;\n\t      try {\n\t        for (i; i < results.length; i++) {\n\t          obj = updateFunction(results[i]);\n\t          this.update(obj);\n\t        }\n\t      } catch (err) {\n\t        this.rollback();\n\t        this.console.error(err.message);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n\t     * @param {(object|array)} doc - the document (or array of documents) to be inserted\n\t     * @returns {(object|array)} document or documents inserted\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.insert = function (doc) {\n\t      if (!Array.isArray(doc)) {\n\t        return this.insertOne(doc);\n\t      }\n\t\n\t      // holder to the clone of the object inserted if collections is set to clone objects\n\t      var obj;\n\t      var results = [];\n\t\n\t      this.emit('pre-insert', doc);\n\t      for (var i = 0, len = doc.length; i < len; i++) {\n\t        obj = this.insertOne(doc[i], true);\n\t        if (!obj) {\n\t          return undefined;\n\t        }\n\t        results.push(obj);\n\t      }\n\t      this.emit('insert', doc);\n\t      return results.length === 1 ? results[0] : results;\n\t    };\n\t\n\t    /**\n\t     * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n\t     * @param {object} doc - the document to be inserted\n\t     * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n\t     * @returns {object} document or 'undefined' if there was a problem inserting it\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.insertOne = function (doc, bulkInsert) {\n\t      var err = null;\n\t      var returnObj;\n\t\n\t      if (typeof doc !== 'object') {\n\t        err = new TypeError('Document needs to be an object');\n\t      } else if (doc === null) {\n\t        err = new TypeError('Object cannot be null');\n\t      }\n\t\n\t      if (err !== null) {\n\t        this.emit('error', err);\n\t        throw err;\n\t      }\n\t\n\t      // if configured to clone, do so now... otherwise just use same obj reference\n\t      var obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\t\n\t      if (typeof obj.meta === 'undefined') {\n\t        obj.meta = {\n\t          revision: 0,\n\t          created: 0\n\t        };\n\t      }\n\t\n\t      // if cloning, give user back clone of 'cloned' object with $loki and meta\n\t      returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\t\n\t      // allow pre-insert to modify actual collection reference even if cloning\n\t      if (!bulkInsert) {\n\t        this.emit('pre-insert', obj);\n\t      }\n\t      if (!this.add(obj)) {\n\t        return undefined;\n\t      }\n\t\n\t      this.addAutoUpdateObserver(returnObj);\n\t      if (!bulkInsert) {\n\t        this.emit('insert', returnObj);\n\t      }\n\t      return returnObj;\n\t    };\n\t\n\t    /**\n\t     * Empties the collection.\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.clear = function () {\n\t      this.data = [];\n\t      this.idIndex = [];\n\t      this.binaryIndices = {};\n\t      this.cachedIndex = null;\n\t      this.cachedBinaryIndex = null;\n\t      this.cachedData = null;\n\t      this.maxId = 0;\n\t      this.DynamicViews = [];\n\t      this.dirty = true;\n\t    };\n\t\n\t    /**\n\t     * Updates an object and notifies collection that the document has changed.\n\t     * @param {object} doc - document to update within the collection\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.update = function (doc) {\n\t      if (Array.isArray(doc)) {\n\t        var k = 0,\n\t            len = doc.length;\n\t        for (k; k < len; k += 1) {\n\t          this.update(doc[k]);\n\t        }\n\t        return;\n\t      }\n\t\n\t      // verify object is a properly formed document\n\t      if (!hasOwnProperty.call(doc, '$loki')) {\n\t        throw new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n\t      }\n\t      try {\n\t        this.startTransaction();\n\t        var arr = this.get(doc.$loki, true),\n\t            oldInternal,\n\t            // ref to existing obj\n\t        newInternal,\n\t            // ref to new internal obj\n\t        position,\n\t            self = this;\n\t\n\t        oldInternal = arr[0]; // -internal- obj ref\n\t        position = arr[1]; // position in data array\n\t\n\t        // if configured to clone, do so now... otherwise just use same obj reference\n\t        newInternal = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\t\n\t        if (!arr) {\n\t          throw new Error('Trying to update a document not in collection.');\n\t        }\n\t        this.emit('pre-update', doc);\n\t\n\t        Object.keys(this.constraints.unique).forEach(function (key) {\n\t          self.constraints.unique[key].update(oldInternal, newInternal);\n\t        });\n\t\n\t        // operate the update\n\t        this.data[position] = newInternal;\n\t\n\t        if (newInternal !== doc) {\n\t          this.addAutoUpdateObserver(doc);\n\t        }\n\t\n\t        // now that we can efficiently determine the data[] position of newly added document,\n\t        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t          this.DynamicViews[idx].evaluateDocument(position, false);\n\t        }\n\t\n\t        var key;\n\t        if (this.adaptiveBinaryIndices) {\n\t          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t          var bIndices = this.binaryIndices;\n\t          for (key in bIndices) {\n\t            this.adaptiveBinaryIndexUpdate(position, key);\n\t          }\n\t        } else {\n\t          this.flagBinaryIndexesDirty();\n\t        }\n\t\n\t        this.idIndex[position] = newInternal.$loki;\n\t        //this.flagBinaryIndexesDirty();\n\t\n\t        this.commit();\n\t        this.dirty = true; // for autosave scenarios\n\t\n\t        this.emit('update', doc, this.cloneObjects ? clone(oldInternal, this.cloneMethod) : null);\n\t        return doc;\n\t      } catch (err) {\n\t        this.rollback();\n\t        this.console.error(err.message);\n\t        this.emit('error', err);\n\t        throw err; // re-throw error so user does not think it succeeded\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Add object to collection\n\t     */\n\t    Collection.prototype.add = function (obj) {\n\t      // if parameter isn't object exit with throw\n\t      if ('object' !== typeof obj) {\n\t        throw new TypeError('Object being added needs to be an object');\n\t      }\n\t      // if object you are adding already has id column it is either already in the collection\n\t      // or the object is carrying its own 'id' property.  If it also has a meta property,\n\t      // then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n\t      if (typeof obj.$loki !== 'undefined') {\n\t        throw new Error('Document is already in collection, please use update()');\n\t      }\n\t\n\t      /*\n\t       * try adding object to collection\n\t       */\n\t      try {\n\t        this.startTransaction();\n\t        this.maxId++;\n\t\n\t        if (isNaN(this.maxId)) {\n\t          this.maxId = this.data[this.data.length - 1].$loki + 1;\n\t        }\n\t\n\t        obj.$loki = this.maxId;\n\t        obj.meta.version = 0;\n\t\n\t        var key,\n\t            constrUnique = this.constraints.unique;\n\t        for (key in constrUnique) {\n\t          if (hasOwnProperty.call(constrUnique, key)) {\n\t            constrUnique[key].set(obj);\n\t          }\n\t        }\n\t\n\t        // add new obj id to idIndex\n\t        this.idIndex.push(obj.$loki);\n\t\n\t        // add the object\n\t        this.data.push(obj);\n\t\n\t        var addedPos = this.data.length - 1;\n\t\n\t        // now that we can efficiently determine the data[] position of newly added document,\n\t        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t        var dvlen = this.DynamicViews.length;\n\t        for (var i = 0; i < dvlen; i++) {\n\t          this.DynamicViews[i].evaluateDocument(addedPos, true);\n\t        }\n\t\n\t        if (this.adaptiveBinaryIndices) {\n\t          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t          var bIndices = this.binaryIndices;\n\t          for (key in bIndices) {\n\t            this.adaptiveBinaryIndexInsert(addedPos, key);\n\t          }\n\t        } else {\n\t          this.flagBinaryIndexesDirty();\n\t        }\n\t\n\t        this.commit();\n\t        this.dirty = true; // for autosave scenarios\n\t\n\t        return this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\t      } catch (err) {\n\t        this.rollback();\n\t        this.console.error(err.message);\n\t        this.emit('error', err);\n\t        throw err; // re-throw error so user does not think it succeeded\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Remove all documents matching supplied filter object\n\t     * @param {object} query - query object to filter on\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.removeWhere = function (query) {\n\t      var list;\n\t      if (typeof query === 'function') {\n\t        list = this.data.filter(query);\n\t      } else {\n\t        list = new Resultset(this, {\n\t          queryObj: query\n\t        });\n\t      }\n\t      this.remove(list);\n\t    };\n\t\n\t    Collection.prototype.removeDataOnly = function () {\n\t      this.remove(this.data.slice());\n\t    };\n\t\n\t    /**\n\t     * Remove a document from the collection\n\t     * @param {object} doc - document to remove from collection\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.remove = function (doc) {\n\t      if (typeof doc === 'number') {\n\t        doc = this.get(doc);\n\t      }\n\t\n\t      if ('object' !== typeof doc) {\n\t        throw new Error('Parameter is not an object');\n\t      }\n\t      if (Array.isArray(doc)) {\n\t        var k = 0,\n\t            len = doc.length;\n\t        for (k; k < len; k += 1) {\n\t          this.remove(doc[k]);\n\t        }\n\t        return;\n\t      }\n\t\n\t      if (!hasOwnProperty.call(doc, '$loki')) {\n\t        throw new Error('Object is not a document stored in the collection');\n\t      }\n\t\n\t      try {\n\t        this.startTransaction();\n\t        var arr = this.get(doc.$loki, true),\n\t\n\t        // obj = arr[0],\n\t        position = arr[1];\n\t        var self = this;\n\t        Object.keys(this.constraints.unique).forEach(function (key) {\n\t          if (doc[key] !== null && typeof doc[key] !== 'undefined') {\n\t            self.constraints.unique[key].remove(doc[key]);\n\t          }\n\t        });\n\t        // now that we can efficiently determine the data[] position of newly added document,\n\t        // submit it for all registered DynamicViews to remove\n\t        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t          this.DynamicViews[idx].removeDocument(position);\n\t        }\n\t\n\t        if (this.adaptiveBinaryIndices) {\n\t          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t          var key,\n\t              bIndices = this.binaryIndices;\n\t          for (key in bIndices) {\n\t            this.adaptiveBinaryIndexRemove(position, key);\n\t          }\n\t        } else {\n\t          this.flagBinaryIndexesDirty();\n\t        }\n\t\n\t        this.data.splice(position, 1);\n\t        this.removeAutoUpdateObserver(doc);\n\t\n\t        // remove id from idIndex\n\t        this.idIndex.splice(position, 1);\n\t\n\t        this.commit();\n\t        this.dirty = true; // for autosave scenarios\n\t        this.emit('delete', arr[0]);\n\t        delete doc.$loki;\n\t        delete doc.meta;\n\t        return doc;\n\t      } catch (err) {\n\t        this.rollback();\n\t        this.console.error(err.message);\n\t        this.emit('error', err);\n\t        return null;\n\t      }\n\t    };\n\t\n\t    /*---------------------+\n\t    | Finding methods     |\n\t    +----------------------*/\n\t\n\t    /**\n\t     * Get by Id - faster than other methods because of the searching algorithm\n\t     * @param {int} id - $loki id of document you want to retrieve\n\t     * @param {boolean} returnPosition - if 'true' we will return [object, position]\n\t     * @returns {(object|array|null)} Object reference if document was found, null if not,\n\t     *     or an array if 'returnPosition' was passed.\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.get = function (id, returnPosition) {\n\t      var retpos = returnPosition || false,\n\t          data = this.idIndex,\n\t          max = data.length - 1,\n\t          min = 0,\n\t          mid = min + max >> 1;\n\t\n\t      id = typeof id === 'number' ? id : parseInt(id, 10);\n\t\n\t      if (isNaN(id)) {\n\t        throw new TypeError('Passed id is not an integer');\n\t      }\n\t\n\t      while (data[min] < data[max]) {\n\t        mid = min + max >> 1;\n\t\n\t        if (data[mid] < id) {\n\t          min = mid + 1;\n\t        } else {\n\t          max = mid;\n\t        }\n\t      }\n\t\n\t      if (max === min && data[min] === id) {\n\t        if (retpos) {\n\t          return [this.data[min], min];\n\t        }\n\t        return this.data[min];\n\t      }\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n\t     *    Since multiple documents may contain the same value (which the index is sorted on),\n\t     *    we hone in on range and then linear scan range to find exact index array position.\n\t     * @param {int} dataPosition : coll.data array index/position\n\t     * @param {string} binaryIndexName : index to search for dataPosition in\n\t     */\n\t    Collection.prototype.getBinaryIndexPosition = function (dataPosition, binaryIndexName) {\n\t      var val = this.data[dataPosition][binaryIndexName];\n\t      var index = this.binaryIndices[binaryIndexName].values;\n\t\n\t      // i think calculateRange can probably be moved to collection\n\t      // as it doesn't seem to need resultset.  need to verify\n\t      //var rs = new Resultset(this, null, null);\n\t      var range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\t\n\t      if (range[0] === 0 && range[1] === -1) {\n\t        // uhoh didn't find range\n\t        return null;\n\t      }\n\t\n\t      var min = range[0];\n\t      var max = range[1];\n\t\n\t      // narrow down the sub-segment of index values\n\t      // where the indexed property value exactly matches our\n\t      // value and then linear scan to find exact -index- position\n\t      for (var idx = min; idx <= max; idx++) {\n\t        if (index[idx] === dataPosition) return idx;\n\t      }\n\t\n\t      // uhoh\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * Adaptively insert a selected item to the index.\n\t     * @param {int} dataPosition : coll.data array index/position\n\t     * @param {string} binaryIndexName : index to search for dataPosition in\n\t     */\n\t    Collection.prototype.adaptiveBinaryIndexInsert = function (dataPosition, binaryIndexName) {\n\t      var index = this.binaryIndices[binaryIndexName].values;\n\t      var val = this.data[dataPosition][binaryIndexName];\n\t      //var rs = new Resultset(this, null, null);\n\t      var idxPos = this.calculateRangeStart(binaryIndexName, val);\n\t\n\t      // insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n\t      // doing this after adjusting dataPositions so no clash with previous item at that position.\n\t      this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n\t    };\n\t\n\t    /**\n\t     * Adaptively update a selected item within an index.\n\t     * @param {int} dataPosition : coll.data array index/position\n\t     * @param {string} binaryIndexName : index to search for dataPosition in\n\t     */\n\t    Collection.prototype.adaptiveBinaryIndexUpdate = function (dataPosition, binaryIndexName) {\n\t      // linear scan needed to find old position within index unless we optimize for clone scenarios later\n\t      // within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n\t      var idxPos,\n\t          index = this.binaryIndices[binaryIndexName].values,\n\t          len = index.length;\n\t\n\t      for (idxPos = 0; idxPos < len; idxPos++) {\n\t        if (index[idxPos] === dataPosition) break;\n\t      }\n\t\n\t      //var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n\t      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\t\n\t      //this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n\t      this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n\t    };\n\t\n\t    /**\n\t     * Adaptively remove a selected item from the index.\n\t     * @param {int} dataPosition : coll.data array index/position\n\t     * @param {string} binaryIndexName : index to search for dataPosition in\n\t     */\n\t    Collection.prototype.adaptiveBinaryIndexRemove = function (dataPosition, binaryIndexName, removedFromIndexOnly) {\n\t      var idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\t      var index = this.binaryIndices[binaryIndexName].values;\n\t      var len, idx;\n\t\n\t      if (idxPos === null) {\n\t        // throw new Error('unable to determine binary index position');\n\t        return null;\n\t      }\n\t\n\t      // remove document from index\n\t      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\t\n\t      // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n\t      // in which case data positions stay the same.\n\t      if (removedFromIndexOnly === true) {\n\t        return;\n\t      }\n\t\n\t      // since index stores data array positions, if we remove a document\n\t      // we need to adjust array positions -1 for all document positions greater than removed position\n\t      len = index.length;\n\t      for (idx = 0; idx < len; idx++) {\n\t        if (index[idx] > dataPosition) {\n\t          index[idx]--;\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Internal method used for index maintenance.  Given a prop (index name), and a value\n\t     * (which may or may not yet exist) this will find the proper location where it can be added.\n\t     */\n\t    Collection.prototype.calculateRangeStart = function (prop, val) {\n\t      var rcd = this.data;\n\t      var index = this.binaryIndices[prop].values;\n\t      var min = 0;\n\t      var max = index.length - 1;\n\t      var mid = 0;\n\t\n\t      if (index.length === 0) {\n\t        return 0;\n\t      }\n\t\n\t      var minVal = rcd[index[min]][prop];\n\t      var maxVal = rcd[index[max]][prop];\n\t\n\t      // hone in on start position of value\n\t      while (min < max) {\n\t        mid = min + max >> 1;\n\t\n\t        if (ltHelper(rcd[index[mid]][prop], val, false)) {\n\t          min = mid + 1;\n\t        } else {\n\t          max = mid;\n\t        }\n\t      }\n\t\n\t      var lbound = min;\n\t\n\t      if (ltHelper(rcd[index[lbound]][prop], val, false)) {\n\t        return lbound + 1;\n\t      } else {\n\t        return lbound;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n\t     *    this is used for collection.find() and first find filter of resultset/dynview\n\t     *    slightly different than get() binary search in that get() hones in on 1 value,\n\t     *    but we have to hone in on many (range)\n\t     * @param {string} op - operation, such as $eq\n\t     * @param {string} prop - name of property to calculate range for\n\t     * @param {object} val - value to use for range calculation.\n\t     * @returns {array} [start, end] index array positions\n\t     */\n\t    Collection.prototype.calculateRange = function (op, prop, val) {\n\t      var rcd = this.data;\n\t      var index = this.binaryIndices[prop].values;\n\t      var min = 0;\n\t      var max = index.length - 1;\n\t      var mid = 0;\n\t\n\t      // when no documents are in collection, return empty range condition\n\t      if (rcd.length === 0) {\n\t        return [0, -1];\n\t      }\n\t\n\t      var minVal = rcd[index[min]][prop];\n\t      var maxVal = rcd[index[max]][prop];\n\t\n\t      // if value falls outside of our range return [0, -1] to designate no results\n\t      switch (op) {\n\t        case '$eq':\n\t        case '$aeq':\n\t          if (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t            return [0, -1];\n\t          }\n\t          break;\n\t        case '$dteq':\n\t          if (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t            return [0, -1];\n\t          }\n\t          break;\n\t        case '$gt':\n\t          if (gtHelper(val, maxVal, true)) {\n\t            return [0, -1];\n\t          }\n\t          break;\n\t        case '$gte':\n\t          if (gtHelper(val, maxVal, false)) {\n\t            return [0, -1];\n\t          }\n\t          break;\n\t        case '$lt':\n\t          if (ltHelper(val, minVal, true)) {\n\t            return [0, -1];\n\t          }\n\t          if (ltHelper(maxVal, val, false)) {\n\t            return [0, rcd.length - 1];\n\t          }\n\t          break;\n\t        case '$lte':\n\t          if (ltHelper(val, minVal, false)) {\n\t            return [0, -1];\n\t          }\n\t          if (ltHelper(maxVal, val, true)) {\n\t            return [0, rcd.length - 1];\n\t          }\n\t          break;\n\t      }\n\t\n\t      // hone in on start position of value\n\t      while (min < max) {\n\t        mid = min + max >> 1;\n\t\n\t        if (ltHelper(rcd[index[mid]][prop], val, false)) {\n\t          min = mid + 1;\n\t        } else {\n\t          max = mid;\n\t        }\n\t      }\n\t\n\t      var lbound = min;\n\t\n\t      // do not reset min, as the upper bound cannot be prior to the found low bound\n\t      max = index.length - 1;\n\t\n\t      // hone in on end position of value\n\t      while (min < max) {\n\t        mid = min + max >> 1;\n\t\n\t        if (ltHelper(val, rcd[index[mid]][prop], false)) {\n\t          max = mid;\n\t        } else {\n\t          min = mid + 1;\n\t        }\n\t      }\n\t\n\t      var ubound = max;\n\t\n\t      var lval = rcd[index[lbound]][prop];\n\t      var uval = rcd[index[ubound]][prop];\n\t\n\t      switch (op) {\n\t        case '$eq':\n\t          if (lval !== val) {\n\t            return [0, -1];\n\t          }\n\t          if (uval !== val) {\n\t            ubound--;\n\t          }\n\t\n\t          return [lbound, ubound];\n\t        case '$dteq':\n\t          if (lval > val || lval < val) {\n\t            return [0, -1];\n\t          }\n\t          if (uval > val || uval < val) {\n\t            ubound--;\n\t          }\n\t\n\t          return [lbound, ubound];\n\t\n\t        case '$gt':\n\t          if (ltHelper(uval, val, true)) {\n\t            return [0, -1];\n\t          }\n\t\n\t          return [ubound, rcd.length - 1];\n\t\n\t        case '$gte':\n\t          if (ltHelper(lval, val, false)) {\n\t            return [0, -1];\n\t          }\n\t\n\t          return [lbound, rcd.length - 1];\n\t\n\t        case '$lt':\n\t          if (lbound === 0 && ltHelper(lval, val, false)) {\n\t            return [0, 0];\n\t          }\n\t          return [0, lbound - 1];\n\t\n\t        case '$lte':\n\t          if (uval !== val) {\n\t            ubound--;\n\t          }\n\t\n\t          if (ubound === 0 && ltHelper(uval, val, false)) {\n\t            return [0, 0];\n\t          }\n\t          return [0, ubound];\n\t\n\t        default:\n\t          return [0, rcd.length - 1];\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Retrieve doc by Unique index\n\t     * @param {string} field - name of uniquely indexed property to use when doing lookup\n\t     * @param {value} value - unique value to search for\n\t     * @returns {object} document matching the value passed\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.by = function (field, value) {\n\t      var self;\n\t      if (value === undefined) {\n\t        self = this;\n\t        return function (value) {\n\t          return self.by(field, value);\n\t        };\n\t      }\n\t\n\t      var result = this.constraints.unique[field].get(value);\n\t      if (!this.cloneObjects) {\n\t        return result;\n\t      } else {\n\t        return clone(result, this.cloneMethod);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Find one object by index property, by property equal to value\n\t     * @param {object} query - query object used to perform search with\n\t     * @returns {(object|null)} First matching document, or null if none\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.findOne = function (query) {\n\t      query = query || {};\n\t\n\t      // Instantiate Resultset and exec find op passing firstOnly = true param\n\t      var result = new Resultset(this, {\n\t        queryObj: query,\n\t        firstOnly: true\n\t      });\n\t\n\t      if (Array.isArray(result) && result.length === 0) {\n\t        return null;\n\t      } else {\n\t        if (!this.cloneObjects) {\n\t          return result;\n\t        } else {\n\t          return clone(result, this.cloneMethod);\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Chain method, used for beginning a series of chained find() and/or view() operations\n\t     * on a collection.\n\t     *\n\t     * @param {array} transform - Ordered array of transform step objects similar to chain\n\t     * @param {object} parameters - Object containing properties representing parameters to substitute\n\t     * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.chain = function (transform, parameters) {\n\t      var rs = new Resultset(this);\n\t\n\t      if (typeof transform === 'undefined') {\n\t        return rs;\n\t      }\n\t\n\t      return rs.transform(transform, parameters);\n\t    };\n\t\n\t    /**\n\t     * Find method, api is similar to mongodb.\n\t     * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n\t     * @example {@tutorial Query Examples}\n\t     * @param {object} query - 'mongo-like' query object\n\t     * @returns {array} Array of matching documents\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.find = function (query) {\n\t      if (typeof query === 'undefined') {\n\t        query = 'getAll';\n\t      }\n\t\n\t      var results = new Resultset(this, {\n\t        queryObj: query\n\t      });\n\t      if (!this.cloneObjects) {\n\t        return results;\n\t      } else {\n\t        return cloneObjectArray(results, this.cloneMethod);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Find object by unindexed field by property equal to value,\n\t     * simply iterates and returns the first element matching the query\n\t     */\n\t    Collection.prototype.findOneUnindexed = function (prop, value) {\n\t      var i = this.data.length,\n\t          doc;\n\t      while (i--) {\n\t        if (this.data[i][prop] === value) {\n\t          doc = this.data[i];\n\t          return doc;\n\t        }\n\t      }\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * Transaction methods\n\t     */\n\t\n\t    /** start the transation */\n\t    Collection.prototype.startTransaction = function () {\n\t      if (this.transactional) {\n\t        this.cachedData = clone(this.data, this.cloneMethod);\n\t        this.cachedIndex = this.idIndex;\n\t        this.cachedBinaryIndex = this.binaryIndices;\n\t\n\t        // propagate startTransaction to dynamic views\n\t        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t          this.DynamicViews[idx].startTransaction();\n\t        }\n\t      }\n\t    };\n\t\n\t    /** commit the transation */\n\t    Collection.prototype.commit = function () {\n\t      if (this.transactional) {\n\t        this.cachedData = null;\n\t        this.cachedIndex = null;\n\t        this.cachedBinaryIndex = null;\n\t\n\t        // propagate commit to dynamic views\n\t        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t          this.DynamicViews[idx].commit();\n\t        }\n\t      }\n\t    };\n\t\n\t    /** roll back the transation */\n\t    Collection.prototype.rollback = function () {\n\t      if (this.transactional) {\n\t        if (this.cachedData !== null && this.cachedIndex !== null) {\n\t          this.data = this.cachedData;\n\t          this.idIndex = this.cachedIndex;\n\t          this.binaryIndices = this.cachedBinaryIndex;\n\t        }\n\t\n\t        // propagate rollback to dynamic views\n\t        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t          this.DynamicViews[idx].rollback();\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Query the collection by supplying a javascript filter function.\n\t     * @example\n\t     * var results = coll.where(function(obj) {\n\t     *   return obj.legs === 8;\n\t     * });\n\t     *\n\t     * @param {function} fun - filter function to run against all collection docs\n\t     * @returns {array} all documents which pass your filter function\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.where = function (fun) {\n\t      var results = new Resultset(this, {\n\t        queryFunc: fun\n\t      });\n\t      if (!this.cloneObjects) {\n\t        return results;\n\t      } else {\n\t        return cloneObjectArray(results, this.cloneMethod);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Map Reduce operation\n\t     *\n\t     * @param {function} mapFunction - function to use as map function\n\t     * @param {function} reduceFunction - function to use as reduce function\n\t     * @returns {data} The result of your mapReduce operation\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.mapReduce = function (mapFunction, reduceFunction) {\n\t      try {\n\t        return reduceFunction(this.data.map(mapFunction));\n\t      } catch (err) {\n\t        throw err;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * Join two collections on specified properties\n\t     *\n\t     * @param {array} joinData - array of documents to 'join' to this collection\n\t     * @param {string} leftJoinProp - property name in collection\n\t     * @param {string} rightJoinProp - property name in joinData\n\t     * @param {function=} mapFun - (Optional) map function to use\n\t     * @returns {Resultset} Result of the mapping operation\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.eqJoin = function (joinData, leftJoinProp, rightJoinProp, mapFun) {\n\t      // logic in Resultset class\n\t      return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);\n\t    };\n\t\n\t    /* ------ STAGING API -------- */\n\t    /**\n\t     * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t     * manipulated without affecting the data in the original collection\n\t     */\n\t    Collection.prototype.stages = {};\n\t\n\t    /**\n\t     * (Staging API) create a stage and/or retrieve it\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.getStage = function (name) {\n\t      if (!this.stages[name]) {\n\t        this.stages[name] = {};\n\t      }\n\t      return this.stages[name];\n\t    };\n\t    /**\n\t     * a collection of objects recording the changes applied through a commmitStage\n\t     */\n\t    Collection.prototype.commitLog = [];\n\t\n\t    /**\n\t     * (Staging API) create a copy of an object and insert it into a stage\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.stage = function (stageName, obj) {\n\t      var copy = JSON.parse(JSON.stringify(obj));\n\t      this.getStage(stageName)[obj.$loki] = copy;\n\t      return copy;\n\t    };\n\t\n\t    /**\n\t     * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n\t     * then create a message to be inserted in the commitlog\n\t     * @param {string} stageName - name of stage\n\t     * @param {string} message\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.commitStage = function (stageName, message) {\n\t      var stage = this.getStage(stageName),\n\t          prop,\n\t          timestamp = new Date().getTime();\n\t\n\t      for (prop in stage) {\n\t\n\t        this.update(stage[prop]);\n\t        this.commitLog.push({\n\t          timestamp: timestamp,\n\t          message: message,\n\t          data: JSON.parse(JSON.stringify(stage[prop]))\n\t        });\n\t      }\n\t      this.stages[stageName] = {};\n\t    };\n\t\n\t    Collection.prototype.no_op = function () {\n\t      return;\n\t    };\n\t\n\t    /**\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.extract = function (field) {\n\t      var i = 0,\n\t          len = this.data.length,\n\t          isDotNotation = isDeepProperty(field),\n\t          result = [];\n\t      for (i; i < len; i += 1) {\n\t        result.push(deepProperty(this.data[i], field, isDotNotation));\n\t      }\n\t      return result;\n\t    };\n\t\n\t    /**\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.max = function (field) {\n\t      return Math.max.apply(null, this.extract(field));\n\t    };\n\t\n\t    /**\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.min = function (field) {\n\t      return Math.min.apply(null, this.extract(field));\n\t    };\n\t\n\t    /**\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.maxRecord = function (field) {\n\t      var i = 0,\n\t          len = this.data.length,\n\t          deep = isDeepProperty(field),\n\t          result = {\n\t        index: 0,\n\t        value: undefined\n\t      },\n\t          max;\n\t\n\t      for (i; i < len; i += 1) {\n\t        if (max !== undefined) {\n\t          if (max < deepProperty(this.data[i], field, deep)) {\n\t            max = deepProperty(this.data[i], field, deep);\n\t            result.index = this.data[i].$loki;\n\t          }\n\t        } else {\n\t          max = deepProperty(this.data[i], field, deep);\n\t          result.index = this.data[i].$loki;\n\t        }\n\t      }\n\t      result.value = max;\n\t      return result;\n\t    };\n\t\n\t    /**\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.minRecord = function (field) {\n\t      var i = 0,\n\t          len = this.data.length,\n\t          deep = isDeepProperty(field),\n\t          result = {\n\t        index: 0,\n\t        value: undefined\n\t      },\n\t          min;\n\t\n\t      for (i; i < len; i += 1) {\n\t        if (min !== undefined) {\n\t          if (min > deepProperty(this.data[i], field, deep)) {\n\t            min = deepProperty(this.data[i], field, deep);\n\t            result.index = this.data[i].$loki;\n\t          }\n\t        } else {\n\t          min = deepProperty(this.data[i], field, deep);\n\t          result.index = this.data[i].$loki;\n\t        }\n\t      }\n\t      result.value = min;\n\t      return result;\n\t    };\n\t\n\t    /**\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.extractNumerical = function (field) {\n\t      return this.extract(field).map(parseBase10).filter(Number).filter(function (n) {\n\t        return !isNaN(n);\n\t      });\n\t    };\n\t\n\t    /**\n\t     * Calculates the average numerical value of a property\n\t     *\n\t     * @param {string} field - name of property in docs to average\n\t     * @returns {number} average of property in all docs in the collection\n\t     * @memberof Collection\n\t     */\n\t    Collection.prototype.avg = function (field) {\n\t      return average(this.extractNumerical(field));\n\t    };\n\t\n\t    /**\n\t     * Calculate standard deviation of a field\n\t     * @memberof Collection\n\t     * @param {string} field\n\t     */\n\t    Collection.prototype.stdDev = function (field) {\n\t      return standardDeviation(this.extractNumerical(field));\n\t    };\n\t\n\t    /**\n\t     * @memberof Collection\n\t     * @param {string} field\n\t     */\n\t    Collection.prototype.mode = function (field) {\n\t      var dict = {},\n\t          data = this.extract(field);\n\t      data.forEach(function (obj) {\n\t        if (dict[obj]) {\n\t          dict[obj] += 1;\n\t        } else {\n\t          dict[obj] = 1;\n\t        }\n\t      });\n\t      var max, prop, mode;\n\t      for (prop in dict) {\n\t        if (max) {\n\t          if (max < dict[prop]) {\n\t            mode = prop;\n\t          }\n\t        } else {\n\t          mode = prop;\n\t          max = dict[prop];\n\t        }\n\t      }\n\t      return mode;\n\t    };\n\t\n\t    /**\n\t     * @memberof Collection\n\t     * @param {string} field - property name\n\t     */\n\t    Collection.prototype.median = function (field) {\n\t      var values = this.extractNumerical(field);\n\t      values.sort(sub);\n\t\n\t      var half = Math.floor(values.length / 2);\n\t\n\t      if (values.length % 2) {\n\t        return values[half];\n\t      } else {\n\t        return (values[half - 1] + values[half]) / 2.0;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * General utils, including statistical functions\n\t     */\n\t    function isDeepProperty(field) {\n\t      return field.indexOf('.') !== -1;\n\t    }\n\t\n\t    function parseBase10(num) {\n\t      return parseFloat(num, 10);\n\t    }\n\t\n\t    function isNotUndefined(obj) {\n\t      return obj !== undefined;\n\t    }\n\t\n\t    function add(a, b) {\n\t      return a + b;\n\t    }\n\t\n\t    function sub(a, b) {\n\t      return a - b;\n\t    }\n\t\n\t    function median(values) {\n\t      values.sort(sub);\n\t      var half = Math.floor(values.length / 2);\n\t      return values.length % 2 ? values[half] : (values[half - 1] + values[half]) / 2.0;\n\t    }\n\t\n\t    function average(array) {\n\t      return array.reduce(add, 0) / array.length;\n\t    }\n\t\n\t    function standardDeviation(values) {\n\t      var avg = average(values);\n\t      var squareDiffs = values.map(function (value) {\n\t        var diff = value - avg;\n\t        var sqrDiff = diff * diff;\n\t        return sqrDiff;\n\t      });\n\t\n\t      var avgSquareDiff = average(squareDiffs);\n\t\n\t      var stdDev = Math.sqrt(avgSquareDiff);\n\t      return stdDev;\n\t    }\n\t\n\t    function deepProperty(obj, property, isDeep) {\n\t      if (isDeep === false) {\n\t        // pass without processing\n\t        return obj[property];\n\t      }\n\t      var pieces = property.split('.'),\n\t          root = obj;\n\t      while (pieces.length > 0) {\n\t        root = root[pieces.shift()];\n\t      }\n\t      return root;\n\t    }\n\t\n\t    function binarySearch(array, item, fun) {\n\t      var lo = 0,\n\t          hi = array.length,\n\t          compared,\n\t          mid;\n\t      while (lo < hi) {\n\t        mid = lo + hi >> 1;\n\t        compared = fun.apply(null, [item, array[mid]]);\n\t        if (compared === 0) {\n\t          return {\n\t            found: true,\n\t            index: mid\n\t          };\n\t        } else if (compared < 0) {\n\t          hi = mid;\n\t        } else {\n\t          lo = mid + 1;\n\t        }\n\t      }\n\t      return {\n\t        found: false,\n\t        index: hi\n\t      };\n\t    }\n\t\n\t    function BSonSort(fun) {\n\t      return function (array, item) {\n\t        return binarySearch(array, item, fun);\n\t      };\n\t    }\n\t\n\t    function KeyValueStore() {}\n\t\n\t    KeyValueStore.prototype = {\n\t      keys: [],\n\t      values: [],\n\t      sort: function (a, b) {\n\t        return a < b ? -1 : a > b ? 1 : 0;\n\t      },\n\t      setSort: function (fun) {\n\t        this.bs = new BSonSort(fun);\n\t      },\n\t      bs: function () {\n\t        return new BSonSort(this.sort);\n\t      },\n\t      set: function (key, value) {\n\t        var pos = this.bs(this.keys, key);\n\t        if (pos.found) {\n\t          this.values[pos.index] = value;\n\t        } else {\n\t          this.keys.splice(pos.index, 0, key);\n\t          this.values.splice(pos.index, 0, value);\n\t        }\n\t      },\n\t      get: function (key) {\n\t        return this.values[binarySearch(this.keys, key, this.sort).index];\n\t      }\n\t    };\n\t\n\t    function UniqueIndex(uniqueField) {\n\t      this.field = uniqueField;\n\t      this.keyMap = {};\n\t      this.lokiMap = {};\n\t    }\n\t    UniqueIndex.prototype.keyMap = {};\n\t    UniqueIndex.prototype.lokiMap = {};\n\t    UniqueIndex.prototype.set = function (obj) {\n\t      var fieldValue = obj[this.field];\n\t      if (fieldValue !== null && typeof fieldValue !== 'undefined') {\n\t        if (this.keyMap[fieldValue]) {\n\t          throw new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n\t        } else {\n\t          this.keyMap[fieldValue] = obj;\n\t          this.lokiMap[obj.$loki] = fieldValue;\n\t        }\n\t      }\n\t    };\n\t    UniqueIndex.prototype.get = function (key) {\n\t      return this.keyMap[key];\n\t    };\n\t\n\t    UniqueIndex.prototype.byId = function (id) {\n\t      return this.keyMap[this.lokiMap[id]];\n\t    };\n\t    /**\n\t     * Updates a document's unique index given an updated object.\n\t     * @param  {Object} obj Original document object\n\t     * @param  {Object} doc New document object (likely the same as obj)\n\t     */\n\t    UniqueIndex.prototype.update = function (obj, doc) {\n\t      if (this.lokiMap[obj.$loki] !== doc[this.field]) {\n\t        var old = this.lokiMap[obj.$loki];\n\t        this.set(doc);\n\t        // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n\t        this.keyMap[old] = undefined;\n\t      } else {\n\t        this.keyMap[obj[this.field]] = doc;\n\t      }\n\t    };\n\t    UniqueIndex.prototype.remove = function (key) {\n\t      var obj = this.keyMap[key];\n\t      if (obj !== null && typeof obj !== 'undefined') {\n\t        this.keyMap[key] = undefined;\n\t        this.lokiMap[obj.$loki] = undefined;\n\t      } else {\n\t        throw new Error('Key is not in unique index: ' + this.field);\n\t      }\n\t    };\n\t    UniqueIndex.prototype.clear = function () {\n\t      this.keyMap = {};\n\t      this.lokiMap = {};\n\t    };\n\t\n\t    function ExactIndex(exactField) {\n\t      this.index = {};\n\t      this.field = exactField;\n\t    }\n\t\n\t    // add the value you want returned to the key in the index\n\t    ExactIndex.prototype = {\n\t      set: function add(key, val) {\n\t        if (this.index[key]) {\n\t          this.index[key].push(val);\n\t        } else {\n\t          this.index[key] = [val];\n\t        }\n\t      },\n\t\n\t      // remove the value from the index, if the value was the last one, remove the key\n\t      remove: function remove(key, val) {\n\t        var idxSet = this.index[key];\n\t        for (var i in idxSet) {\n\t          if (idxSet[i] == val) {\n\t            idxSet.splice(i, 1);\n\t          }\n\t        }\n\t        if (idxSet.length < 1) {\n\t          this.index[key] = undefined;\n\t        }\n\t      },\n\t\n\t      // get the values related to the key, could be more than one\n\t      get: function get(key) {\n\t        return this.index[key];\n\t      },\n\t\n\t      // clear will zap the index\n\t      clear: function clear(key) {\n\t        this.index = {};\n\t      }\n\t    };\n\t\n\t    function SortedIndex(sortedField) {\n\t      this.field = sortedField;\n\t    }\n\t\n\t    SortedIndex.prototype = {\n\t      keys: [],\n\t      values: [],\n\t      // set the default sort\n\t      sort: function (a, b) {\n\t        return a < b ? -1 : a > b ? 1 : 0;\n\t      },\n\t      bs: function () {\n\t        return new BSonSort(this.sort);\n\t      },\n\t      // and allow override of the default sort\n\t      setSort: function (fun) {\n\t        this.bs = new BSonSort(fun);\n\t      },\n\t      // add the value you want returned  to the key in the index\n\t      set: function (key, value) {\n\t        var pos = binarySearch(this.keys, key, this.sort);\n\t        if (pos.found) {\n\t          this.values[pos.index].push(value);\n\t        } else {\n\t          this.keys.splice(pos.index, 0, key);\n\t          this.values.splice(pos.index, 0, [value]);\n\t        }\n\t      },\n\t      // get all values which have a key == the given key\n\t      get: function (key) {\n\t        var bsr = binarySearch(this.keys, key, this.sort);\n\t        if (bsr.found) {\n\t          return this.values[bsr.index];\n\t        } else {\n\t          return [];\n\t        }\n\t      },\n\t      // get all values which have a key < the given key\n\t      getLt: function (key) {\n\t        var bsr = binarySearch(this.keys, key, this.sort);\n\t        var pos = bsr.index;\n\t        if (bsr.found) pos--;\n\t        return this.getAll(key, 0, pos);\n\t      },\n\t      // get all values which have a key > the given key\n\t      getGt: function (key) {\n\t        var bsr = binarySearch(this.keys, key, this.sort);\n\t        var pos = bsr.index;\n\t        if (bsr.found) pos++;\n\t        return this.getAll(key, pos, this.keys.length);\n\t      },\n\t\n\t      // get all vals from start to end\n\t      getAll: function (key, start, end) {\n\t        var results = [];\n\t        for (var i = start; i < end; i++) {\n\t          results = results.concat(this.values[i]);\n\t        }\n\t        return results;\n\t      },\n\t      // just in case someone wants to do something smart with ranges\n\t      getPos: function (key) {\n\t        return binarySearch(this.keys, key, this.sort);\n\t      },\n\t      // remove the value from the index, if the value was the last one, remove the key\n\t      remove: function (key, value) {\n\t        var pos = binarySearch(this.keys, key, this.sort).index;\n\t        var idxSet = this.values[pos];\n\t        for (var i in idxSet) {\n\t          if (idxSet[i] == value) idxSet.splice(i, 1);\n\t        }\n\t        if (idxSet.length < 1) {\n\t          this.keys.splice(pos, 1);\n\t          this.values.splice(pos, 1);\n\t        }\n\t      },\n\t      // clear will zap the index\n\t      clear: function () {\n\t        this.keys = [];\n\t        this.values = [];\n\t      }\n\t    };\n\t\n\t    Loki.LokiOps = LokiOps;\n\t    Loki.Collection = Collection;\n\t    Loki.KeyValueStore = KeyValueStore;\n\t    Loki.persistenceAdapters = {\n\t      fs: LokiFsAdapter,\n\t      localStorage: LokiLocalStorageAdapter\n\t    };\n\t    return Loki;\n\t  }();\n\t});\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n\n/***/ 14:\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n\n/***/ }\n\n/******/ })\n});\n;\n\n\n// WEBPACK FOOTER //\n// lokijs.loki.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap da7d1153d4acd55453c4","/**\n * LokiJS\n * @author Joe Minichino <joe.minichino@gmail.com>\n *\n * A lightweight document oriented javascript database\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    // CommonJS\n    module.exports = factory();\n  } else {\n    // Browser globals\n    root.loki = factory();\n  }\n}(this, function () {\n\n  return (function () {\n    'use strict';\n\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    var Utils = {\n      copyProperties: function (src, dest) {\n        var prop;\n        for (prop in src) {\n          dest[prop] = src[prop];\n        }\n      },\n      // used to recursively scan hierarchical transform step object for param substitution\n      resolveTransformObject: function (subObj, params, depth) {\n        var prop,\n          pname;\n\n        if (typeof depth !== 'number') {\n          depth = 0;\n        }\n\n        if (++depth >= 10) return subObj;\n\n        for (prop in subObj) {\n          if (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n            pname = subObj[prop].substring(8);\n            if (params.hasOwnProperty(pname)) {\n              subObj[prop] = params[pname];\n            }\n          } else if (typeof subObj[prop] === \"object\") {\n            subObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n          }\n        }\n\n        return subObj;\n      },\n      // top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\n      resolveTransformParams: function (transform, params) {\n        var idx,\n          clonedStep,\n          resolvedTransform = [];\n\n        if (typeof params === 'undefined') return transform;\n\n        // iterate all steps in the transform array\n        for (idx = 0; idx < transform.length; idx++) {\n          // clone transform so our scan and replace can operate directly on cloned transform\n          clonedStep = JSON.parse(JSON.stringify(transform[idx]));\n          resolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));\n        }\n\n        return resolvedTransform;\n      }\n    };\n\n    /** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n     *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n     *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n     *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n     */\n    function ltHelper(prop1, prop2, equal) {\n      var cv1, cv2;\n\n      // 'falsy' and Boolean handling\n      if (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n        if ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n          if (equal) {\n            return prop1 === prop2;\n          } else {\n            if (prop1) {\n              return false;\n            } else {\n              return prop2;\n            }\n          }\n        }\n\n        if (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n          return equal;\n        }\n        if (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n          return true;\n        }\n      }\n\n      if (prop1 === prop2) {\n        return equal;\n      }\n\n      if (prop1 < prop2) {\n        return true;\n      }\n\n      if (prop1 > prop2) {\n        return false;\n      }\n\n      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n      cv1 = prop1.toString();\n      cv2 = prop2.toString();\n\n      if (cv1 == cv2) {\n        return equal;\n      }\n\n      if (cv1 < cv2) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function gtHelper(prop1, prop2, equal) {\n      var cv1, cv2;\n\n      // 'falsy' and Boolean handling\n      if (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n        if ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n          if (equal) {\n            return prop1 === prop2;\n          } else {\n            if (prop1) {\n              return !prop2;\n            } else {\n              return false;\n            }\n          }\n        }\n\n        if (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n          return equal;\n        }\n        if (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n          return true;\n        }\n      }\n\n      if (prop1 === prop2) {\n        return equal;\n      }\n\n      if (prop1 > prop2) {\n        return true;\n      }\n\n      if (prop1 < prop2) {\n        return false;\n      }\n\n      // not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n      cv1 = prop1.toString();\n      cv2 = prop2.toString();\n\n      if (cv1 == cv2) {\n        return equal;\n      }\n\n      if (cv1 > cv2) {\n        return true;\n      }\n\n      return false;\n    }\n\n    function sortHelper(prop1, prop2, desc) {\n      if (prop1 === prop2) {\n        return 0;\n      }\n\n      if (ltHelper(prop1, prop2, false)) {\n        return (desc) ? (1) : (-1);\n      }\n\n      if (gtHelper(prop1, prop2, false)) {\n        return (desc) ? (-1) : (1);\n      }\n\n      // not lt, not gt so implied equality-- date compatible\n      return 0;\n    }\n\n    /**\n     * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n     *\n     * @param {array} properties - array of property names, in order, by which to evaluate sort order\n     * @param {object} obj1 - first object to compare\n     * @param {object} obj2 - second object to compare\n     * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n     */\n    function compoundeval(properties, obj1, obj2) {\n      var res = 0;\n      var prop, field;\n      for (var i = 0, len = properties.length; i < len; i++) {\n        prop = properties[i];\n        field = prop[0];\n        res = sortHelper(obj1[field], obj2[field], prop[1]);\n        if (res !== 0) {\n          return res;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * dotSubScan - helper function used for dot notation queries.\n     *\n     * @param {object} root - object to traverse\n     * @param {array} paths - array of properties to drill into\n     * @param {function} fun - evaluation function to test with\n     * @param {any} value - comparative value to also pass to (compare) fun\n     * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n     */\n    function dotSubScan(root, paths, fun, value, poffset) {\n      var pathOffset = poffset || 0;\n      var path = paths[pathOffset];\n      if (root === undefined || root === null || !hasOwnProperty.call(root, path)) {\n        return false;\n      }\n\n      var valueFound = false;\n      var element = root[path];\n      if (pathOffset + 1 >= paths.length) {\n        // if we have already expanded out the dot notation,\n        // then just evaluate the test function and value on the element\n        valueFound = fun(element, value);\n      } else if (Array.isArray(element)) {\n        for (var index = 0, len = element.length; index < len; index += 1) {\n          valueFound = dotSubScan(element[index], paths, fun, value, pathOffset + 1);\n          if (valueFound === true) {\n            break;\n          }\n        }\n      } else {\n        valueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);\n      }\n\n      return valueFound;\n    }\n\n    function containsCheckFn(a) {\n      if (typeof a === 'string' || Array.isArray(a)) {\n        return function (b) {\n          return a.indexOf(b) !== -1;\n        };\n      } else if (typeof a === 'object' && a !== null) {\n        return function (b) {\n          return hasOwnProperty.call(a, b);\n        };\n      }\n      return null;\n    }\n\n    function doQueryOp(val, op) {\n      for (var p in op) {\n        if (hasOwnProperty.call(op, p)) {\n          return LokiOps[p](val, op[p]);\n        }\n      }\n      return false;\n    }\n\n    var LokiOps = {\n      // comparison operators\n      // a is the value in the collection\n      // b is the query value\n      $eq: function (a, b) {\n        return a === b;\n      },\n\n      // abstract/loose equality\n      $aeq: function (a, b) {\n        return a == b;\n      },\n\n      $ne: function (a, b) {\n        // ecma 5 safe test for NaN\n        if (b !== b) {\n          // ecma 5 test value is not NaN\n          return (a === a);\n        }\n\n        return a !== b;\n      },\n\n      $dteq: function (a, b) {\n        if (ltHelper(a, b, false)) {\n          return false;\n        }\n        return !gtHelper(a, b, false);\n      },\n\n      $gt: function (a, b) {\n        return gtHelper(a, b, false);\n      },\n\n      $gte: function (a, b) {\n        return gtHelper(a, b, true);\n      },\n\n      $lt: function (a, b) {\n        return ltHelper(a, b, false);\n      },\n\n      $lte: function (a, b) {\n        return ltHelper(a, b, true);\n      },\n\n      $in: function (a, b) {\n        return b.indexOf(a) !== -1;\n      },\n\n      $nin: function (a, b) {\n        return b.indexOf(a) === -1;\n      },\n\n      $keyin: function (a, b) {\n        return a in b;\n      },\n\n      $nkeyin: function (a, b) {\n        return !(a in b);\n      },\n\n      $definedin: function (a, b) {\n        return b[a] !== undefined;\n      },\n\n      $undefinedin: function (a, b) {\n        return b[a] === undefined;\n      },\n\n      $regex: function (a, b) {\n        return b.test(a);\n      },\n\n      $containsString: function (a, b) {\n        return (typeof a === 'string') && (a.indexOf(b) !== -1);\n      },\n\n      $containsNone: function (a, b) {\n        return !LokiOps.$containsAny(a, b);\n      },\n\n      $containsAny: function (a, b) {\n        var checkFn = containsCheckFn(a);\n        if (checkFn !== null) {\n          return (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));\n        }\n        return false;\n      },\n\n      $contains: function (a, b) {\n        var checkFn = containsCheckFn(a);\n        if (checkFn !== null) {\n          return (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));\n        }\n        return false;\n      },\n\n      $type: function (a, b) {\n        var type = typeof a;\n        if (type === 'object') {\n          if (Array.isArray(a)) {\n            type = 'array';\n          } else if (a instanceof Date) {\n            type = 'date';\n          }\n        }\n        return (typeof b !== 'object') ? (type === b) : doQueryOp(type, b);\n      },\n\n      $size: function (a, b) {\n        if (Array.isArray(a)) {\n          return (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n        }\n        return false;\n      },\n\n      $len: function (a, b) {\n        if (typeof a === 'string') {\n          return (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n        }\n        return false;\n      },\n\n      $where: function (a, b) {\n        return b(a) === true;\n      },\n\n      // field-level logical operators\n      // a is the value in the collection\n      // b is the nested query operation (for '$not')\n      //   or an array of nested query operations (for '$and' and '$or')\n      $not: function (a, b) {\n        return !doQueryOp(a, b);\n      },\n\n      $and: function (a, b) {\n        for (var idx = 0, len = b.length; idx < len; idx += 1) {\n          if (!doQueryOp(a, b[idx])) {\n            return false;\n          }\n        }\n        return true;\n      },\n\n      $or: function (a, b) {\n        for (var idx = 0, len = b.length; idx < len; idx += 1) {\n          if (doQueryOp(a, b[idx])) {\n            return true;\n          }\n        }\n        return false;\n      }\n    };\n\n    // making indexing opt-in... our range function knows how to deal with these ops :\n    var indexedOpsList = ['$eq', '$aeq', '$dteq', '$gt', '$gte', '$lt', '$lte'];\n\n    function clone(data, method) {\n      var cloneMethod = method || 'parse-stringify',\n        cloned;\n\n      switch (cloneMethod) {\n      case \"parse-stringify\":\n        cloned = JSON.parse(JSON.stringify(data));\n        break;\n      case \"jquery-extend-deep\":\n        cloned = jQuery.extend(true, {}, data);\n        break;\n      case \"shallow\":\n        cloned = Object.create(data.prototype || null);\n        Object.keys(data).map(function (i) {\n          cloned[i] = data[i];\n        });\n        break;\n      default:\n        break;\n      }\n\n      //if (cloneMethod === 'parse-stringify') {\n      //  cloned = JSON.parse(JSON.stringify(data));\n      //}\n      return cloned;\n    }\n\n    function cloneObjectArray(objarray, method) {\n      var i,\n        result = [];\n\n      if (method == \"parse-stringify\") {\n        return clone(objarray, method);\n      }\n\n      i = objarray.length - 1;\n\n      for (; i <= 0; i--) {\n        result.push(clone(objarray[i], method));\n      }\n\n      return result;\n    }\n\n    function localStorageAvailable() {\n      try {\n        return (window && window.localStorage !== undefined && window.localStorage !== null);\n      } catch (e) {\n        return false;\n      }\n    }\n\n\n    /**\n     * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n     * constructor that inherits EventEmitter to emit events and trigger\n     * listeners that have been added to the event through the on(event, callback) method\n     *\n     * @constructor LokiEventEmitter\n     */\n    function LokiEventEmitter() {}\n\n    /**\n     * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.events = {};\n\n    /**\n     * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n     * should happen in an async fashion or not\n     * Default is false, which means events are synchronous\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.asyncListeners = false;\n\n    /**\n     * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n     * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n     * @param {function} listener - callback function of listener to attach\n     * @returns {int} the index of the callback in the array of listeners for a particular event\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.on = function (eventName, listener) {\n      var event;\n      var self = this;\n\n      if (Array.isArray(eventName)) {\n        eventName.forEach(function(currentEventName) {\n          self.on(currentEventName, listener);\n        });\n        return listener;\n      }\n\n      event = this.events[eventName];\n      if (!event) {\n        event = this.events[eventName] = [];\n      }\n      event.push(listener);\n      return listener;\n    };\n\n    /**\n     * emit(eventName, data) - emits a particular event\n     * with the option of passing optional parameters which are going to be processed by the callback\n     * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n     * @param {string} eventName - the name of the event\n     * @param {object=} data - optional object passed with the event\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.emit = function (eventName, data) {\n      var self = this;\n      if (eventName && this.events[eventName]) {\n        this.events[eventName].forEach(function (listener) {\n          if (self.asyncListeners) {\n            setTimeout(function () {\n              listener(data);\n            }, 1);\n          } else {\n            listener(data);\n          }\n\n        });\n      }\n    };\n\n    /**\n     * removeListener() - removes the listener at position 'index' from the event 'eventName'\n     * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n     * @param {function} listener - the listener callback function to remove from emitter\n     * @memberof LokiEventEmitter\n     */\n    LokiEventEmitter.prototype.removeListener = function (eventName, listener) {\n      var self = this;\n      if (Array.isArray(eventName)) {\n        eventName.forEach(function(currentEventName) {\n          self.removeListener(currentEventName, listen);\n        });\n      }\n\n      if (this.events[eventName]) {\n        var listeners = this.events[eventName];\n        listeners.splice(listeners.indexOf(listener), 1);\n      }\n    };\n\n    /**\n     * Loki: The main database class\n     * @constructor Loki\n     * @implements LokiEventEmitter\n     * @param {string} filename - name of the file to be saved to\n     * @param {object=} options - (Optional) config options object\n     * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n     * @param {boolean} options.verbose - enable console output (default is 'false')\n     */\n    function Loki(filename, options) {\n      this.filename = filename || 'loki.db';\n      this.collections = [];\n\n      // persist version of code which created the database to the database.\n      // could use for upgrade scenarios\n      this.databaseVersion = 1.1;\n      this.engineVersion = 1.1;\n\n      // autosave support (disabled by default)\n      // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n      this.autosave = false;\n      this.autosaveInterval = 5000;\n      this.autosaveHandle = null;\n\n      this.options = {};\n\n      // currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n      // will not or cannot be deserialized.  You are required to configure persistence every time\n      // you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\n      // persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n      // this is optional option param, otherwise environment detection will be used\n      // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n      this.persistenceMethod = null;\n\n      // retain reference to optional (non-serializable) persistenceAdapter 'instance'\n      this.persistenceAdapter = null;\n\n      // enable console output if verbose flag is set (disabled by default)\n      this.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;\n\n      this.events = {\n        'init': [],\n        'loaded': [],\n        'flushChanges': [],\n        'close': [],\n        'changes': [],\n        'warning': []\n      };\n\n      var getENV = function () {\n        if (typeof window === 'undefined') {\n          return 'NODEJS';\n        }\n\n        if (typeof global !== 'undefined' && global.window) {\n          return 'NODEJS'; //node-webkit\n        }\n\n        if (typeof document !== 'undefined') {\n          if (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n            return 'CORDOVA';\n          }\n          return 'BROWSER';\n        }\n        return 'CORDOVA';\n      };\n\n      // refactored environment detection due to invalid detection for browser environments.\n      // if they do not specify an options.env we want to detect env rather than default to nodejs.\n      // currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n      //   might want to review whether we can consolidate.\n      if (options && options.hasOwnProperty('env')) {\n        this.ENV = options.env;\n      } else {\n        this.ENV = getENV();\n      }\n\n      this.on('init', this.clearChanges);\n\n    }\n\n    // db class is an EventEmitter\n    Loki.prototype = new LokiEventEmitter();\n\n    // experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n    // Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n    Loki.prototype.getIndexedAdapter = function () {\n      var adapter;\n\n      if (typeof require === 'function') {\n        adapter = require(\"./loki-indexed-adapter.js\");\n      }\n\n      return adapter;\n    };\n\n\n    /**\n     * configures options related to database persistence.\n     *\n     * @param {object} options - configuration options to apply to loki db object\n     * @param {adapter} options.adapter - an instance of a loki persistence adapter\n     * @param {boolean} options.autosave - enables autosave\n     * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n     * @param {boolean} options.autoload - enables autoload on loki instantiation\n     * @param {object} options.inflate - options that are passed to loadDatabase if autoload enabled\n     * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n     * @memberof Loki\n     */\n    Loki.prototype.initializePersistence = function (options) {\n      var self = this;\n      var defaultPersistence = {\n          'NODEJS': 'fs',\n          'BROWSER': 'localStorage',\n          'CORDOVA': 'localStorage'\n        },\n        persistenceMethods = {\n          'fs': LokiFsAdapter,\n          'localStorage': LokiLocalStorageAdapter\n        };\n\n      this.options = options || {};\n\n      this.persistenceMethod = null;\n      // retain reference to optional persistence adapter 'instance'\n      // currently keeping outside options because it can't be serialized\n      this.persistenceAdapter = null;\n\n      // process the options\n      if (this.options.hasOwnProperty('persistenceMethod')) {\n        // check if the specified persistence method is known\n        if (typeof (persistenceMethods[this.options.persistenceMethod]) === 'function') {\n          this.persistenceMethod = this.options.persistenceMethod;\n          this.persistenceAdapter = new persistenceMethods[this.options.persistenceMethod]();\n        }\n        // should be throw an error here, or just fall back to defaults ??\n      }\n\n      // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n      if (this.persistenceAdapter === null) {\n        this.persistenceMethod = defaultPersistence[this.ENV];\n        if (this.persistenceMethod) {\n          this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n        }\n      }\n\n      // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n      if (this.options.hasOwnProperty('adapter')) {\n        this.persistenceMethod = 'adapter';\n        this.persistenceAdapter = this.options.adapter;\n      }\n\n      if (this.options.hasOwnProperty('autosaveInterval')) {\n        this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n      }\n\n      this.autosaveDisable();\n\n      var loaded;\n\n      // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n      if (this.options.autoload) {\n        loaded = this.loadDatabase(this.options.inflate);\n      }\n      else {\n        loaded = Promise.resolve();\n      }\n\n      return loaded.then(function () {\n        if (self.options.autosave) {\n          self.autosaveEnable();\n        }\n      });\n    };\n\n    /**\n     * Shorthand method for quickly creating and populating an anonymous collection.\n     *    This collection is not referenced internally so upon losing scope it will be garbage collected.\n     *\n     * @example\n     * var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });\n     *\n     * @param {Array} docs - document array to initialize the anonymous collection with\n     * @param {object} options - configuration object, see {@link Loki#addCollection} options\n     * @returns {Collection} New collection which you can query or chain\n     * @memberof Loki\n     */\n    Loki.prototype.anonym = function (docs, options) {\n      var collection = new Collection('anonym', options);\n      collection.insert(docs);\n\n      if (this.verbose)\n        collection.console = console;\n\n      return collection;\n    };\n\n    /**\n     * Adds a collection to the database.\n     * @param {string} name - name of collection to add\n     * @param {object=} options - (optional) options to configure collection with.\n     * @param {array} options.unique - array of property names to define unique constraints for\n     * @param {array} options.exact - array of property names to define exact constraints for\n     * @param {array} options.indices - array property names to define binary indexes for\n     * @param {boolean} options.asyncListeners - default is false\n     * @param {boolean} options.disableChangesApi - default is true\n     * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n     * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n     * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n     * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n     * @returns {Collection} a reference to the collection which was just added\n     * @memberof Loki\n     */\n    Loki.prototype.addCollection = function (name, options) {\n      var collection = new Collection(name, options);\n      this.collections.push(collection);\n\n      if (this.verbose)\n        collection.console = console;\n\n      return collection;\n    };\n\n    Loki.prototype.loadCollection = function (collection) {\n      if (!collection.name) {\n        throw new Error('Collection must have a name property to be loaded');\n      }\n      this.collections.push(collection);\n    };\n\n    /**\n     * Retrieves reference to a collection by name.\n     * @param {string} collectionName - name of collection to look up\n     * @returns {Collection} Reference to collection in database by that name, or null if not found\n     * @memberof Loki\n     */\n    Loki.prototype.getCollection = function (collectionName) {\n      var i,\n        len = this.collections.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.collections[i].name === collectionName) {\n          return this.collections[i];\n        }\n      }\n\n      // no such collection\n      this.emit('warning', 'collection ' + collectionName + ' not found');\n      return null;\n    };\n\n    Loki.prototype.listCollections = function () {\n\n      var i = this.collections.length,\n        colls = [];\n\n      while (i--) {\n        colls.push({\n          name: this.collections[i].name,\n          type: this.collections[i].objType,\n          count: this.collections[i].data.length\n        });\n      }\n      return colls;\n    };\n\n    /**\n     * Removes a collection from the database.\n     * @param {string} collectionName - name of collection to remove\n     * @memberof Loki\n     */\n    Loki.prototype.removeCollection = function (collectionName) {\n      var i,\n        len = this.collections.length;\n\n      for (i = 0; i < len; i += 1) {\n        if (this.collections[i].name === collectionName) {\n          var tmpcol = new Collection(collectionName, {});\n          var curcol = this.collections[i];\n          for (var prop in curcol) {\n            if (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n              curcol[prop] = tmpcol[prop];\n            }\n          }\n          this.collections.splice(i, 1);\n          return;\n        }\n      }\n    };\n\n    Loki.prototype.getName = function () {\n      return this.name;\n    };\n\n    /**\n     * serializeReplacer - used to prevent certain properties from being serialized\n     *\n     */\n    Loki.prototype.serializeReplacer = function (key, value) {\n      switch (key) {\n      case 'autosaveHandle':\n      case 'persistenceAdapter':\n      case 'constraints':\n      case 'ttl':\n        return null;\n      default:\n        return value;\n      }\n    };\n\n    /**\n     * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n     *\n     * @returns {string} Stringified representation of the loki database.\n     * @memberof Loki\n     */\n    Loki.prototype.serialize = function () {\n      return JSON.stringify(this, this.serializeReplacer, 2);\n    };\n    // alias of serialize\n    Loki.prototype.toJson = Loki.prototype.serialize;\n\n    /**\n     * Inflates a loki database from a serialized JSON string\n     *\n     * @param {string} serializedDb - a serialized loki database string\n     * @param {object} options - apply or override collection level settings\n     * @memberof Loki\n     */\n    Loki.prototype.loadJSON = function (serializedDb, options) {\n      var dbObject;\n      if (serializedDb.length === 0) {\n        dbObject = {};\n      } else {\n        dbObject = JSON.parse(serializedDb);\n      }\n\n      this.loadJSONObject(dbObject, options);\n    };\n\n    /**\n     * Inflates a loki database from a JS object\n     *\n     * @param {object} dbObject - a serialized loki database string\n     * @param {object} options - apply or override collection level settings\n     * @memberof Loki\n     */\n    Loki.prototype.loadJSONObject = function (dbObject, options) {\n      var i = 0,\n        len = dbObject.collections ? dbObject.collections.length : 0,\n        coll,\n        copyColl,\n        clen,\n        j,\n        loader,\n        collObj;\n\n      this.name = dbObject.name;\n\n      // restore database version\n      this.databaseVersion = 1.0;\n      if (dbObject.hasOwnProperty('databaseVersion')) {\n        this.databaseVersion = dbObject.databaseVersion;\n      }\n\n      this.collections = [];\n\n      function makeLoader(coll) {\n        var collOptions = options[coll.name];\n        var inflater;\n\n        if (collOptions.proto) {\n          inflater = collOptions.inflate || Utils.copyProperties;\n\n          return function(data) {\n            var collObj = new(collOptions.proto)();\n            inflater(data, collObj);\n            return collObj;\n          };\n        }\n\n        return collOptions.inflate;\n      }\n\n      for (i; i < len; i += 1) {\n        coll = dbObject.collections[i];\n        copyColl = this.addCollection(coll.name);\n\n        copyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices')?(coll.adaptiveBinaryIndices === true): false;\n        copyColl.transactional = coll.transactional;\n        copyColl.asyncListeners = coll.asyncListeners;\n        copyColl.disableChangesApi = coll.disableChangesApi;\n        copyColl.cloneObjects = coll.cloneObjects;\n        copyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n        copyColl.autoupdate = coll.autoupdate;\n\n        // load each element individually\n        clen = coll.data.length;\n        j = 0;\n        if (options && options.hasOwnProperty(coll.name)) {\n          loader = makeLoader(coll);\n\n          for (j; j < clen; j++) {\n            collObj = loader(coll.data[j]);\n            copyColl.data[j] = collObj;\n            copyColl.addAutoUpdateObserver(collObj);\n          }\n        } else {\n\n          for (j; j < clen; j++) {\n            copyColl.data[j] = coll.data[j];\n            copyColl.addAutoUpdateObserver(copyColl.data[j]);\n          }\n        }\n\n        copyColl.maxId = (coll.data.length === 0) ? 0 : coll.maxId;\n        copyColl.idIndex = coll.idIndex;\n        if (typeof (coll.binaryIndices) !== 'undefined') {\n          copyColl.binaryIndices = coll.binaryIndices;\n        }\n        if (typeof coll.transforms !== 'undefined') {\n          copyColl.transforms = coll.transforms;\n        }\n\n        copyColl.ensureId();\n\n        // regenerate unique indexes\n        copyColl.uniqueNames = [];\n        if (coll.hasOwnProperty(\"uniqueNames\")) {\n          copyColl.uniqueNames = coll.uniqueNames;\n          for (j = 0; j < copyColl.uniqueNames.length; j++) {\n            copyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);\n          }\n        }\n\n        // in case they are loading a database created before we added dynamic views, handle undefined\n        if (typeof (coll.DynamicViews) === 'undefined') continue;\n\n        // reinflate DynamicViews and attached Resultsets\n        for (var idx = 0; idx < coll.DynamicViews.length; idx++) {\n          var colldv = coll.DynamicViews[idx];\n\n          var dv = copyColl.addDynamicView(colldv.name, colldv.options);\n          dv.resultdata = colldv.resultdata;\n          dv.resultsdirty = colldv.resultsdirty;\n          dv.filterPipeline = colldv.filterPipeline;\n\n          dv.sortCriteria = colldv.sortCriteria;\n          dv.sortFunction = null;\n\n          dv.sortDirty = colldv.sortDirty;\n          dv.resultset.filteredrows = colldv.resultset.filteredrows;\n          dv.resultset.searchIsChained = colldv.resultset.searchIsChained;\n          dv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\n          dv.rematerialize({\n            removeWhereFilters: true\n          });\n        }\n      }\n    };\n\n    /**\n     * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n     * Does not actually destroy the db.\n     *\n     * @returns {Promise} a Promise that resolves after closing the database succeeded\n     * @memberof Loki\n     */\n    Loki.prototype.close = function () {\n      var self = this;\n      var saved;\n\n      // for autosave scenarios, we will let close perform final save (if dirty)\n      // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n      if (this.autosave) {\n        this.autosaveDisable();\n        if (this.autosaveDirty()) {\n          saved = this.saveDatabase();\n        }\n      }\n\n      if (!saved) {\n        saved = Promise.resolve();\n      }\n\n      return saved.then(function () {\n        self.emit('close');\n      });\n    };\n\n    /**-------------------------+\n    | Changes API               |\n    +--------------------------*/\n\n    /**\n     * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n     * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n     */\n\n    /**\n     * (Changes API) : takes all the changes stored in each\n     * collection and creates a single array for the entire database. If an array of names\n     * of collections is passed then only the included collections will be tracked.\n     *\n     * @param {array=} optional array of collection names. No arg means all collections are processed.\n     * @returns {array} array of changes\n     * @see private method createChange() in Collection\n     * @memberof Loki\n     */\n    Loki.prototype.generateChangesNotification = function (arrayOfCollectionNames) {\n      function getCollName(coll) {\n        return coll.name;\n      }\n      var changes = [],\n        selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\n      this.collections.forEach(function (coll) {\n        if (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n          changes = changes.concat(coll.getChanges());\n        }\n      });\n      return changes;\n    };\n\n    /**\n     * (Changes API) - stringify changes for network transmission\n     * @returns {string} string representation of the changes\n     * @memberof Loki\n     */\n    Loki.prototype.serializeChanges = function (collectionNamesArray) {\n      return JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n    };\n\n    /**\n     * (Changes API) : clears all the changes in all collections.\n     * @memberof Loki\n     */\n    Loki.prototype.clearChanges = function () {\n      this.collections.forEach(function (coll) {\n        if (coll.flushChanges) {\n          coll.flushChanges();\n        }\n      });\n    };\n\n    /*------------------+\n    | PERSISTENCE       |\n    -------------------*/\n\n\n    /** there are two build in persistence adapters for internal use\n     * fs             for use in Nodejs type environments\n     * localStorage   for use in browser environment\n     * defined as helper classes here so its easy and clean to use\n     */\n\n    /**\n     * A loki persistence adapter which persists using node fs module\n     * @constructor LokiFsAdapter\n     */\n    function LokiFsAdapter() {\n      this.fs = require('fs');\n    }\n\n    /**\n     * loadDatabase() - Load data from file, will throw an error if the file does not exist\n     * @param {string} dbname - the filename of the database to load\n     * @returns {Promise} a Promise that resolves after the database was loaded\n     * @memberof LokiFsAdapter\n     */\n    LokiFsAdapter.prototype.loadDatabase = function loadDatabase(dbname) {\n      var self = this;\n\n      return new Promise(function (resolve, reject) {\n        self.fs.stat(dbname, function (err, stats) {\n          if (!err && stats.isFile()) {\n            self.fs.readFile(dbname, {\n              encoding: 'utf8'\n            }, function readFileCallback(err, data) {\n              if (err) {\n                reject(err);\n              } else {\n                resolve(data);\n              }\n            });\n          }\n          else {\n            reject();\n          }\n        });\n      });\n    };\n\n    /**\n     * saveDatabase() - save data to file, will throw an error if the file can't be saved\n     * might want to expand this to avoid dataloss on partial save\n     * @param {string} dbname - the filename of the database to load\n     * @returns {Promise} a Promise that resolves after the database was persisted\n     * @memberof LokiFsAdapter\n     */\n    LokiFsAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring) {\n      var self = this;\n\n      return new Promise(function (resolve, reject) {\n        self.fs.writeFile(dbname, dbstring, function (err) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    };\n\n    /**\n     * deleteDatabase() - delete the database file, will throw an error if the\n     * file can't be deleted\n     * @param {string} dbname - the filename of the database to delete\n     * @returns {Promise} a Promise that resolves after the database was deleted\n     * @memberof LokiFsAdapter\n     */\n    LokiFsAdapter.prototype.deleteDatabase = function deleteDatabase(dbname, callback) {\n      var self = this;\n\n      return new Promise(function (resolve, reject) {\n        self.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n      });\n    };\n\n\n    /**\n     * A loki persistence adapter which persists to web browser's local storage object\n     * @constructor LokiLocalStorageAdapter\n     */\n    function LokiLocalStorageAdapter() {}\n\n    /**\n     * loadDatabase() - Load data from localstorage\n     * @param {string} dbname - the name of the database to load\n     * @returns {Promise} a Promise that resolves after the database was loaded\n     * @memberof LokiLocalStorageAdapter\n     */\n    LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(dbname) {\n      if (localStorageAvailable()) {\n        return Promise.resolve(localStorage.getItem(dbname));\n      }\n\n      return Promise.reject(new Error('localStorage is not available'));\n    };\n\n    /**\n     * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n     * might want to expand this to avoid dataloss on partial save\n     * @param {string} dbname - the filename of the database to load\n     * @returns {Promise} a Promise that resolves after the database was saved\n     * @memberof LokiLocalStorageAdapter\n     */\n    LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring) {\n      if (localStorageAvailable()) {\n        localStorage.setItem(dbname, dbstring);\n\n        return Promise.resolve();\n      }\n\n      return Promise.reject(new Error('localStorage is not available'));\n    };\n\n    /**\n     * deleteDatabase() - delete the database from localstorage, will throw an error if it\n     * can't be deleted\n     * @param {string} dbname - the filename of the database to delete\n     * @returns {Promise} a Promise that resolves after the database was deleted\n     * @memberof LokiLocalStorageAdapter\n     */\n    LokiLocalStorageAdapter.prototype.deleteDatabase = function deleteDatabase(dbname) {\n      if (localStorageAvailable()) {\n        localStorage.removeItem(dbname);\n\n        return Promise.resolve();\n      }\n\n      return Promise.reject(new Error('localStorage is not available'));\n    };\n\n    /**\n     * Handles loading from file system, local storage, or adapter (indexeddb).\n     *\n     * @param {object} options - an object containing inflation options for each collection\n     * @returns {Promise} a Promise that resolves after the database is loaded\n     * @memberof Loki\n     */\n    Loki.prototype.loadDatabase = function (options) {\n      var self = this;\n\n      // the persistenceAdapter should be present if all is ok, but check to be sure.\n      if (this.persistenceAdapter === null) {\n        return Promise.reject(new Error('persistenceAdapter not configured'));\n      }\n\n      return this.persistenceAdapter.loadDatabase(this.filename)\n        .then(function loadDatabaseCallback(dbString) {\n          if (typeof (dbString) === 'string') {\n            self.loadJSON(dbString, options || {});\n            self.emit('load', self);\n          } else {\n            // if adapter has returned an js object (other than null or error) attempt to load from JSON object\n            if (typeof (dbString) === \"object\" && dbString !== null && !(dbString instanceof Error)) {\n              self.loadJSONObject(dbString, options || {});\n              self.emit('load', self);\n            } else {\n              if (dbString instanceof Error)\n                throw dbString;\n\n              throw new TypeError('The persistence adapter did not load a serialized DB string or object.');\n            }\n          }\n        });\n    };\n\n    /**\n     * Handles saving to file system, local storage, or adapter (indexeddb)\n     *\n     * @memberof Loki\n     * @returns {Promise} a Promise that resolves after the database is persisted\n     */\n    Loki.prototype.saveDatabase = function () {\n      var self = this;\n\n      // the persistenceAdapter should be present if all is ok, but check to be sure.\n      if (this.persistenceAdapter === null) {\n        return Promise.reject(new Error('persistenceAdapter not configured'));\n      }\n\n      var saved;\n\n      // check if the adapter is requesting (and supports) a 'reference' mode export\n      if (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n        // filename may seem redundant but loadDatabase will need to expect this same filename\n        saved = this.persistenceAdapter.exportDatabase(this.filename, this);\n      }\n      // otherwise just pass the serialized database to adapter\n      else {\n        saved = this.persistenceAdapter.saveDatabase(this.filename, self.serialize());\n      }\n\n      return saved.then(function () {\n        self.autosaveClearFlags();\n        self.emit(\"save\");\n      });\n    };\n\n    // alias\n    Loki.prototype.save = Loki.prototype.saveDatabase;\n\n    /**\n     * Handles deleting a database from file system, local storage, or adapter (indexeddb)\n     *\n     * @returns {Promise} a Promise that resolves after the database is deleted\n     * @memberof Loki\n     */\n    Loki.prototype.deleteDatabase = function () {\n      // the persistenceAdapter should be present if all is ok, but check to be sure.\n      if (this.persistenceAdapter === null) {\n        return Promise.reject(new Error('persistenceAdapter not configured'));\n      }\n\n      return this.persistenceAdapter.deleteDatabase(this.filename);\n    };\n\n    /**\n     * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n     *\n     * @returns {boolean} - true if database has changed since last autosave, false if not.\n     */\n    Loki.prototype.autosaveDirty = function () {\n      for (var idx = 0; idx < this.collections.length; idx++) {\n        if (this.collections[idx].dirty) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    /**\n     * autosaveClearFlags - resets dirty flags on all collections.\n     *    Called from saveDatabase() after db is saved.\n     *\n     */\n    Loki.prototype.autosaveClearFlags = function () {\n      for (var idx = 0; idx < this.collections.length; idx++) {\n        this.collections[idx].dirty = false;\n      }\n    };\n\n    /**\n     * autosaveEnable - begin a javascript interval to periodically save the database.\n     *\n     */\n    Loki.prototype.autosaveEnable = function () {\n      if (this.autosaveHandle) {\n        return;\n      }\n\n      var self = this;\n      var running = true;\n\n      this.autosave = true;\n      this.autosaveHandle = function () {\n        running = false;\n        self.autosaveHandle = undefined;\n      };\n\n      (function saveDatabase() {\n        setTimeout(function () {\n          if (running) {\n            self.saveDatabase().then(saveDatabase, saveDatabase);\n          }\n        }, self.autosaveInterval);\n      })();\n    };\n\n    /**\n     * autosaveDisable - stop the autosave interval timer.\n     *\n     */\n    Loki.prototype.autosaveDisable = function () {\n      this.autosave = false;\n\n      if (this.autosaveHandle) {\n        this.autosaveHandle();\n      }\n    };\n\n\n    /**\n     * Resultset class allowing chainable queries.  Intended to be instanced internally.\n     *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n     *\n     * @example\n     *    mycollection.chain()\n     *      .find({ 'doors' : 4 })\n     *      .where(function(obj) { return obj.name === 'Toyota' })\n     *      .data();\n     *\n     * @constructor Resultset\n     * @param {Collection} collection - The collection which this Resultset will query against.\n     * @param {Object=} options - Object containing one or more options.\n     * @param {string} options.queryObj - Optional mongo-style query object to initialize resultset with.\n     * @param {function} options.queryFunc - Optional javascript filter function to initialize resultset with.\n     * @param {bool} options.firstOnly - Optional boolean used by collection.findOne().\n     */\n    function Resultset(collection, options) {\n      options = options || {};\n\n      options.queryObj = options.queryObj || null;\n      options.queryFunc = options.queryFunc || null;\n      options.firstOnly = options.firstOnly || false;\n\n      // retain reference to collection we are querying against\n      this.collection = collection;\n\n      // if chain() instantiates with null queryObj and queryFunc, so we will keep flag for later\n      this.searchIsChained = (!options.queryObj && !options.queryFunc);\n      this.filteredrows = [];\n      this.filterInitialized = false;\n\n      // if user supplied initial queryObj or queryFunc, apply it\n      if (typeof (options.queryObj) !== \"undefined\" && options.queryObj !== null) {\n        return this.find(options.queryObj, options.firstOnly);\n      }\n      if (typeof (options.queryFunc) !== \"undefined\" && options.queryFunc !== null) {\n        return this.where(options.queryFunc);\n      }\n\n      // otherwise return unfiltered Resultset for future filtering\n      return this;\n    }\n\n    /**\n     * reset() - Reset the resultset to its initial state.\n     *\n     * @returns {Resultset} Reference to this resultset, for future chain operations.\n     */\n    Resultset.prototype.reset = function () {\n      if (this.filteredrows.length > 0) {\n        this.filteredrows = [];\n      }\n      this.filterInitialized = false;\n      return this;\n    };\n\n    /**\n     * toJSON() - Override of toJSON to avoid circular references\n     *\n     */\n    Resultset.prototype.toJSON = function () {\n      var copy = this.copy();\n      copy.collection = null;\n      return copy;\n    };\n\n    /**\n     * Allows you to limit the number of documents passed to next chain operation.\n     *    A resultset copy() is made to avoid altering original resultset.\n     *\n     * @param {int} qty - The number of documents to return.\n     * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n     * @memberof Resultset\n     */\n    Resultset.prototype.limit = function (qty) {\n      // if this is chained resultset with no filters applied, we need to populate filteredrows first\n      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var rscopy = new Resultset(this.collection);\n      rscopy.filteredrows = this.filteredrows.slice(0, qty);\n      rscopy.filterInitialized = true;\n      return rscopy;\n    };\n\n    /**\n     * Used for skipping 'pos' number of documents in the resultset.\n     *\n     * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n     * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n     * @memberof Resultset\n     */\n    Resultset.prototype.offset = function (pos) {\n      // if this is chained resultset with no filters applied, we need to populate filteredrows first\n      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var rscopy = new Resultset(this.collection);\n      rscopy.filteredrows = this.filteredrows.slice(pos);\n      rscopy.filterInitialized = true;\n      return rscopy;\n    };\n\n    /**\n     * copy() - To support reuse of resultset in branched query situations.\n     *\n     * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n     * @memberof Resultset\n     */\n    Resultset.prototype.copy = function () {\n      var result = new Resultset(this.collection);\n\n      if (this.filteredrows.length > 0) {\n        result.filteredrows = this.filteredrows.slice();\n      }\n      result.filterInitialized = this.filterInitialized;\n\n      return result;\n    };\n\n    /**\n     * Alias of copy()\n     * @memberof Resultset\n     */\n    Resultset.prototype.branch = Resultset.prototype.copy;\n\n    /**\n     * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n     *\n     * @param transform {(string|array)} - name of collection transform or raw transform array\n     * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n     * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n     * @memberof Resultset\n     */\n    Resultset.prototype.transform = function (transform, parameters) {\n      var idx,\n        step,\n        rs = this;\n\n      // if transform is name, then do lookup first\n      if (typeof transform === 'string') {\n        if (this.collection.transforms.hasOwnProperty(transform)) {\n          transform = this.collection.transforms[transform];\n        }\n      }\n\n      // either they passed in raw transform array or we looked it up, so process\n      if (typeof transform !== 'object' || !Array.isArray(transform)) {\n        throw new Error(\"Invalid transform\");\n      }\n\n      if (typeof parameters !== 'undefined') {\n        transform = Utils.resolveTransformParams(transform, parameters);\n      }\n\n      for (idx = 0; idx < transform.length; idx++) {\n        step = transform[idx];\n\n        switch (step.type) {\n        case \"find\":\n          rs.find(step.value);\n          break;\n        case \"where\":\n          rs.where(step.value);\n          break;\n        case \"simplesort\":\n          rs.simplesort(step.property, step.desc);\n          break;\n        case \"compoundsort\":\n          rs.compoundsort(step.value);\n          break;\n        case \"sort\":\n          rs.sort(step.value);\n          break;\n        case \"limit\":\n          rs = rs.limit(step.value);\n          break; // limit makes copy so update reference\n        case \"offset\":\n          rs = rs.offset(step.value);\n          break; // offset makes copy so update reference\n        case \"map\":\n          rs = rs.map(step.value);\n          break;\n        case \"eqJoin\":\n          rs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);\n          break;\n          // following cases break chain by returning array data so make any of these last in transform steps\n        case \"mapReduce\":\n          rs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n          break;\n          // following cases update documents in current filtered resultset (use carefully)\n        case \"update\":\n          rs.update(step.value);\n          break;\n        case \"remove\":\n          rs.remove();\n          break;\n        default:\n          break;\n        }\n      }\n\n      return rs;\n    };\n\n    /**\n     * User supplied compare function is provided two documents to compare. (chainable)\n     * @example\n     *    rslt.sort(function(obj1, obj2) {\n     *      if (obj1.name === obj2.name) return 0;\n     *      if (obj1.name > obj2.name) return 1;\n     *      if (obj1.name < obj2.name) return -1;\n     *    });\n     *\n     * @param {function} comparefun - A javascript compare function used for sorting.\n     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n     * @memberof Resultset\n     */\n    Resultset.prototype.sort = function (comparefun) {\n      // if this is chained resultset with no filters applied, just we need to populate filteredrows first\n      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var wrappedComparer =\n        (function (userComparer, data) {\n          return function (a, b) {\n            return userComparer(data[a], data[b]);\n          };\n        })(comparefun, this.collection.data);\n\n      this.filteredrows.sort(wrappedComparer);\n\n      return this;\n    };\n\n    /**\n     * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n     *    Sorting based on the same lt/gt helper functions used for binary indices.\n     *\n     * @param {string} propname - name of property to sort by.\n     * @param {bool=} isdesc - (Optional) If true, the property will be sorted in descending order\n     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n     * @memberof Resultset\n     */\n    Resultset.prototype.simplesort = function (propname, isdesc) {\n      // if this is chained resultset with no filters applied, just we need to populate filteredrows first\n      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      if (typeof (isdesc) === 'undefined') {\n        isdesc = false;\n      }\n\n      var wrappedComparer =\n        (function (prop, desc, data) {\n          return function (a, b) {\n            return sortHelper(data[a][prop], data[b][prop], desc);\n          };\n        })(propname, isdesc, this.collection.data);\n\n      this.filteredrows.sort(wrappedComparer);\n\n      return this;\n    };\n\n    /**\n     * Allows sorting a resultset based on multiple columns.\n     * @example\n     * // to sort by age and then name (both ascending)\n     * rs.compoundsort(['age', 'name']);\n     * // to sort by age (ascending) and then by name (descending)\n     * rs.compoundsort(['age', ['name', true]);\n     *\n     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n     * @memberof Resultset\n     */\n    Resultset.prototype.compoundsort = function (properties) {\n      if (properties.length === 0) {\n        throw new Error(\"Invalid call to compoundsort, need at least one property\");\n      }\n\n      var prop;\n      if (properties.length === 1) {\n        prop = properties[0];\n        if (Array.isArray(prop)) {\n          return this.simplesort(prop[0], prop[1]);\n        }\n        return this.simplesort(prop, false);\n      }\n\n      // unify the structure of 'properties' to avoid checking it repeatedly while sorting\n      for (var i = 0, len = properties.length; i < len; i += 1) {\n        prop = properties[i];\n        if (!Array.isArray(prop)) {\n          properties[i] = [prop, false];\n        }\n      }\n\n      // if this is chained resultset with no filters applied, just we need to populate filteredrows first\n      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var wrappedComparer =\n        (function (props, data) {\n          return function (a, b) {\n            return compoundeval(props, data[a], data[b]);\n          };\n        })(properties, this.collection.data);\n\n      this.filteredrows.sort(wrappedComparer);\n\n      return this;\n    };\n\n    /**\n     * findOr() - oversee the operation of OR'ed query expressions.\n     *    OR'ed expression evaluation runs each expression individually against the full collection,\n     *    and finally does a set OR on each expression's results.\n     *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n     *\n     * @param {array} expressionArray - array of expressions\n     * @returns {Resultset} this resultset for further chain ops.\n     */\n    Resultset.prototype.findOr = function (expressionArray) {\n      var fr = null,\n        fri = 0,\n        frlen = 0,\n        docset = [],\n        idxset = [],\n        idx = 0,\n        origCount = this.count();\n\n      // If filter is already initialized, then we query against only those items already in filter.\n      // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n      for (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n        // we need to branch existing query to run each filter separately and combine results\n        fr = this.branch().find(expressionArray[ei]).filteredrows;\n        frlen = fr.length;\n        // if the find operation did not reduce the initial set, then the initial set is the actual result\n        if (frlen === origCount) {\n          return this;\n        }\n\n        // add any document 'hits'\n        for (fri = 0; fri < frlen; fri++) {\n          idx = fr[fri];\n          if (idxset[idx] === undefined) {\n            idxset[idx] = true;\n            docset.push(idx);\n          }\n        }\n      }\n\n      this.filteredrows = docset;\n      this.filterInitialized = true;\n\n      return this;\n    };\n    Resultset.prototype.$or = Resultset.prototype.findOr;\n\n    /**\n     * findAnd() - oversee the operation of AND'ed query expressions.\n     *    AND'ed expression evaluation runs each expression progressively against the full collection,\n     *    internally utilizing existing chained resultset functionality.\n     *    Only the first filter can utilize a binary index.\n     *\n     * @param {array} expressionArray - array of expressions\n     * @returns {Resultset} this resultset for further chain ops.\n     */\n    Resultset.prototype.findAnd = function (expressionArray) {\n      // we have already implementing method chaining in this (our Resultset class)\n      // so lets just progressively apply user supplied and filters\n      for (var i = 0, len = expressionArray.length; i < len; i++) {\n        if (this.count() === 0) {\n          return this;\n        }\n        this.find(expressionArray[i]);\n      }\n      return this;\n    };\n    Resultset.prototype.$and = Resultset.prototype.findAnd;\n\n    /**\n     * Used for querying via a mongo-style query object.\n     *\n     * @param {object} query - A mongo-style query object used for filtering current results.\n     * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n     * @returns {Resultset} this resultset for further chain ops.\n     * @memberof Resultset\n     */\n    Resultset.prototype.find = function (query, firstOnly) {\n      if (this.collection.data.length === 0) {\n        if (this.searchIsChained) {\n          this.filteredrows = [];\n          this.filterInitialized = true;\n          return this;\n        }\n        return [];\n      }\n\n      var queryObject = query || 'getAll',\n        p,\n        property,\n        queryObjectOp,\n        operator,\n        value,\n        key,\n        searchByIndex = false,\n        result = [],\n        index = null;\n\n      // if this was note invoked via findOne()\n      firstOnly = firstOnly || false;\n\n      if (typeof queryObject === 'object') {\n        for (p in queryObject) {\n          if (hasOwnProperty.call(queryObject, p)) {\n            property = p;\n            queryObjectOp = queryObject[p];\n            break;\n          }\n        }\n      }\n\n      // apply no filters if they want all\n      if (!property || queryObject === 'getAll') {\n        // coll.find(), coll.findOne(), coll.chain().find().data() all path here\n\n        if (firstOnly) {\n          return (this.collection.data.length > 0)?this.collection.data[0]: null;\n        }\n\n        return (this.searchIsChained) ? (this) : (this.collection.data.slice());\n      }\n\n      // injecting $and and $or expression tree evaluation here.\n      if (property === '$and' || property === '$or') {\n        if (this.searchIsChained) {\n          this[property](queryObjectOp);\n\n          // for chained find with firstonly,\n          if (firstOnly && this.filteredrows.length > 1) {\n            this.filteredrows = this.filteredrows.slice(0, 1);\n          }\n\n          return this;\n        } else {\n          // our $and operation internally chains filters\n          result = this.collection.chain()[property](queryObjectOp).data();\n\n          // if this was coll.findOne() return first object or empty array if null\n          // since this is invoked from a constructor we can't return null, so we will\n          // make null in coll.findOne();\n          if (firstOnly) {\n            return (result.length === 0) ? ([]) : (result[0]);\n          }\n\n          // not first only return all results\n          return result;\n        }\n      }\n\n      // see if query object is in shorthand mode (assuming eq operator)\n      if (queryObjectOp === null || (typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date)) {\n        operator = '$eq';\n        value = queryObjectOp;\n      } else if (typeof queryObjectOp === 'object') {\n        for (key in queryObjectOp) {\n          if (hasOwnProperty.call(queryObjectOp, key)) {\n            operator = key;\n            value = queryObjectOp[key];\n            break;\n          }\n        }\n      } else {\n        throw new Error('Do not know what you want to do.');\n      }\n\n      // for regex ops, precompile\n      if (operator === '$regex') {\n        if (Array.isArray(value)) {\n          value = new RegExp(value[0], value[1]);\n        } else if (!(value instanceof RegExp)) {\n          value = new RegExp(value);\n        }\n      }\n\n      // if user is deep querying the object such as find('name.first': 'odin')\n      var usingDotNotation = (property.indexOf('.') !== -1);\n\n      // if an index exists for the property being queried against, use it\n      // for now only enabling for non-chained query (who's set of docs matches index)\n      // or chained queries where it is the first filter applied and prop is indexed\n      var doIndexCheck = !usingDotNotation &&\n        (!this.searchIsChained || !this.filterInitialized);\n\n      if (doIndexCheck && this.collection.binaryIndices[property] &&\n        indexedOpsList.indexOf(operator) !== -1) {\n        // this is where our lazy index rebuilding will take place\n        // basically we will leave all indexes dirty until we need them\n        // so here we will rebuild only the index tied to this property\n        // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n        if (this.collection.adaptiveBinaryIndices !== true) {\n          this.collection.ensureIndex(property);\n        }\n\n        searchByIndex = true;\n        index = this.collection.binaryIndices[property];\n      }\n\n      // the comparison function\n      var fun = LokiOps[operator];\n\n      // \"shortcut\" for collection data\n      var t = this.collection.data;\n      // filter data length\n      var i = 0;\n\n      // Query executed differently depending on :\n      //    - whether it is chained or not\n      //    - whether the property being queried has an index defined\n      //    - if chained, we handle first pass differently for initial filteredrows[] population\n      //\n      // For performance reasons, each case has its own if block to minimize in-loop calculations\n\n      // If not a chained query, bypass filteredrows and work directly against data\n      if (!this.searchIsChained) {\n        if (!searchByIndex) {\n          i = t.length;\n\n          if (firstOnly) {\n            if (usingDotNotation) {\n              property = property.split('.');\n              while (i--) {\n                if (dotSubScan(t[i], property, fun, value)) {\n                  return (t[i]);\n                }\n              }\n            } else {\n              while (i--) {\n                if (fun(t[i][property], value)) {\n                  return (t[i]);\n                }\n              }\n            }\n\n            return [];\n          }\n\n          // if using dot notation then treat property as keypath such as 'name.first'.\n          // currently supporting dot notation for non-indexed conditions only\n          if (usingDotNotation) {\n            property = property.split('.');\n            while (i--) {\n              if (dotSubScan(t[i], property, fun, value)) {\n                result.push(t[i]);\n              }\n            }\n          } else {\n            while (i--) {\n              if (fun(t[i][property], value)) {\n                result.push(t[i]);\n              }\n            }\n          }\n        } else {\n          // searching by binary index via calculateRange() utility method\n          var seg = this.collection.calculateRange(operator, property, value);\n\n          // not chained so this 'find' was designated in Resultset constructor\n          // so return object itself\n          if (firstOnly) {\n            if (seg[1] !== -1) {\n              return t[index.values[seg[0]]];\n            }\n            return [];\n          }\n\n          for (i = seg[0]; i <= seg[1]; i++) {\n            result.push(t[index.values[i]]);\n          }\n        }\n\n        // not a chained query so return result as data[]\n        return result;\n      }\n\n\n      // Otherwise this is a chained query\n\n      var filter, rowIdx = 0;\n\n      // If the filteredrows[] is already initialized, use it\n      if (this.filterInitialized) {\n        filter = this.filteredrows;\n        i = filter.length;\n\n        // currently supporting dot notation for non-indexed conditions only\n        if (usingDotNotation) {\n          property = property.split('.');\n          while (i--) {\n            rowIdx = filter[i];\n            if (dotSubScan(t[rowIdx], property, fun, value)) {\n              result.push(rowIdx);\n            }\n          }\n        } else {\n          while (i--) {\n            rowIdx = filter[i];\n            if (fun(t[rowIdx][property], value)) {\n              result.push(rowIdx);\n            }\n          }\n        }\n      }\n      // first chained query so work against data[] but put results in filteredrows\n      else {\n        // if not searching by index\n        if (!searchByIndex) {\n          i = t.length;\n\n          if (usingDotNotation) {\n            property = property.split('.');\n            while (i--) {\n              if (dotSubScan(t[i], property, fun, value)) {\n                result.push(i);\n              }\n            }\n          } else {\n            while (i--) {\n              if (fun(t[i][property], value)) {\n                result.push(i);\n              }\n            }\n          }\n        } else {\n          // search by index\n          var segm = this.collection.calculateRange(operator, property, value);\n\n          for (i = segm[0]; i <= segm[1]; i++) {\n            result.push(index.values[i]);\n          }\n        }\n\n        this.filterInitialized = true; // next time work against filteredrows[]\n      }\n\n      this.filteredrows = result;\n      return this;\n    };\n\n\n    /**\n     * where() - Used for filtering via a javascript filter function.\n     *\n     * @param {function} fun - A javascript function used for filtering current results by.\n     * @returns {Resultset} this resultset for further chain ops.\n     * @memberof Resultset\n     */\n    Resultset.prototype.where = function (fun) {\n      var viewFunction,\n        result = [];\n\n      if ('function' === typeof fun) {\n        viewFunction = fun;\n      } else {\n        throw new TypeError('Argument is not a stored view or a function');\n      }\n      try {\n        // if not a chained query then run directly against data[] and return object []\n        if (!this.searchIsChained) {\n          var i = this.collection.data.length;\n\n          while (i--) {\n            if (viewFunction(this.collection.data[i]) === true) {\n              result.push(this.collection.data[i]);\n            }\n          }\n\n          // not a chained query so returning result as data[]\n          return result;\n        }\n        // else chained query, so run against filteredrows\n        else {\n          // If the filteredrows[] is already initialized, use it\n          if (this.filterInitialized) {\n            var j = this.filteredrows.length;\n\n            while (j--) {\n              if (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n                result.push(this.filteredrows[j]);\n              }\n            }\n\n            this.filteredrows = result;\n\n            return this;\n          }\n          // otherwise this is initial chained op, work against data, push into filteredrows[]\n          else {\n            var k = this.collection.data.length;\n\n            while (k--) {\n              if (viewFunction(this.collection.data[k]) === true) {\n                result.push(k);\n              }\n            }\n\n            this.filteredrows = result;\n            this.filterInitialized = true;\n\n            return this;\n          }\n        }\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    /**\n     * count() - returns the number of documents in the resultset.\n     *\n     * @returns {number} The number of documents in the resultset.\n     * @memberof Resultset\n     */\n    Resultset.prototype.count = function () {\n      if (this.searchIsChained && this.filterInitialized) {\n        return this.filteredrows.length;\n      }\n      return this.collection.count();\n    };\n\n    /**\n     * Terminates the chain and returns array of filtered documents\n     *\n     * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n     * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n     *        the collection is not configured for clone object.\n     * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n     *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'\n     *\n     * @returns {array} Array of documents in the resultset\n     * @memberof Resultset\n     */\n    Resultset.prototype.data = function (options) {\n      var result = [],\n        data = this.collection.data,\n        len,\n        i,\n        method;\n\n      options = options || {};\n\n      // if this is chained resultset with no filters applied, just return collection.data\n      if (this.searchIsChained && !this.filterInitialized) {\n        if (this.filteredrows.length === 0) {\n          // determine whether we need to clone objects or not\n          if (this.collection.cloneObjects || options.forceClones) {\n            len = data.length;\n            method = options.forceCloneMethod || this.collection.cloneMethod;\n\n            for (i = 0; i < len; i++) {\n              result.push(clone(data[i], method));\n            }\n            return result;\n          }\n          // otherwise we are not cloning so return sliced array with same object references\n          else {\n            return data.slice();\n          }\n        } else {\n          // filteredrows must have been set manually, so use it\n          this.filterInitialized = true;\n        }\n      }\n\n      var fr = this.filteredrows;\n      len = fr.length;\n\n      if (this.collection.cloneObjects || options.forceClones) {\n        method = options.forceCloneMethod || this.collection.cloneMethod;\n        for (i = 0; i < len; i++) {\n          result.push(clone(data[fr[i]], method));\n        }\n      } else {\n        for (i = 0; i < len; i++) {\n          result.push(data[fr[i]]);\n        }\n      }\n      return result;\n    };\n\n    /**\n     * Used to run an update operation on all documents currently in the resultset.\n     *\n     * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n     * @returns {Resultset} this resultset for further chain ops.\n     * @memberof Resultset\n     */\n    Resultset.prototype.update = function (updateFunction) {\n\n      if (typeof (updateFunction) !== \"function\") {\n        throw new TypeError('Argument is not a function');\n      }\n\n      // if this is chained resultset with no filters applied, we need to populate filteredrows first\n      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      var len = this.filteredrows.length,\n        rcd = this.collection.data;\n\n      for (var idx = 0; idx < len; idx++) {\n        // pass in each document object currently in resultset to user supplied updateFunction\n        updateFunction(rcd[this.filteredrows[idx]]);\n\n        // notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate\n        this.collection.update(rcd[this.filteredrows[idx]]);\n      }\n\n      return this;\n    };\n\n    /**\n     * Removes all document objects which are currently in resultset from collection (as well as resultset)\n     *\n     * @returns {Resultset} this (empty) resultset for further chain ops.\n     * @memberof Resultset\n     */\n    Resultset.prototype.remove = function () {\n\n      // if this is chained resultset with no filters applied, we need to populate filteredrows first\n      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n        this.filteredrows = this.collection.prepareFullDocIndex();\n      }\n\n      this.collection.remove(this.data());\n\n      this.filteredrows = [];\n\n      return this;\n    };\n\n    /**\n     * data transformation via user supplied functions\n     *\n     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n     * @returns {value} The output of your reduceFunction\n     * @memberof Resultset\n     */\n    Resultset.prototype.mapReduce = function (mapFunction, reduceFunction) {\n      try {\n        return reduceFunction(this.data().map(mapFunction));\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    /**\n     * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n     * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n     * @param {Array} joinData - Data array to join to.\n     * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n     * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n     * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n     * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n     * @memberof Resultset\n     */\n    Resultset.prototype.eqJoin = function (joinData, leftJoinKey, rightJoinKey, mapFun) {\n\n      var leftData = [],\n        leftDataLength,\n        rightData = [],\n        rightDataLength,\n        key,\n        result = [],\n        leftKeyisFunction = typeof leftJoinKey === 'function',\n        rightKeyisFunction = typeof rightJoinKey === 'function',\n        joinMap = {};\n\n      //get the left data\n      leftData = this.data();\n      leftDataLength = leftData.length;\n\n      //get the right data\n      if (joinData instanceof Resultset) {\n        rightData = joinData.data();\n      } else if (Array.isArray(joinData)) {\n        rightData = joinData;\n      } else {\n        throw new TypeError('joinData needs to be an array or result set');\n      }\n      rightDataLength = rightData.length;\n\n      //construct a lookup table\n\n      for (var i = 0; i < rightDataLength; i++) {\n        key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n        joinMap[key] = rightData[i];\n      }\n\n      if (!mapFun) {\n        mapFun = function (left, right) {\n          return {\n            left: left,\n            right: right\n          };\n        };\n      }\n\n      //Run map function over each object in the resultset\n      for (var j = 0; j < leftDataLength; j++) {\n        key = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n        result.push(mapFun(leftData[j], joinMap[key] || {}));\n      }\n\n      //return return a new resultset with no filters\n      this.collection = new Collection('joinData');\n      this.collection.insert(result);\n      this.filteredrows = [];\n      this.filterInitialized = false;\n\n      return this;\n    };\n\n    Resultset.prototype.map = function (mapFun) {\n      var data = this.data().map(mapFun);\n      //return return a new resultset with no filters\n      this.collection = new Collection('mappedData');\n      this.collection.insert(data);\n      this.filteredrows = [];\n      this.filterInitialized = false;\n\n      return this;\n    };\n\n    /**\n     * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n     *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n     *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n     *\n     * @example\n     * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n     * mydv.applyFind({ 'doors' : 4 });\n     * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n     * var results = mydv.data();\n     *\n     * @constructor DynamicView\n     * @implements LokiEventEmitter\n     * @param {Collection} collection - A reference to the collection to work against\n     * @param {string} name - The name of this dynamic view\n     * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n     * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n     * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n     * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n     */\n    function DynamicView(collection, name, options) {\n      this.collection = collection;\n      this.name = name;\n      this.rebuildPending = false;\n      this.options = options || {};\n\n      if (!this.options.hasOwnProperty('persistent')) {\n        this.options.persistent = false;\n      }\n\n      // 'persistentSortPriority':\n      // 'passive' will defer the sort phase until they call data(). (most efficient overall)\n      // 'active' will sort async whenever next idle. (prioritizes read speeds)\n      if (!this.options.hasOwnProperty('sortPriority')) {\n        this.options.sortPriority = 'passive';\n      }\n\n      if (!this.options.hasOwnProperty('minRebuildInterval')) {\n        this.options.minRebuildInterval = 1;\n      }\n\n      this.resultset = new Resultset(collection);\n      this.resultdata = [];\n      this.resultsdirty = false;\n\n      this.cachedresultset = null;\n\n      // keep ordered filter pipeline\n      this.filterPipeline = [];\n\n      // sorting member variables\n      // we only support one active search, applied using applySort() or applySimpleSort()\n      this.sortFunction = null;\n      this.sortCriteria = null;\n      this.sortDirty = false;\n\n      // for now just have 1 event for when we finally rebuilt lazy view\n      // once we refactor transactions, i will tie in certain transactional events\n\n      this.events = {\n        'rebuild': []\n      };\n    }\n\n    DynamicView.prototype = new LokiEventEmitter();\n\n\n    /**\n     * rematerialize() - intended for use immediately after deserialization (loading)\n     *    This will clear out and reapply filterPipeline ops, recreating the view.\n     *    Since where filters do not persist correctly, this method allows\n     *    restoring the view to state where user can re-apply those where filters.\n     *\n     * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n     * @returns {DynamicView} This dynamic view for further chained ops.\n     * @memberof DynamicView\n     * @fires DynamicView.rebuild\n     */\n    DynamicView.prototype.rematerialize = function (options) {\n      var fpl,\n        fpi,\n        idx;\n\n      options = options || {};\n\n      this.resultdata = [];\n      this.resultsdirty = true;\n      this.resultset = new Resultset(this.collection);\n\n      if (this.sortFunction || this.sortCriteria) {\n        this.sortDirty = true;\n      }\n\n      if (options.hasOwnProperty('removeWhereFilters')) {\n        // for each view see if it had any where filters applied... since they don't\n        // serialize those functions lets remove those invalid filters\n        fpl = this.filterPipeline.length;\n        fpi = fpl;\n        while (fpi--) {\n          if (this.filterPipeline[fpi].type === 'where') {\n            if (fpi !== this.filterPipeline.length - 1) {\n              this.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n            }\n\n            this.filterPipeline.length--;\n          }\n        }\n      }\n\n      // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n      var ofp = this.filterPipeline;\n      this.filterPipeline = [];\n\n      // now re-apply 'find' filterPipeline ops\n      fpl = ofp.length;\n      for (idx = 0; idx < fpl; idx++) {\n        this.applyFind(ofp[idx].val);\n      }\n\n      // during creation of unit tests, i will remove this forced refresh and leave lazy\n      this.data();\n\n      // emit rebuild event in case user wants to be notified\n      this.emit('rebuild', this);\n\n      return this;\n    };\n\n    /**\n     * branchResultset() - Makes a copy of the internal resultset for branched queries.\n     *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n     *    so your branched query should be immediately resolved and not held for future evaluation.\n     *\n     * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n     * @param {object=} parameters - optional parameters (if optional transform requires them)\n     * @returns {Resultset} A copy of the internal resultset for branched queries.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.branchResultset = function (transform, parameters) {\n      var rs = this.resultset.branch();\n\n      if (typeof transform === 'undefined') {\n        return rs;\n      }\n\n      return rs.transform(transform, parameters);\n    };\n\n    /**\n     * toJSON() - Override of toJSON to avoid circular references\n     *\n     */\n    DynamicView.prototype.toJSON = function () {\n      var copy = new DynamicView(this.collection, this.name, this.options);\n\n      copy.resultset = this.resultset;\n      copy.resultdata = []; // let's not save data (copy) to minimize size\n      copy.resultsdirty = true;\n      copy.filterPipeline = this.filterPipeline;\n      copy.sortFunction = this.sortFunction;\n      copy.sortCriteria = this.sortCriteria;\n      copy.sortDirty = this.sortDirty;\n\n      // avoid circular reference, reapply in db.loadJSON()\n      copy.collection = null;\n\n      return copy;\n    };\n\n    /**\n     * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n     *     Existing options should be retained.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.removeFilters = function () {\n      this.rebuildPending = false;\n      this.resultset.reset();\n      this.resultdata = [];\n      this.resultsdirty = false;\n\n      this.cachedresultset = null;\n\n      // keep ordered filter pipeline\n      this.filterPipeline = [];\n\n      // sorting member variables\n      // we only support one active search, applied using applySort() or applySimpleSort()\n      this.sortFunction = null;\n      this.sortCriteria = null;\n      this.sortDirty = false;\n    };\n\n    /**\n     * applySort() - Used to apply a sort to the dynamic view\n     * @example\n     * dv.applySort(function(obj1, obj2) {\n     *   if (obj1.name === obj2.name) return 0;\n     *   if (obj1.name > obj2.name) return 1;\n     *   if (obj1.name < obj2.name) return -1;\n     * });\n     *\n     * @param {function} comparefun - a javascript compare function used for sorting\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applySort = function (comparefun) {\n      this.sortFunction = comparefun;\n      this.sortCriteria = null;\n\n      this.queueSortPhase();\n\n      return this;\n    };\n\n    /**\n     * applySimpleSort() - Used to specify a property used for view translation.\n     * @example\n     * dv.applySimpleSort(\"name\");\n     *\n     * @param {string} propname - Name of property by which to sort.\n     * @param {boolean=} isdesc - (Optional) If true, the sort will be in descending order.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applySimpleSort = function (propname, isdesc) {\n      this.sortCriteria = [\n        [propname, isdesc || false]\n      ];\n      this.sortFunction = null;\n\n      this.queueSortPhase();\n\n      return this;\n    };\n\n    /**\n     * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n     * @example\n     * // to sort by age and then name (both ascending)\n     * dv.applySortCriteria(['age', 'name']);\n     * // to sort by age (ascending) and then by name (descending)\n     * dv.applySortCriteria(['age', ['name', true]);\n     * // to sort by age (descending) and then by name (descending)\n     * dv.applySortCriteria(['age', true], ['name', true]);\n     *\n     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n     * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applySortCriteria = function (criteria) {\n      this.sortCriteria = criteria;\n      this.sortFunction = null;\n\n      this.queueSortPhase();\n\n      return this;\n    };\n\n    /**\n     * startTransaction() - marks the beginning of a transaction.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    DynamicView.prototype.startTransaction = function () {\n      this.cachedresultset = this.resultset.copy();\n\n      return this;\n    };\n\n    /**\n     * commit() - commits a transaction.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    DynamicView.prototype.commit = function () {\n      this.cachedresultset = null;\n\n      return this;\n    };\n\n    /**\n     * rollback() - rolls back a transaction.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    DynamicView.prototype.rollback = function () {\n      this.resultset = this.cachedresultset;\n\n      if (this.options.persistent) {\n        // for now just rebuild the persistent dynamic view data in this worst case scenario\n        // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n        this.resultdata = this.resultset.data();\n\n        this.emit('rebuild', this);\n      }\n\n      return this;\n    };\n\n\n    /**\n     * Implementation detail.\n     * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n     *\n     * @param {(string|number)} uid - The unique ID of the filter.\n     * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n     */\n    DynamicView.prototype._indexOfFilterWithId = function (uid) {\n      if (typeof uid === 'string' || typeof uid === 'number') {\n        for (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n          if (uid === this.filterPipeline[idx].uid) {\n            return idx;\n          }\n        }\n      }\n      return -1;\n    };\n\n    /**\n     * Implementation detail.\n     * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n     *\n     * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n     */\n    DynamicView.prototype._addFilter = function (filter) {\n      this.filterPipeline.push(filter);\n      this.resultset[filter.type](filter.val);\n    };\n\n    /**\n     * reapplyFilters() - Reapply all the filters in the current pipeline.\n     *\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     */\n    DynamicView.prototype.reapplyFilters = function () {\n      this.resultset.reset();\n\n      this.cachedresultset = null;\n      if (this.options.persistent) {\n        this.resultdata = [];\n        this.resultsdirty = true;\n      }\n\n      var filters = this.filterPipeline;\n      this.filterPipeline = [];\n\n      for (var idx = 0, len = filters.length; idx < len; idx += 1) {\n        this._addFilter(filters[idx]);\n      }\n\n      if (this.sortFunction || this.sortCriteria) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n\n      return this;\n    };\n\n    /**\n     * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n     *\n     * @param {object} filter - A filter object to add to the pipeline.\n     *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applyFilter = function (filter) {\n      var idx = this._indexOfFilterWithId(filter.uid);\n      if (idx >= 0) {\n        this.filterPipeline[idx] = filter;\n        return this.reapplyFilters();\n      }\n\n      this.cachedresultset = null;\n      if (this.options.persistent) {\n        this.resultdata = [];\n        this.resultsdirty = true;\n      }\n\n      this._addFilter(filter);\n\n      if (this.sortFunction || this.sortCriteria) {\n        this.queueSortPhase();\n      } else {\n        this.queueRebuildEvent();\n      }\n\n      return this;\n    };\n\n    /**\n     * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n     *\n     * @param {object} query - A mongo-style query object to apply to pipeline\n     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applyFind = function (query, uid) {\n      this.applyFilter({\n        type: 'find',\n        val: query,\n        uid: uid\n      });\n      return this;\n    };\n\n    /**\n     * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n     *\n     * @param {function} fun - A javascript filter function to apply to pipeline\n     * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.applyWhere = function (fun, uid) {\n      this.applyFilter({\n        type: 'where',\n        val: fun,\n        uid: uid\n      });\n      return this;\n    };\n\n    /**\n     * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n     *\n     * @param {(string|number)} uid - The unique ID of the filter to be removed.\n     * @returns {DynamicView} this DynamicView object, for further chain ops.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.removeFilter = function (uid) {\n      var idx = this._indexOfFilterWithId(uid);\n      if (idx < 0) {\n        throw new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n      }\n\n      this.filterPipeline.splice(idx, 1);\n      this.reapplyFilters();\n      return this;\n    };\n\n    /**\n     * count() - returns the number of documents representing the current DynamicView contents.\n     *\n     * @returns {number} The number of documents representing the current DynamicView contents.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.count = function () {\n      if (this.options.persistent) {\n        return this.resultdata.length;\n      }\n      return this.resultset.count();\n    };\n\n    /**\n     * data() - resolves and pending filtering and sorting, then returns document array as result.\n     *\n     * @returns {array} An array of documents representing the current DynamicView contents.\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.data = function () {\n      // using final sort phase as 'catch all' for a few use cases which require full rebuild\n      if (this.sortDirty || this.resultsdirty) {\n        this.performSortPhase({\n          suppressRebuildEvent: true\n        });\n      }\n      return (this.options.persistent) ? (this.resultdata) : (this.resultset.data());\n    };\n\n    /**\n     * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n     *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n     */\n    DynamicView.prototype.queueRebuildEvent = function () {\n      if (this.rebuildPending) {\n        return;\n      }\n      this.rebuildPending = true;\n\n      var self = this;\n      setTimeout(function () {\n        if (self.rebuildPending) {\n          self.rebuildPending = false;\n          self.emit('rebuild', self);\n        }\n      }, this.options.minRebuildInterval);\n    };\n\n    /**\n     * queueSortPhase : If the view is sorted we will throttle sorting to either :\n     *    (1) passive - when the user calls data(), or\n     *    (2) active - once they stop updating and yield js thread control\n     */\n    DynamicView.prototype.queueSortPhase = function () {\n      // already queued? exit without queuing again\n      if (this.sortDirty) {\n        return;\n      }\n      this.sortDirty = true;\n\n      var self = this;\n      if (this.options.sortPriority === \"active\") {\n        // active sorting... once they are done and yield js thread, run async performSortPhase()\n        setTimeout(function () {\n          self.performSortPhase();\n        }, this.options.minRebuildInterval);\n      } else {\n        // must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n        // potentially notify user that data has changed.\n        this.queueRebuildEvent();\n      }\n    };\n\n    /**\n     * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n     *\n     */\n    DynamicView.prototype.performSortPhase = function (options) {\n      // async call to this may have been pre-empted by synchronous call to data before async could fire\n      if (!this.sortDirty && !this.resultsdirty) {\n        return;\n      }\n\n      options = options || {};\n\n      if (this.sortDirty) {\n        if (this.sortFunction) {\n          this.resultset.sort(this.sortFunction);\n        } else if (this.sortCriteria) {\n          this.resultset.compoundsort(this.sortCriteria);\n        }\n\n        this.sortDirty = false;\n      }\n\n      if (this.options.persistent) {\n        // persistent view, rebuild local resultdata array\n        this.resultdata = this.resultset.data();\n        this.resultsdirty = false;\n      }\n\n      if (!options.suppressRebuildEvent) {\n        this.emit('rebuild', this);\n      }\n    };\n\n    /**\n     * evaluateDocument() - internal method for (re)evaluating document inclusion.\n     *    Called by : collection.insert() and collection.update().\n     *\n     * @param {int} objIndex - index of document to (re)run through filter pipeline.\n     * @param {bool} isNew - true if the document was just added to the collection.\n     */\n    DynamicView.prototype.evaluateDocument = function (objIndex, isNew) {\n      // if no filter applied yet, the result 'set' should remain 'everything'\n      if (!this.resultset.filterInitialized) {\n        if (this.options.persistent) {\n          this.resultdata = this.resultset.data();\n        }\n        // need to re-sort to sort new document\n        if (this.sortFunction || this.sortCriteria) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n        return;\n      }\n\n      var ofr = this.resultset.filteredrows;\n      var oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));\n      var oldlen = ofr.length;\n\n      // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n      // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n      var evalResultset = new Resultset(this.collection);\n      evalResultset.filteredrows = [objIndex];\n      evalResultset.filterInitialized = true;\n      var filter;\n      for (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n        filter = this.filterPipeline[idx];\n        evalResultset[filter.type](filter.val);\n      }\n\n      // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n      var newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;\n\n      // wasn't in old, shouldn't be now... do nothing\n      if (oldPos === -1 && newPos === -1) return;\n\n      // wasn't in resultset, should be now... add\n      if (oldPos === -1 && newPos !== -1) {\n        ofr.push(objIndex);\n\n        if (this.options.persistent) {\n          this.resultdata.push(this.collection.data[objIndex]);\n        }\n\n        // need to re-sort to sort new document\n        if (this.sortFunction || this.sortCriteria) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      }\n\n      // was in resultset, shouldn't be now... delete\n      if (oldPos !== -1 && newPos === -1) {\n        if (oldPos < oldlen - 1) {\n          ofr.splice(oldPos, 1);\n\n          if (this.options.persistent) {\n            this.resultdata.splice(oldPos, 1);\n          }\n        } else {\n          ofr.length = oldlen - 1;\n\n          if (this.options.persistent) {\n            this.resultdata.length = oldlen - 1;\n          }\n        }\n\n        // in case changes to data altered a sort column\n        if (this.sortFunction || this.sortCriteria) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      }\n\n      // was in resultset, should still be now... (update persistent only?)\n      if (oldPos !== -1 && newPos !== -1) {\n        if (this.options.persistent) {\n          // in case document changed, replace persistent view data with the latest collection.data document\n          this.resultdata[oldPos] = this.collection.data[objIndex];\n        }\n\n        // in case changes to data altered a sort column\n        if (this.sortFunction || this.sortCriteria) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n\n        return;\n      }\n    };\n\n    /**\n     * removeDocument() - internal function called on collection.delete()\n     */\n    DynamicView.prototype.removeDocument = function (objIndex) {\n      // if no filter applied yet, the result 'set' should remain 'everything'\n      if (!this.resultset.filterInitialized) {\n        if (this.options.persistent) {\n          this.resultdata = this.resultset.data();\n        }\n        // in case changes to data altered a sort column\n        if (this.sortFunction || this.sortCriteria) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n        return;\n      }\n\n      var ofr = this.resultset.filteredrows;\n      var oldPos = ofr.indexOf(+objIndex);\n      var oldlen = ofr.length;\n      var idx;\n\n      if (oldPos !== -1) {\n        // if not last row in resultdata, swap last to hole and truncate last row\n        if (oldPos < oldlen - 1) {\n          ofr[oldPos] = ofr[oldlen - 1];\n          ofr.length = oldlen - 1;\n\n          if (this.options.persistent) {\n            this.resultdata[oldPos] = this.resultdata[oldlen - 1];\n            this.resultdata.length = oldlen - 1;\n          }\n        }\n        // last row, so just truncate last row\n        else {\n          ofr.length = oldlen - 1;\n\n          if (this.options.persistent) {\n            this.resultdata.length = oldlen - 1;\n          }\n        }\n\n        // in case changes to data altered a sort column\n        if (this.sortFunction || this.sortCriteria) {\n          this.queueSortPhase();\n        } else {\n          this.queueRebuildEvent();\n        }\n      }\n\n      // since we are using filteredrows to store data array positions\n      // if they remove a document (whether in our view or not),\n      // we need to adjust array positions -1 for all document array references after that position\n      oldlen = ofr.length;\n      for (idx = 0; idx < oldlen; idx++) {\n        if (ofr[idx] > objIndex) {\n          ofr[idx]--;\n        }\n      }\n    };\n\n    /**\n     * mapReduce() - data transformation via user supplied functions\n     *\n     * @param {function} mapFunction - this function accepts a single document for you to transform and return\n     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n     * @returns The output of your reduceFunction\n     * @memberof DynamicView\n     */\n    DynamicView.prototype.mapReduce = function (mapFunction, reduceFunction) {\n      try {\n        return reduceFunction(this.data().map(mapFunction));\n      } catch (err) {\n        throw err;\n      }\n    };\n\n\n    /**\n     * Collection class that handles documents of same type\n     * @constructor Collection\n     * @implements LokiEventEmitter\n     * @param {string} name - collection name\n     * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n     * @param {array} options.unique - array of property names to define unique constraints for\n     * @param {array} options.exact - array of property names to define exact constraints for\n     * @param {array} options.indices - array property names to define binary indexes for\n     * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily (default: true)\n     * @param {boolean} options.asyncListeners - default is false\n     * @param {boolean} options.disableChangesApi - default is true\n     * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n     * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n     * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n     * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n     * @see {@link Loki#addCollection} for normal creation of collections\n     */\n    function Collection(name, options) {\n      // the name of the collection\n\n      this.name = name;\n      // the data held by the collection\n      this.data = [];\n      this.idIndex = []; // index of id\n      this.binaryIndices = {}; // user defined indexes\n      this.constraints = {\n        unique: {},\n        exact: {}\n      };\n\n      // unique contraints contain duplicate object references, so they are not persisted.\n      // we will keep track of properties which have unique contraint applied here, and regenerate on load\n      this.uniqueNames = [];\n\n      // transforms will be used to store frequently used query chains as a series of steps\n      // which itself can be stored along with the database.\n      this.transforms = {};\n\n      // the object type of the collection\n      this.objType = name;\n\n      // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n      // currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n      // defaulting to true since this is called from addCollection and adding a collection should trigger save\n      this.dirty = true;\n\n      // private holders for cached data\n      this.cachedIndex = null;\n      this.cachedBinaryIndex = null;\n      this.cachedData = null;\n      var self = this;\n\n      /* OPTIONS */\n      options = options || {};\n\n      // exact match and unique constraints\n      if (options.hasOwnProperty('unique')) {\n        if (!Array.isArray(options.unique)) {\n          options.unique = [options.unique];\n        }\n        options.unique.forEach(function (prop) {\n          self.uniqueNames.push(prop); // used to regenerate on subsequent database loads\n          self.constraints.unique[prop] = new UniqueIndex(prop);\n        });\n      }\n\n      if (options.hasOwnProperty('exact')) {\n        options.exact.forEach(function (prop) {\n          self.constraints.exact[prop] = new ExactIndex(prop);\n        });\n      }\n\n      // if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n      // if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n      this.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;\n\n      // is collection transactional\n      this.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;\n\n      // options to clone objects when inserting them\n      this.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;\n\n      // default clone method (if enabled) is parse-stringify\n      this.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : \"parse-stringify\";\n\n      // option to make event listeners async, default is sync\n      this.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;\n\n      // disable track changes\n      this.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;\n\n      // option to observe objects and update them automatically, ignored if Object.observe is not supported\n      this.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;\n\n      //option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n      this.ttl = {\n        age: null,\n        ttlInterval: null,\n        daemon: null\n      };\n      this.setTTL(options.ttl || -1, options.ttlInterval);\n\n      // currentMaxId - change manually at your own peril!\n      this.maxId = 0;\n\n      this.DynamicViews = [];\n\n      // events\n      this.events = {\n        'insert': [],\n        'update': [],\n        'pre-insert': [],\n        'pre-update': [],\n        'close': [],\n        'flushbuffer': [],\n        'error': [],\n        'delete': [],\n        'warning': []\n      };\n\n      // changes are tracked by collection and aggregated by the db\n      this.changes = [];\n\n      // initialize the id index\n      this.ensureId();\n      var indices = [];\n      // initialize optional user-supplied indices array ['age', 'lname', 'zip']\n      if (options && options.indices) {\n        if (Object.prototype.toString.call(options.indices) === '[object Array]') {\n          indices = options.indices;\n        } else if (typeof options.indices === 'string') {\n          indices = [options.indices];\n        } else {\n          throw new TypeError('Indices needs to be a string or an array of strings');\n        }\n      }\n\n      for (var idx = 0; idx < indices.length; idx++) {\n        this.ensureIndex(indices[idx]);\n      }\n\n      function observerCallback(changes) {\n\n        var changedObjects = typeof Set === 'function' ? new Set() : [];\n\n        if (!changedObjects.add)\n          changedObjects.add = function (object) {\n            if (this.indexOf(object) === -1)\n              this.push(object);\n            return this;\n          };\n\n        changes.forEach(function (change) {\n          changedObjects.add(change.object);\n        });\n\n        changedObjects.forEach(function (object) {\n          if (!hasOwnProperty.call(object, '$loki'))\n            return self.removeAutoUpdateObserver(object);\n          try {\n            self.update(object);\n          } catch (err) {}\n        });\n      }\n\n      this.observerCallback = observerCallback;\n\n      /*\n       * This method creates a clone of the current status of an object and associates operation and collection name,\n       * so the parent db can aggregate and generate a changes object for the entire db\n       */\n      function createChange(name, op, obj) {\n        self.changes.push({\n          name: name,\n          operation: op,\n          obj: JSON.parse(JSON.stringify(obj))\n        });\n      }\n\n      // clear all the changes\n      function flushChanges() {\n        self.changes = [];\n      }\n\n      this.getChanges = function () {\n        return self.changes;\n      };\n\n      this.flushChanges = flushChanges;\n\n      /**\n       * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled\n       */\n      function insertMeta(obj) {\n        if (!obj) {\n          return;\n        }\n        if (!obj.meta) {\n          obj.meta = {};\n        }\n\n        obj.meta.created = (new Date()).getTime();\n        obj.meta.revision = 0;\n      }\n\n      function updateMeta(obj) {\n        if (!obj) {\n          return;\n        }\n        obj.meta.updated = (new Date()).getTime();\n        obj.meta.revision += 1;\n      }\n\n      function createInsertChange(obj) {\n        createChange(self.name, 'I', obj);\n      }\n\n      function createUpdateChange(obj) {\n        createChange(self.name, 'U', obj);\n      }\n\n      function insertMetaWithChange(obj) {\n        insertMeta(obj);\n        createInsertChange(obj);\n      }\n\n      function updateMetaWithChange(obj) {\n        updateMeta(obj);\n        createUpdateChange(obj);\n      }\n\n\n      /* assign correct handler based on ChangesAPI flag */\n      var insertHandler, updateHandler;\n\n      function setHandlers() {\n        insertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;\n        updateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;\n      }\n\n      setHandlers();\n\n      this.setChangesApi = function (enabled) {\n        self.disableChangesApi = !enabled;\n        setHandlers();\n      };\n      /**\n       * built-in events\n       */\n      this.on('insert', function insertCallback(obj) {\n        insertHandler(obj);\n      });\n\n      this.on('update', function updateCallback(obj) {\n        updateHandler(obj);\n      });\n\n      this.on('delete', function deleteCallback(obj) {\n        if (!self.disableChangesApi) {\n          createChange(self.name, 'R', obj);\n        }\n      });\n\n      this.on('warning', function (warning) {\n        self.console.warn(warning);\n      });\n      // for de-serialization purposes\n      flushChanges();\n    }\n\n    Collection.prototype = new LokiEventEmitter();\n\n    Collection.prototype.console = {\n      log: function () {},\n      warn: function () {},\n      error: function () {},\n    };\n\n    Collection.prototype.addAutoUpdateObserver = function (object) {\n      if (!this.autoupdate || typeof Object.observe !== 'function')\n        return;\n\n      Object.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n    };\n\n    Collection.prototype.removeAutoUpdateObserver = function (object) {\n      if (!this.autoupdate || typeof Object.observe !== 'function')\n        return;\n\n      Object.unobserve(object, this.observerCallback);\n    };\n\n    /**\n     * Adds a named collection transform to the collection\n     * @param {string} name - name to associate with transform\n     * @param {array} transform - an array of transformation 'step' objects to save into the collection\n     * @memberof Collection\n     */\n    Collection.prototype.addTransform = function (name, transform) {\n      if (this.transforms.hasOwnProperty(name)) {\n        throw new Error(\"a transform by that name already exists\");\n      }\n\n      this.transforms[name] = transform;\n    };\n\n    /**\n     * Updates a named collection transform to the collection\n     * @param {string} name - name to associate with transform\n     * @param {object} transform - a transformation object to save into collection\n     * @memberof Collection\n     */\n    Collection.prototype.setTransform = function (name, transform) {\n      this.transforms[name] = transform;\n    };\n\n    /**\n     * Removes a named collection transform from the collection\n     * @param {string} name - name of collection transform to remove\n     * @memberof Collection\n     */\n    Collection.prototype.removeTransform = function (name) {\n      delete this.transforms[name];\n    };\n\n    Collection.prototype.byExample = function (template) {\n      var k, obj, query;\n      query = [];\n      for (k in template) {\n        if (!template.hasOwnProperty(k)) continue;\n        query.push((\n          obj = {},\n          obj[k] = template[k],\n          obj\n        ));\n      }\n      return {\n        '$and': query\n      };\n    };\n\n    Collection.prototype.findObject = function (template) {\n      return this.findOne(this.byExample(template));\n    };\n\n    Collection.prototype.findObjects = function (template) {\n      return this.find(this.byExample(template));\n    };\n\n    /*----------------------------+\n    | TTL daemon                  |\n    +----------------------------*/\n    Collection.prototype.ttlDaemonFuncGen = function () {\n      var collection = this;\n      var age = this.ttl.age;\n      return function ttlDaemon() {\n        var now = Date.now();\n        var toRemove = collection.chain().where(function daemonFilter(member) {\n          var timestamp = member.meta.updated || member.meta.created;\n          var diff = now - timestamp;\n          return age < diff;\n        });\n        toRemove.remove();\n      };\n    };\n\n    Collection.prototype.setTTL = function (age, interval) {\n      if (age < 0) {\n        clearInterval(this.ttl.daemon);\n      } else {\n        this.ttl.age = age;\n        this.ttl.ttlInterval = interval;\n        this.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n      }\n    };\n\n    /*----------------------------+\n    | INDEXING                    |\n    +----------------------------*/\n\n    /**\n     * create a row filter that covers all documents in the collection\n     */\n    Collection.prototype.prepareFullDocIndex = function () {\n      var len = this.data.length;\n      var indexes = new Array(len);\n      for (var i = 0; i < len; i += 1) {\n        indexes[i] = i;\n      }\n      return indexes;\n    };\n\n    /**\n     * Will allow reconfiguring certain collection options.\n     * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n     * @memberof Collection\n     */\n    Collection.prototype.configureOptions = function (options) {\n      options = options || {};\n\n      if (options.hasOwnProperty('adaptiveBinaryIndices')) {\n        this.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\n        // if switching to adaptive binary indices, make sure none are 'dirty'\n        if (this.adaptiveBinaryIndices) {\n          this.ensureAllIndexes();\n        }\n      }\n    };\n\n    /**\n     * Ensure binary index on a certain field\n     * @param {string} property - name of property to create binary index on\n     * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n     * @memberof Collection\n     */\n    Collection.prototype.ensureIndex = function (property, force) {\n      // optional parameter to force rebuild whether flagged as dirty or not\n      if (typeof (force) === 'undefined') {\n        force = false;\n      }\n\n      if (property === null || property === undefined) {\n        throw new Error('Attempting to set index without an associated property');\n      }\n\n      if (this.binaryIndices[property] && !force) {\n        if (!this.binaryIndices[property].dirty) return;\n      }\n\n      var index = {\n        'name': property,\n        'dirty': true,\n        'values': this.prepareFullDocIndex()\n      };\n      this.binaryIndices[property] = index;\n\n      var wrappedComparer =\n        (function (p, data) {\n          return function (a, b) {\n            var objAp = data[a][p],\n              objBp = data[b][p];\n            if (objAp !== objBp) {\n              if (ltHelper(objAp, objBp, false)) return -1;\n              if (gtHelper(objAp, objBp, false)) return 1;\n            }\n            return 0;\n          };\n        })(property, this.data);\n\n      index.values.sort(wrappedComparer);\n      index.dirty = false;\n\n      this.dirty = true; // for autosave scenarios\n    };\n\n    Collection.prototype.getSequencedIndexValues = function (property) {\n      var idx, idxvals = this.binaryIndices[property].values;\n      var result = \"\";\n\n      for (idx = 0; idx < idxvals.length; idx++) {\n        result += \" [\" + idx + \"] \" + this.data[idxvals[idx]][property];\n      }\n\n      return result;\n    };\n\n    Collection.prototype.ensureUniqueIndex = function (field) {\n      var index = this.constraints.unique[field];\n      if (!index) {\n        // keep track of new unique index for regenerate after database (re)load.\n        if (this.uniqueNames.indexOf(field) == -1) {\n          this.uniqueNames.push(field);\n        }\n      }\n\n      // if index already existed, (re)loading it will likely cause collisions, rebuild always\n      this.constraints.unique[field] = index = new UniqueIndex(field);\n      this.data.forEach(function (obj) {\n        index.set(obj);\n      });\n      return index;\n    };\n\n    /**\n     * Ensure all binary indices\n     */\n    Collection.prototype.ensureAllIndexes = function (force) {\n      var key, bIndices = this.binaryIndices;\n      for (key in bIndices) {\n        if (hasOwnProperty.call(bIndices, key)) {\n          this.ensureIndex(key, force);\n        }\n      }\n    };\n\n    Collection.prototype.flagBinaryIndexesDirty = function () {\n      var key, bIndices = this.binaryIndices;\n      for (key in bIndices) {\n        if (hasOwnProperty.call(bIndices, key)) {\n          bIndices[key].dirty = true;\n        }\n      }\n    };\n\n    Collection.prototype.flagBinaryIndexDirty = function (index) {\n      if (this.binaryIndices[index])\n        this.binaryIndices[index].dirty = true;\n    };\n\n    /**\n     * Quickly determine number of documents in collection (or query)\n     * @param {object=} query - (optional) query object to count results of\n     * @returns {number} number of documents in the collection\n     * @memberof Collection\n     */\n    Collection.prototype.count = function (query) {\n      if (!query) {\n        return this.data.length;\n      }\n\n      return this.chain().find(query).filteredrows.length;\n    };\n\n    /**\n     * Rebuild idIndex\n     */\n    Collection.prototype.ensureId = function () {\n      var len = this.data.length,\n        i = 0;\n\n      this.idIndex = [];\n      for (i; i < len; i += 1) {\n        this.idIndex.push(this.data[i].$loki);\n      }\n    };\n\n    /**\n     * Add a dynamic view to the collection\n     * @param {string} name - name of dynamic view to add\n     * @param {object=} options - (optional) options to configure dynamic view with\n     * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n     * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n     * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n     * @returns {DynamicView} reference to the dynamic view added\n     * @memberof Collection\n     **/\n\n    Collection.prototype.addDynamicView = function (name, options) {\n      var dv = new DynamicView(this, name, options);\n      this.DynamicViews.push(dv);\n\n      return dv;\n    };\n\n    /**\n     * Remove a dynamic view from the collection\n     * @param {string} name - name of dynamic view to remove\n     * @memberof Collection\n     **/\n    Collection.prototype.removeDynamicView = function (name) {\n      for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n        if (this.DynamicViews[idx].name === name) {\n          this.DynamicViews.splice(idx, 1);\n        }\n      }\n    };\n\n    /**\n     * Look up dynamic view reference from within the collection\n     * @param {string} name - name of dynamic view to retrieve reference of\n     * @returns {DynamicView} A reference to the dynamic view with that name\n     * @memberof Collection\n     **/\n    Collection.prototype.getDynamicView = function (name) {\n      for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n        if (this.DynamicViews[idx].name === name) {\n          return this.DynamicViews[idx];\n        }\n      }\n\n      return null;\n    };\n\n    /**\n     * find and update: pass a filtering function to select elements to be updated\n     * and apply the updatefunctino to those elements iteratively\n     * @param {function} filterFunction - filter function whose results will execute update\n     * @param {function} updateFunction - update function to run against filtered documents\n     * @memberof Collection\n     */\n    Collection.prototype.findAndUpdate = function (filterFunction, updateFunction) {\n      var results = this.where(filterFunction),\n        i = 0,\n        obj;\n      try {\n        for (i; i < results.length; i++) {\n          obj = updateFunction(results[i]);\n          this.update(obj);\n        }\n\n      } catch (err) {\n        this.rollback();\n        this.console.error(err.message);\n      }\n    };\n\n    /**\n     * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n     * @param {(object|array)} doc - the document (or array of documents) to be inserted\n     * @returns {(object|array)} document or documents inserted\n     * @memberof Collection\n     */\n    Collection.prototype.insert = function (doc) {\n      if (!Array.isArray(doc)) {\n        return this.insertOne(doc);\n      }\n\n      // holder to the clone of the object inserted if collections is set to clone objects\n      var obj;\n      var results = [];\n\n      this.emit('pre-insert', doc);\n      for (var i = 0, len = doc.length; i < len; i++) {\n        obj = this.insertOne(doc[i], true);\n        if (!obj) {\n          return undefined;\n        }\n        results.push(obj);\n      }\n      this.emit('insert', doc);\n      return results.length === 1 ? results[0] : results;\n    };\n\n    /**\n     * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n     * @param {object} doc - the document to be inserted\n     * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n     * @returns {object} document or 'undefined' if there was a problem inserting it\n     * @memberof Collection\n     */\n    Collection.prototype.insertOne = function (doc, bulkInsert) {\n      var err = null;\n      var returnObj;\n\n      if (typeof doc !== 'object') {\n        err = new TypeError('Document needs to be an object');\n      } else if (doc === null) {\n        err = new TypeError('Object cannot be null');\n      }\n\n      if (err !== null) {\n        this.emit('error', err);\n        throw err;\n      }\n\n      // if configured to clone, do so now... otherwise just use same obj reference\n      var obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n      if (typeof obj.meta === 'undefined') {\n        obj.meta = {\n          revision: 0,\n          created: 0\n        };\n      }\n\n      // if cloning, give user back clone of 'cloned' object with $loki and meta\n      returnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\n      // allow pre-insert to modify actual collection reference even if cloning\n      if (!bulkInsert) {\n        this.emit('pre-insert', obj);\n      }\n      if (!this.add(obj)) {\n        return undefined;\n      }\n\n      this.addAutoUpdateObserver(returnObj);\n      if (!bulkInsert) {\n        this.emit('insert', returnObj);\n      }\n      return returnObj;\n    };\n\n    /**\n     * Empties the collection.\n     * @memberof Collection\n     */\n    Collection.prototype.clear = function () {\n      this.data = [];\n      this.idIndex = [];\n      this.binaryIndices = {};\n      this.cachedIndex = null;\n      this.cachedBinaryIndex = null;\n      this.cachedData = null;\n      this.maxId = 0;\n      this.DynamicViews = [];\n      this.dirty = true;\n    };\n\n    /**\n     * Updates an object and notifies collection that the document has changed.\n     * @param {object} doc - document to update within the collection\n     * @memberof Collection\n     */\n    Collection.prototype.update = function (doc) {\n      if (Array.isArray(doc)) {\n        var k = 0,\n          len = doc.length;\n        for (k; k < len; k += 1) {\n          this.update(doc[k]);\n        }\n        return;\n      }\n\n      // verify object is a properly formed document\n      if (!hasOwnProperty.call(doc, '$loki')) {\n        throw new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n      }\n      try {\n        this.startTransaction();\n        var arr = this.get(doc.$loki, true),\n          oldInternal,   // ref to existing obj\n          newInternal, // ref to new internal obj\n          position,\n          self = this;\n\n        oldInternal = arr[0]; // -internal- obj ref\n        position = arr[1]; // position in data array\n\n        // if configured to clone, do so now... otherwise just use same obj reference\n        newInternal = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n        if (!arr) {\n          throw new Error('Trying to update a document not in collection.');\n        }\n        this.emit('pre-update', doc);\n\n        Object.keys(this.constraints.unique).forEach(function (key) {\n          self.constraints.unique[key].update(oldInternal, newInternal);\n        });\n\n        // operate the update\n        this.data[position] = newInternal;\n\n        if (newInternal !== doc) {\n          this.addAutoUpdateObserver(doc);\n        }\n\n        // now that we can efficiently determine the data[] position of newly added document,\n        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].evaluateDocument(position, false);\n        }\n\n        var key;\n        if (this.adaptiveBinaryIndices) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          var bIndices = this.binaryIndices;\n          for (key in bIndices) {\n            this.adaptiveBinaryIndexUpdate(position, key);\n          }\n        }\n        else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        this.idIndex[position] = newInternal.$loki;\n        //this.flagBinaryIndexesDirty();\n\n        this.commit();\n        this.dirty = true; // for autosave scenarios\n\n        this.emit('update', doc, this.cloneObjects ? clone(oldInternal, this.cloneMethod) : null);\n        return doc;\n      } catch (err) {\n        this.rollback();\n        this.console.error(err.message);\n        this.emit('error', err);\n        throw (err); // re-throw error so user does not think it succeeded\n      }\n    };\n\n    /**\n     * Add object to collection\n     */\n    Collection.prototype.add = function (obj) {\n      // if parameter isn't object exit with throw\n      if ('object' !== typeof obj) {\n        throw new TypeError('Object being added needs to be an object');\n      }\n      // if object you are adding already has id column it is either already in the collection\n      // or the object is carrying its own 'id' property.  If it also has a meta property,\n      // then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n      if (typeof (obj.$loki) !== 'undefined') {\n        throw new Error('Document is already in collection, please use update()');\n      }\n\n      /*\n       * try adding object to collection\n       */\n      try {\n        this.startTransaction();\n        this.maxId++;\n\n        if (isNaN(this.maxId)) {\n          this.maxId = (this.data[this.data.length - 1].$loki + 1);\n        }\n\n        obj.$loki = this.maxId;\n        obj.meta.version = 0;\n\n        var key, constrUnique = this.constraints.unique;\n        for (key in constrUnique) {\n          if (hasOwnProperty.call(constrUnique, key)) {\n            constrUnique[key].set(obj);\n          }\n        }\n\n        // add new obj id to idIndex\n        this.idIndex.push(obj.$loki);\n\n        // add the object\n        this.data.push(obj);\n\n        var addedPos = this.data.length - 1;\n\n        // now that we can efficiently determine the data[] position of newly added document,\n        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n        var dvlen = this.DynamicViews.length;\n        for (var i = 0; i < dvlen; i++) {\n          this.DynamicViews[i].evaluateDocument(addedPos, true);\n        }\n\n        if (this.adaptiveBinaryIndices) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          var bIndices = this.binaryIndices;\n          for (key in bIndices) {\n            this.adaptiveBinaryIndexInsert(addedPos, key);\n          }\n        }\n        else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        this.commit();\n        this.dirty = true; // for autosave scenarios\n\n        return (this.cloneObjects) ? (clone(obj, this.cloneMethod)) : (obj);\n      } catch (err) {\n        this.rollback();\n        this.console.error(err.message);\n        this.emit('error', err);\n        throw (err); // re-throw error so user does not think it succeeded\n      }\n    };\n\n    /**\n     * Remove all documents matching supplied filter object\n     * @param {object} query - query object to filter on\n     * @memberof Collection\n     */\n    Collection.prototype.removeWhere = function (query) {\n      var list;\n      if (typeof query === 'function') {\n        list = this.data.filter(query);\n      } else {\n        list = new Resultset(this, {\n          queryObj: query\n        });\n      }\n      this.remove(list);\n    };\n\n    Collection.prototype.removeDataOnly = function () {\n      this.remove(this.data.slice());\n    };\n\n    /**\n     * Remove a document from the collection\n     * @param {object} doc - document to remove from collection\n     * @memberof Collection\n     */\n    Collection.prototype.remove = function (doc) {\n      if (typeof doc === 'number') {\n        doc = this.get(doc);\n      }\n\n      if ('object' !== typeof doc) {\n        throw new Error('Parameter is not an object');\n      }\n      if (Array.isArray(doc)) {\n        var k = 0,\n          len = doc.length;\n        for (k; k < len; k += 1) {\n          this.remove(doc[k]);\n        }\n        return;\n      }\n\n      if (!hasOwnProperty.call(doc, '$loki')) {\n        throw new Error('Object is not a document stored in the collection');\n      }\n\n      try {\n        this.startTransaction();\n        var arr = this.get(doc.$loki, true),\n          // obj = arr[0],\n          position = arr[1];\n        var self = this;\n        Object.keys(this.constraints.unique).forEach(function (key) {\n          if (doc[key] !== null && typeof doc[key] !== 'undefined') {\n            self.constraints.unique[key].remove(doc[key]);\n          }\n        });\n        // now that we can efficiently determine the data[] position of newly added document,\n        // submit it for all registered DynamicViews to remove\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].removeDocument(position);\n        }\n\n        if (this.adaptiveBinaryIndices) {\n          // for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n          var key, bIndices = this.binaryIndices;\n          for (key in bIndices) {\n            this.adaptiveBinaryIndexRemove(position, key);\n          }\n        }\n        else {\n          this.flagBinaryIndexesDirty();\n        }\n\n        this.data.splice(position, 1);\n        this.removeAutoUpdateObserver(doc);\n\n        // remove id from idIndex\n        this.idIndex.splice(position, 1);\n\n        this.commit();\n        this.dirty = true; // for autosave scenarios\n        this.emit('delete', arr[0]);\n        delete doc.$loki;\n        delete doc.meta;\n        return doc;\n\n      } catch (err) {\n        this.rollback();\n        this.console.error(err.message);\n        this.emit('error', err);\n        return null;\n      }\n    };\n\n    /*---------------------+\n    | Finding methods     |\n    +----------------------*/\n\n    /**\n     * Get by Id - faster than other methods because of the searching algorithm\n     * @param {int} id - $loki id of document you want to retrieve\n     * @param {boolean} returnPosition - if 'true' we will return [object, position]\n     * @returns {(object|array|null)} Object reference if document was found, null if not,\n     *     or an array if 'returnPosition' was passed.\n     * @memberof Collection\n     */\n    Collection.prototype.get = function (id, returnPosition) {\n      var retpos = returnPosition || false,\n        data = this.idIndex,\n        max = data.length - 1,\n        min = 0,\n        mid = (min + max) >> 1;\n\n      id = typeof id === 'number' ? id : parseInt(id, 10);\n\n      if (isNaN(id)) {\n        throw new TypeError('Passed id is not an integer');\n      }\n\n      while (data[min] < data[max]) {\n        mid = (min + max) >> 1;\n\n        if (data[mid] < id) {\n          min = mid + 1;\n        } else {\n          max = mid;\n        }\n      }\n\n      if (max === min && data[min] === id) {\n        if (retpos) {\n          return [this.data[min], min];\n        }\n        return this.data[min];\n      }\n      return null;\n\n    };\n\n    /**\n     * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n     *    Since multiple documents may contain the same value (which the index is sorted on),\n     *    we hone in on range and then linear scan range to find exact index array position.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n    Collection.prototype.getBinaryIndexPosition = function(dataPosition, binaryIndexName) {\n      var val = this.data[dataPosition][binaryIndexName];\n      var index = this.binaryIndices[binaryIndexName].values;\n\n      // i think calculateRange can probably be moved to collection\n      // as it doesn't seem to need resultset.  need to verify\n      //var rs = new Resultset(this, null, null);\n      var range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n      if (range[0] === 0 && range[1] === -1) {\n        // uhoh didn't find range\n        return null;\n      }\n\n      var min = range[0];\n      var max = range[1];\n\n      // narrow down the sub-segment of index values\n      // where the indexed property value exactly matches our\n      // value and then linear scan to find exact -index- position\n      for(var idx = min; idx <= max; idx++) {\n        if (index[idx] === dataPosition) return idx;\n      }\n\n      // uhoh\n      return null;\n    };\n\n    /**\n     * Adaptively insert a selected item to the index.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n    Collection.prototype.adaptiveBinaryIndexInsert = function(dataPosition, binaryIndexName) {\n      var index = this.binaryIndices[binaryIndexName].values;\n      var val = this.data[dataPosition][binaryIndexName];\n      //var rs = new Resultset(this, null, null);\n      var idxPos = this.calculateRangeStart(binaryIndexName, val);\n\n      // insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n      // doing this after adjusting dataPositions so no clash with previous item at that position.\n      this.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n    };\n\n    /**\n     * Adaptively update a selected item within an index.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n    Collection.prototype.adaptiveBinaryIndexUpdate = function(dataPosition, binaryIndexName) {\n      // linear scan needed to find old position within index unless we optimize for clone scenarios later\n      // within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n      var idxPos,\n        index = this.binaryIndices[binaryIndexName].values,\n        len=index.length;\n\n      for(idxPos=0; idxPos < len; idxPos++) {\n        if (index[idxPos] === dataPosition) break;\n      }\n\n      //var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n      //this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n      this.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n    };\n\n    /**\n     * Adaptively remove a selected item from the index.\n     * @param {int} dataPosition : coll.data array index/position\n     * @param {string} binaryIndexName : index to search for dataPosition in\n     */\n    Collection.prototype.adaptiveBinaryIndexRemove = function(dataPosition, binaryIndexName, removedFromIndexOnly) {\n      var idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n      var index = this.binaryIndices[binaryIndexName].values;\n      var len,\n        idx;\n\n      if (idxPos === null) {\n        // throw new Error('unable to determine binary index position');\n        return null;\n      }\n\n      // remove document from index\n      this.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n      // if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n      // in which case data positions stay the same.\n      if (removedFromIndexOnly === true) {\n        return;\n      }\n\n      // since index stores data array positions, if we remove a document\n      // we need to adjust array positions -1 for all document positions greater than removed position\n      len = index.length;\n      for (idx = 0; idx < len; idx++) {\n        if (index[idx] > dataPosition) {\n          index[idx]--;\n        }\n      }\n    };\n\n    /**\n     * Internal method used for index maintenance.  Given a prop (index name), and a value\n     * (which may or may not yet exist) this will find the proper location where it can be added.\n     */\n    Collection.prototype.calculateRangeStart = function (prop, val) {\n      var rcd = this.data;\n      var index = this.binaryIndices[prop].values;\n      var min = 0;\n      var max = index.length - 1;\n      var mid = 0;\n\n      if (index.length === 0) {\n        return 0;\n      }\n\n      var minVal = rcd[index[min]][prop];\n      var maxVal = rcd[index[max]][prop];\n\n      // hone in on start position of value\n      while (min < max) {\n        mid = (min + max) >> 1;\n\n        if (ltHelper(rcd[index[mid]][prop], val, false)) {\n          min = mid + 1;\n        } else {\n          max = mid;\n        }\n      }\n\n      var lbound = min;\n\n      if (ltHelper(rcd[index[lbound]][prop], val, false)) {\n        return lbound+1;\n      }\n      else {\n        return lbound;\n      }\n    };\n\n    /**\n     * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n     *    this is used for collection.find() and first find filter of resultset/dynview\n     *    slightly different than get() binary search in that get() hones in on 1 value,\n     *    but we have to hone in on many (range)\n     * @param {string} op - operation, such as $eq\n     * @param {string} prop - name of property to calculate range for\n     * @param {object} val - value to use for range calculation.\n     * @returns {array} [start, end] index array positions\n     */\n    Collection.prototype.calculateRange = function (op, prop, val) {\n      var rcd = this.data;\n      var index = this.binaryIndices[prop].values;\n      var min = 0;\n      var max = index.length - 1;\n      var mid = 0;\n\n      // when no documents are in collection, return empty range condition\n      if (rcd.length === 0) {\n        return [0, -1];\n      }\n\n      var minVal = rcd[index[min]][prop];\n      var maxVal = rcd[index[max]][prop];\n\n      // if value falls outside of our range return [0, -1] to designate no results\n      switch (op) {\n      case '$eq':\n      case '$aeq':\n        if (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n          return [0, -1];\n        }\n        break;\n      case '$dteq':\n        if (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n          return [0, -1];\n        }\n        break;\n      case '$gt':\n        if (gtHelper(val, maxVal, true)) {\n          return [0, -1];\n        }\n        break;\n      case '$gte':\n        if (gtHelper(val, maxVal, false)) {\n          return [0, -1];\n        }\n        break;\n      case '$lt':\n        if (ltHelper(val, minVal, true)) {\n          return [0, -1];\n        }\n        if (ltHelper(maxVal, val, false)) {\n          return [0, rcd.length - 1];\n        }\n        break;\n      case '$lte':\n        if (ltHelper(val, minVal, false)) {\n          return [0, -1];\n        }\n        if (ltHelper(maxVal, val, true)) {\n          return [0, rcd.length - 1];\n        }\n        break;\n      }\n\n      // hone in on start position of value\n      while (min < max) {\n        mid = (min + max) >> 1;\n\n        if (ltHelper(rcd[index[mid]][prop], val, false)) {\n          min = mid + 1;\n        } else {\n          max = mid;\n        }\n      }\n\n      var lbound = min;\n\n      // do not reset min, as the upper bound cannot be prior to the found low bound\n      max = index.length - 1;\n\n      // hone in on end position of value\n      while (min < max) {\n        mid = (min + max) >> 1;\n\n        if (ltHelper(val, rcd[index[mid]][prop], false)) {\n          max = mid;\n        } else {\n          min = mid + 1;\n        }\n      }\n\n      var ubound = max;\n\n      var lval = rcd[index[lbound]][prop];\n      var uval = rcd[index[ubound]][prop];\n\n      switch (op) {\n      case '$eq':\n        if (lval !== val) {\n          return [0, -1];\n        }\n        if (uval !== val) {\n          ubound--;\n        }\n\n        return [lbound, ubound];\n      case '$dteq':\n        if (lval > val || lval < val) {\n          return [0, -1];\n        }\n        if (uval > val || uval < val) {\n          ubound--;\n        }\n\n        return [lbound, ubound];\n\n\n      case '$gt':\n        if (ltHelper(uval, val, true)) {\n          return [0, -1];\n        }\n\n        return [ubound, rcd.length - 1];\n\n      case '$gte':\n        if (ltHelper(lval, val, false)) {\n          return [0, -1];\n        }\n\n        return [lbound, rcd.length - 1];\n\n      case '$lt':\n        if (lbound === 0 && ltHelper(lval, val, false)) {\n          return [0, 0];\n        }\n        return [0, lbound - 1];\n\n      case '$lte':\n        if (uval !== val) {\n          ubound--;\n        }\n\n        if (ubound === 0 && ltHelper(uval, val, false)) {\n          return [0, 0];\n        }\n        return [0, ubound];\n\n      default:\n        return [0, rcd.length - 1];\n      }\n    };\n\n    /**\n     * Retrieve doc by Unique index\n     * @param {string} field - name of uniquely indexed property to use when doing lookup\n     * @param {value} value - unique value to search for\n     * @returns {object} document matching the value passed\n     * @memberof Collection\n     */\n    Collection.prototype.by = function (field, value) {\n      var self;\n      if (value === undefined) {\n        self = this;\n        return function (value) {\n          return self.by(field, value);\n        };\n      }\n\n      var result = this.constraints.unique[field].get(value);\n      if (!this.cloneObjects) {\n        return result;\n      } else {\n        return clone(result, this.cloneMethod);\n      }\n    };\n\n    /**\n     * Find one object by index property, by property equal to value\n     * @param {object} query - query object used to perform search with\n     * @returns {(object|null)} First matching document, or null if none\n     * @memberof Collection\n     */\n    Collection.prototype.findOne = function (query) {\n      query = query || {};\n\n      // Instantiate Resultset and exec find op passing firstOnly = true param\n      var result = new Resultset(this, {\n        queryObj: query,\n        firstOnly: true\n      });\n\n      if (Array.isArray(result) && result.length === 0) {\n        return null;\n      } else {\n        if (!this.cloneObjects) {\n          return result;\n        } else {\n          return clone(result, this.cloneMethod);\n        }\n      }\n    };\n\n    /**\n     * Chain method, used for beginning a series of chained find() and/or view() operations\n     * on a collection.\n     *\n     * @param {array} transform - Ordered array of transform step objects similar to chain\n     * @param {object} parameters - Object containing properties representing parameters to substitute\n     * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n     * @memberof Collection\n     */\n    Collection.prototype.chain = function (transform, parameters) {\n      var rs = new Resultset(this);\n\n      if (typeof transform === 'undefined') {\n        return rs;\n      }\n\n      return rs.transform(transform, parameters);\n    };\n\n    /**\n     * Find method, api is similar to mongodb.\n     * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n     * @example {@tutorial Query Examples}\n     * @param {object} query - 'mongo-like' query object\n     * @returns {array} Array of matching documents\n     * @memberof Collection\n     */\n    Collection.prototype.find = function (query) {\n      if (typeof (query) === 'undefined') {\n        query = 'getAll';\n      }\n\n      var results = new Resultset(this, {\n        queryObj: query\n      });\n      if (!this.cloneObjects) {\n        return results;\n      } else {\n        return cloneObjectArray(results, this.cloneMethod);\n      }\n    };\n\n    /**\n     * Find object by unindexed field by property equal to value,\n     * simply iterates and returns the first element matching the query\n     */\n    Collection.prototype.findOneUnindexed = function (prop, value) {\n      var i = this.data.length,\n        doc;\n      while (i--) {\n        if (this.data[i][prop] === value) {\n          doc = this.data[i];\n          return doc;\n        }\n      }\n      return null;\n    };\n\n    /**\n     * Transaction methods\n     */\n\n    /** start the transation */\n    Collection.prototype.startTransaction = function () {\n      if (this.transactional) {\n        this.cachedData = clone(this.data, this.cloneMethod);\n        this.cachedIndex = this.idIndex;\n        this.cachedBinaryIndex = this.binaryIndices;\n\n        // propagate startTransaction to dynamic views\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].startTransaction();\n        }\n      }\n    };\n\n    /** commit the transation */\n    Collection.prototype.commit = function () {\n      if (this.transactional) {\n        this.cachedData = null;\n        this.cachedIndex = null;\n        this.cachedBinaryIndex = null;\n\n        // propagate commit to dynamic views\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].commit();\n        }\n      }\n    };\n\n    /** roll back the transation */\n    Collection.prototype.rollback = function () {\n      if (this.transactional) {\n        if (this.cachedData !== null && this.cachedIndex !== null) {\n          this.data = this.cachedData;\n          this.idIndex = this.cachedIndex;\n          this.binaryIndices = this.cachedBinaryIndex;\n        }\n\n        // propagate rollback to dynamic views\n        for (var idx = 0; idx < this.DynamicViews.length; idx++) {\n          this.DynamicViews[idx].rollback();\n        }\n      }\n    };\n\n    /**\n     * Query the collection by supplying a javascript filter function.\n     * @example\n     * var results = coll.where(function(obj) {\n     *   return obj.legs === 8;\n     * });\n     *\n     * @param {function} fun - filter function to run against all collection docs\n     * @returns {array} all documents which pass your filter function\n     * @memberof Collection\n     */\n    Collection.prototype.where = function (fun) {\n      var results = new Resultset(this, {\n        queryFunc: fun\n      });\n      if (!this.cloneObjects) {\n        return results;\n      } else {\n        return cloneObjectArray(results, this.cloneMethod);\n      }\n    };\n\n    /**\n     * Map Reduce operation\n     *\n     * @param {function} mapFunction - function to use as map function\n     * @param {function} reduceFunction - function to use as reduce function\n     * @returns {data} The result of your mapReduce operation\n     * @memberof Collection\n     */\n    Collection.prototype.mapReduce = function (mapFunction, reduceFunction) {\n      try {\n        return reduceFunction(this.data.map(mapFunction));\n      } catch (err) {\n        throw err;\n      }\n    };\n\n    /**\n     * Join two collections on specified properties\n     *\n     * @param {array} joinData - array of documents to 'join' to this collection\n     * @param {string} leftJoinProp - property name in collection\n     * @param {string} rightJoinProp - property name in joinData\n     * @param {function=} mapFun - (Optional) map function to use\n     * @returns {Resultset} Result of the mapping operation\n     * @memberof Collection\n     */\n    Collection.prototype.eqJoin = function (joinData, leftJoinProp, rightJoinProp, mapFun) {\n      // logic in Resultset class\n      return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);\n    };\n\n    /* ------ STAGING API -------- */\n    /**\n     * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n     * manipulated without affecting the data in the original collection\n     */\n    Collection.prototype.stages = {};\n\n    /**\n     * (Staging API) create a stage and/or retrieve it\n     * @memberof Collection\n     */\n    Collection.prototype.getStage = function (name) {\n      if (!this.stages[name]) {\n        this.stages[name] = {};\n      }\n      return this.stages[name];\n    };\n    /**\n     * a collection of objects recording the changes applied through a commmitStage\n     */\n    Collection.prototype.commitLog = [];\n\n    /**\n     * (Staging API) create a copy of an object and insert it into a stage\n     * @memberof Collection\n     */\n    Collection.prototype.stage = function (stageName, obj) {\n      var copy = JSON.parse(JSON.stringify(obj));\n      this.getStage(stageName)[obj.$loki] = copy;\n      return copy;\n    };\n\n    /**\n     * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n     * then create a message to be inserted in the commitlog\n     * @param {string} stageName - name of stage\n     * @param {string} message\n     * @memberof Collection\n     */\n    Collection.prototype.commitStage = function (stageName, message) {\n      var stage = this.getStage(stageName),\n        prop,\n        timestamp = new Date().getTime();\n\n      for (prop in stage) {\n\n        this.update(stage[prop]);\n        this.commitLog.push({\n          timestamp: timestamp,\n          message: message,\n          data: JSON.parse(JSON.stringify(stage[prop]))\n        });\n      }\n      this.stages[stageName] = {};\n    };\n\n    Collection.prototype.no_op = function () {\n      return;\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.extract = function (field) {\n      var i = 0,\n        len = this.data.length,\n        isDotNotation = isDeepProperty(field),\n        result = [];\n      for (i; i < len; i += 1) {\n        result.push(deepProperty(this.data[i], field, isDotNotation));\n      }\n      return result;\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.max = function (field) {\n      return Math.max.apply(null, this.extract(field));\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.min = function (field) {\n      return Math.min.apply(null, this.extract(field));\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.maxRecord = function (field) {\n      var i = 0,\n        len = this.data.length,\n        deep = isDeepProperty(field),\n        result = {\n          index: 0,\n          value: undefined\n        },\n        max;\n\n      for (i; i < len; i += 1) {\n        if (max !== undefined) {\n          if (max < deepProperty(this.data[i], field, deep)) {\n            max = deepProperty(this.data[i], field, deep);\n            result.index = this.data[i].$loki;\n          }\n        } else {\n          max = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      }\n      result.value = max;\n      return result;\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.minRecord = function (field) {\n      var i = 0,\n        len = this.data.length,\n        deep = isDeepProperty(field),\n        result = {\n          index: 0,\n          value: undefined\n        },\n        min;\n\n      for (i; i < len; i += 1) {\n        if (min !== undefined) {\n          if (min > deepProperty(this.data[i], field, deep)) {\n            min = deepProperty(this.data[i], field, deep);\n            result.index = this.data[i].$loki;\n          }\n        } else {\n          min = deepProperty(this.data[i], field, deep);\n          result.index = this.data[i].$loki;\n        }\n      }\n      result.value = min;\n      return result;\n    };\n\n    /**\n     * @memberof Collection\n     */\n    Collection.prototype.extractNumerical = function (field) {\n      return this.extract(field).map(parseBase10).filter(Number).filter(function (n) {\n        return !(isNaN(n));\n      });\n    };\n\n    /**\n     * Calculates the average numerical value of a property\n     *\n     * @param {string} field - name of property in docs to average\n     * @returns {number} average of property in all docs in the collection\n     * @memberof Collection\n     */\n    Collection.prototype.avg = function (field) {\n      return average(this.extractNumerical(field));\n    };\n\n    /**\n     * Calculate standard deviation of a field\n     * @memberof Collection\n     * @param {string} field\n     */\n    Collection.prototype.stdDev = function (field) {\n      return standardDeviation(this.extractNumerical(field));\n    };\n\n    /**\n     * @memberof Collection\n     * @param {string} field\n     */\n    Collection.prototype.mode = function (field) {\n      var dict = {},\n        data = this.extract(field);\n      data.forEach(function (obj) {\n        if (dict[obj]) {\n          dict[obj] += 1;\n        } else {\n          dict[obj] = 1;\n        }\n      });\n      var max,\n        prop, mode;\n      for (prop in dict) {\n        if (max) {\n          if (max < dict[prop]) {\n            mode = prop;\n          }\n        } else {\n          mode = prop;\n          max = dict[prop];\n        }\n      }\n      return mode;\n    };\n\n    /**\n     * @memberof Collection\n     * @param {string} field - property name\n     */\n    Collection.prototype.median = function (field) {\n      var values = this.extractNumerical(field);\n      values.sort(sub);\n\n      var half = Math.floor(values.length / 2);\n\n      if (values.length % 2) {\n        return values[half];\n      } else {\n        return (values[half - 1] + values[half]) / 2.0;\n      }\n    };\n\n    /**\n     * General utils, including statistical functions\n     */\n    function isDeepProperty(field) {\n      return field.indexOf('.') !== -1;\n    }\n\n    function parseBase10(num) {\n      return parseFloat(num, 10);\n    }\n\n    function isNotUndefined(obj) {\n      return obj !== undefined;\n    }\n\n    function add(a, b) {\n      return a + b;\n    }\n\n    function sub(a, b) {\n      return a - b;\n    }\n\n    function median(values) {\n      values.sort(sub);\n      var half = Math.floor(values.length / 2);\n      return (values.length % 2) ? values[half] : ((values[half - 1] + values[half]) / 2.0);\n    }\n\n    function average(array) {\n      return (array.reduce(add, 0)) / array.length;\n    }\n\n    function standardDeviation(values) {\n      var avg = average(values);\n      var squareDiffs = values.map(function (value) {\n        var diff = value - avg;\n        var sqrDiff = diff * diff;\n        return sqrDiff;\n      });\n\n      var avgSquareDiff = average(squareDiffs);\n\n      var stdDev = Math.sqrt(avgSquareDiff);\n      return stdDev;\n    }\n\n    function deepProperty(obj, property, isDeep) {\n      if (isDeep === false) {\n        // pass without processing\n        return obj[property];\n      }\n      var pieces = property.split('.'),\n        root = obj;\n      while (pieces.length > 0) {\n        root = root[pieces.shift()];\n      }\n      return root;\n    }\n\n    function binarySearch(array, item, fun) {\n      var lo = 0,\n        hi = array.length,\n        compared,\n        mid;\n      while (lo < hi) {\n        mid = (lo + hi) >> 1;\n        compared = fun.apply(null, [item, array[mid]]);\n        if (compared === 0) {\n          return {\n            found: true,\n            index: mid\n          };\n        } else if (compared < 0) {\n          hi = mid;\n        } else {\n          lo = mid + 1;\n        }\n      }\n      return {\n        found: false,\n        index: hi\n      };\n    }\n\n    function BSonSort(fun) {\n      return function (array, item) {\n        return binarySearch(array, item, fun);\n      };\n    }\n\n    function KeyValueStore() {}\n\n    KeyValueStore.prototype = {\n      keys: [],\n      values: [],\n      sort: function (a, b) {\n        return (a < b) ? -1 : ((a > b) ? 1 : 0);\n      },\n      setSort: function (fun) {\n        this.bs = new BSonSort(fun);\n      },\n      bs: function () {\n        return new BSonSort(this.sort);\n      },\n      set: function (key, value) {\n        var pos = this.bs(this.keys, key);\n        if (pos.found) {\n          this.values[pos.index] = value;\n        } else {\n          this.keys.splice(pos.index, 0, key);\n          this.values.splice(pos.index, 0, value);\n        }\n      },\n      get: function (key) {\n        return this.values[binarySearch(this.keys, key, this.sort).index];\n      }\n    };\n\n    function UniqueIndex(uniqueField) {\n      this.field = uniqueField;\n      this.keyMap = {};\n      this.lokiMap = {};\n    }\n    UniqueIndex.prototype.keyMap = {};\n    UniqueIndex.prototype.lokiMap = {};\n    UniqueIndex.prototype.set = function (obj) {\n      var fieldValue = obj[this.field];\n      if (fieldValue !== null && typeof (fieldValue) !== 'undefined') {\n        if (this.keyMap[fieldValue]) {\n          throw new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n        } else {\n          this.keyMap[fieldValue] = obj;\n          this.lokiMap[obj.$loki] = fieldValue;\n        }\n      }\n    };\n    UniqueIndex.prototype.get = function (key) {\n      return this.keyMap[key];\n    };\n\n    UniqueIndex.prototype.byId = function (id) {\n      return this.keyMap[this.lokiMap[id]];\n    };\n    /**\n     * Updates a document's unique index given an updated object.\n     * @param  {Object} obj Original document object\n     * @param  {Object} doc New document object (likely the same as obj)\n     */\n    UniqueIndex.prototype.update = function (obj, doc) {\n      if (this.lokiMap[obj.$loki] !== doc[this.field]) {\n        var old = this.lokiMap[obj.$loki];\n        this.set(doc);\n        // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n        this.keyMap[old] = undefined;\n      } else {\n        this.keyMap[obj[this.field]] = doc;\n      }\n    };\n    UniqueIndex.prototype.remove = function (key) {\n      var obj = this.keyMap[key];\n      if (obj !== null && typeof obj !== 'undefined') {\n        this.keyMap[key] = undefined;\n        this.lokiMap[obj.$loki] = undefined;\n      } else {\n        throw new Error('Key is not in unique index: ' + this.field);\n      }\n    };\n    UniqueIndex.prototype.clear = function () {\n      this.keyMap = {};\n      this.lokiMap = {};\n    };\n\n    function ExactIndex(exactField) {\n      this.index = {};\n      this.field = exactField;\n    }\n\n    // add the value you want returned to the key in the index\n    ExactIndex.prototype = {\n      set: function add(key, val) {\n        if (this.index[key]) {\n          this.index[key].push(val);\n        } else {\n          this.index[key] = [val];\n        }\n      },\n\n      // remove the value from the index, if the value was the last one, remove the key\n      remove: function remove(key, val) {\n        var idxSet = this.index[key];\n        for (var i in idxSet) {\n          if (idxSet[i] == val) {\n            idxSet.splice(i, 1);\n          }\n        }\n        if (idxSet.length < 1) {\n          this.index[key] = undefined;\n        }\n      },\n\n      // get the values related to the key, could be more than one\n      get: function get(key) {\n        return this.index[key];\n      },\n\n      // clear will zap the index\n      clear: function clear(key) {\n        this.index = {};\n      }\n    };\n\n    function SortedIndex(sortedField) {\n      this.field = sortedField;\n    }\n\n    SortedIndex.prototype = {\n      keys: [],\n      values: [],\n      // set the default sort\n      sort: function (a, b) {\n        return (a < b) ? -1 : ((a > b) ? 1 : 0);\n      },\n      bs: function () {\n        return new BSonSort(this.sort);\n      },\n      // and allow override of the default sort\n      setSort: function (fun) {\n        this.bs = new BSonSort(fun);\n      },\n      // add the value you want returned  to the key in the index\n      set: function (key, value) {\n        var pos = binarySearch(this.keys, key, this.sort);\n        if (pos.found) {\n          this.values[pos.index].push(value);\n        } else {\n          this.keys.splice(pos.index, 0, key);\n          this.values.splice(pos.index, 0, [value]);\n        }\n      },\n      // get all values which have a key == the given key\n      get: function (key) {\n        var bsr = binarySearch(this.keys, key, this.sort);\n        if (bsr.found) {\n          return this.values[bsr.index];\n        } else {\n          return [];\n        }\n      },\n      // get all values which have a key < the given key\n      getLt: function (key) {\n        var bsr = binarySearch(this.keys, key, this.sort);\n        var pos = bsr.index;\n        if (bsr.found) pos--;\n        return this.getAll(key, 0, pos);\n      },\n      // get all values which have a key > the given key\n      getGt: function (key) {\n        var bsr = binarySearch(this.keys, key, this.sort);\n        var pos = bsr.index;\n        if (bsr.found) pos++;\n        return this.getAll(key, pos, this.keys.length);\n      },\n\n      // get all vals from start to end\n      getAll: function (key, start, end) {\n        var results = [];\n        for (var i = start; i < end; i++) {\n          results = results.concat(this.values[i]);\n        }\n        return results;\n      },\n      // just in case someone wants to do something smart with ranges\n      getPos: function (key) {\n        return binarySearch(this.keys, key, this.sort);\n      },\n      // remove the value from the index, if the value was the last one, remove the key\n      remove: function (key, value) {\n        var pos = binarySearch(this.keys, key, this.sort).index;\n        var idxSet = this.values[pos];\n        for (var i in idxSet) {\n          if (idxSet[i] == value) idxSet.splice(i, 1);\n        }\n        if (idxSet.length < 1) {\n          this.keys.splice(pos, 1);\n          this.values.splice(pos, 1);\n        }\n      },\n      // clear will zap the index\n      clear: function () {\n        this.keys = [];\n        this.values = [];\n      }\n    };\n\n\n    Loki.LokiOps = LokiOps;\n    Loki.Collection = Collection;\n    Loki.KeyValueStore = KeyValueStore;\n    Loki.persistenceAdapters = {\n      fs: LokiFsAdapter,\n      localStorage: LokiLocalStorageAdapter\n    };\n    return Loki;\n  }());\n\n}));\n\n\n\n// WEBPACK FOOTER //\n// ./src/lokijs.js","module.exports = __WEBPACK_EXTERNAL_MODULE_14__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"fs\"\n// module id = 14\n// module chunks = 1"],"sourceRoot":""}