{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lokijs.core.min.js","webpack:///webpack/bootstrap da7d1153d4acd55453c4","webpack:///./src/core/index.js","webpack:///./src/core/lokicore.js","webpack:///./src/core/event_emitter.js","webpack:///./src/core/fs_adapter.js","webpack:///./src/core/local_storage_adapter.js","webpack:///./src/core/collection.js","webpack:///./src/core/unique_index.js","webpack:///./src/core/exact_index.js","webpack:///./src/core/resultset.js","webpack:///./src/core/clone.js","webpack:///./src/core/utils.js","webpack:///./src/core/helper.js","webpack:///./src/core/dynamic_view.js","webpack:///./src/core/loki-indexed-adapter.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_lokicore","Loki","global","Object","defineProperty","value","undefined","_event_emitter","_fs_adapter","_local_storage_adapter","_collection","_utils","LokiEventEmitter","constructor","filename","options","super","collections","databaseVersion","engineVersion","autosave","autosaveInterval","autosaveHandle","serializationMethod","hasOwnProperty","destructureDelimiter","persistenceMethod","persistenceAdapter","verbose","events","init","flushChanges","close","changes","warning","getENV","window","document","URL","indexOf","ENV","env","on","clearChanges","getIndexedAdapter","adapter","initializePersistence","self","defaultPersistence","NODEJS","BROWSER","CORDOVA","persistenceMethods","fs","LokiFsAdapter","localStorage","LokiLocalStorageAdapter","parseInt","autosaveDisable","autoload","loadDatabase","inflate","Promise","resolve","then","autosaveEnable","copy","clen","idx","databaseCopy","loadJSONObject","retainDirtyFlags","removeNonSerializable","length","constraints","ttl","anonym","docs","collection","Collection","insert","console","addCollection","name","push","loadCollection","Error","getCollection","collectionName","i","len","emit","listCollections","colls","type","objType","count","data","removeCollection","tmpcol","curcol","prop","splice","getName","serializeReplacer","key","serialize","JSON","stringify","serializeDestructured","toJson","sidx","result","resultlen","dbcopy","reconstruct","partitioned","delimited","delimiter","partition","serializeCollection","collectionIndex","Array","isArray","join","doccount","docidx","resultlines","deserializeDestructured","destructuredSource","cdb","collCount","currLine","currObject","workarray","collIndex","lineIndex","done","parse","deserializeCollection","split","pop","loadJSON","serializedDb","dbObject","makeLoader","coll","inflater","collOptions","proto","Utils","copyProperties","collObj","copyColl","j","loader","adaptiveBinaryIndices","transactional","asyncListeners","disableChangesApi","cloneObjects","cloneMethod","autoupdate","dirty","addAutoUpdateObserver","maxId","idIndex","binaryIndices","transforms","ensureId","uniqueNames","ensureUniqueIndex","DynamicViews","colldv","dv","addDynamicView","resultdata","resultsdirty","filterPipeline","sortCriteria","sortFunction","sortDirty","resultset","filteredrows","searchIsChained","filterInitialized","rematerialize","removeWhereFilters","saved","autosaveDirty","saveDatabase","generateChangesNotification","arrayOfCollectionNames","getCollName","selectedCollections","map","forEach","concat","getChanges","serializeChanges","collectionNamesArray","reject","dbString","TypeError","mode","exportDatabase","autosaveClearFlags","save","deleteDatabase","running","setTimeout","eventName","listener","event","currentEventName","addListener","removeListener","listen","listeners","dbname","stat","err","stats","isFile","readFile","encoding","dbstring","tmpdbname","writeFile","rename","unlink","localStorageAvailable","e","getItem","setItem","removeItem","isDeepProperty","field","parseBase10","num","parseFloat","add","a","b","sub","average","array","reduce","standardDeviation","values","avg","squareDiffs","diff","sqrDiff","avgSquareDiff","stdDev","Math","sqrt","deepProperty","obj","property","isDeep","pieces","shift","_unique_index","_exact_index","_resultset","_dynamic_view","_clone","_helper","observerCallback","changedObjects","Set","object","change","removeAutoUpdateObserver","update","createChange","op","operation","insertMeta","meta","created","Date","getTime","revision","updateMeta","updated","createInsertChange","createUpdateChange","insertMetaWithChange","updateMetaWithChange","setHandlers","insertHandler","updateHandler","unique","exact","cachedIndex","cachedBinaryIndex","cachedData","UniqueIndex","ExactIndex","clone","age","ttlInterval","daemon","setTTL","pre-insert","pre-update","flushbuffer","error","delete","indices","prototype","toString","ensureIndex","setChangesApi","enabled","warn","log","stages","commitLog","observe","unobserve","addTransform","transform","setTransform","removeTransform","byExample","template","k","query","$and","findObject","findOne","findObjects","find","ttlDaemonFuncGen","now","toRemove","chain","where","member","timestamp","remove","interval","clearInterval","setInterval","prepareFullDocIndex","indexes","configureOptions","ensureAllIndexes","force","index","wrappedComparer","objAp","objBp","ltHelper","gtHelper","sort","getSequencedIndexValues","idxvals","set","bIndices","flagBinaryIndexesDirty","flagBinaryIndexDirty","$loki","DynamicView","removeDynamicView","getDynamicView","findAndUpdate","filterObject","updateFunction","updateWhere","findAndRemove","doc","insertOne","results","bulkInsert","returnObj","clear","removeIndices","keys","biname","uiname","startTransaction","oldInternal","newInternal","position","arr","get","evaluateDocument","adaptiveBinaryIndexUpdate","commit","rollback","message","isNaN","version","constrUnique","addedPos","dvlen","adaptiveBinaryIndexInsert","filterFunction","removeWhere","list","filter","removeDataOnly","slice","removeDocument","adaptiveBinaryIndexRemove","returnPosition","retpos","max","min","mid","getBinaryIndexPosition","dataPosition","binaryIndexName","val","range","calculateRange","idxPos","calculateRangeStart","removedFromIndexOnly","rcd","lbound","calculateRangeEnd","ubound","minVal","maxVal","idxset","segResult","seg","lval","uval","by","Resultset","queryObj","firstOnly","parameters","rs","cloneObjectArray","findOneUnindexed","fun","queryFunc","mapReduce","mapFunction","reduceFunction","eqJoin","joinData","leftJoinProp","rightJoinProp","mapFun","getStage","stage","stageName","commitStage","no_op","extract","isDotNotation","apply","maxRecord","deep","minRecord","extractNumerical","Number","n","dict","median","half","floor","uniqueField","keyMap","lokiMap","fieldValue","byId","old","exactField","idxSet","containsCheckFn","doQueryOp","LokiOps","sortHelper","prop1","prop2","desc","compoundeval","properties","obj1","obj2","res","dotSubScan","paths","poffset","pathOffset","path","valueFound","element","$eq","$aeq","$ne","$dteq","$gt","$gte","$lt","$lte","$between","vals","$in","$nin","$keyin","$nkeyin","$definedin","$undefinedin","$regex","test","$containsString","$containsNone","$containsAny","checkFn","some","$contains","every","$type","$size","$len","$where","$not","$or","indexedOpsList","reset","toJSON","limit","qty","rscopy","offset","pos","branch","step","resolveTransformParams","simplesort","compoundsort","leftJoinKey","rightJoinKey","instance","collectionOptions","instanceCollection","comparefun","userComparer","propname","isdesc","props","findOr","expressionArray","fr","fri","frlen","docset","origCount","ei","elen","arguments","findAnd","queryObjectOp","operator","queryObject","searchByIndex","RegExp","usingDotNotation","doIndexCheck","t","rowIdx","segm","viewFunction","method","forceClones","forceCloneMethod","leftDataLength","rightDataLength","leftData","rightData","leftKeyisFunction","rightKeyisFunction","joinMap","left","right","cloned","jQuery","extend","create","objarray","src","dest","resolveTransformObject","subObj","params","depth","pname","substring","clonedStep","resolvedTransform","equal","cv1","cv2","rebuildPending","persistent","sortPriority","minRebuildInterval","cachedresultset","rebuild","fpl","fpi","ofp","applyFind","branchResultset","removeFilters","queueSortPhase","applySort","applySimpleSort","applySortCriteria","criteria","_indexOfFilterWithId","uid","_addFilter","reapplyFilters","filters","queueRebuildEvent","applyFilter","applyWhere","removeFilter","performSortPhase","suppressRebuildEvent","objIndex","isNew","ofr","oldPos","oldlen","evalResultset","newPos","LokiIndexedAdapter","appname","app","catalog","checkAvailability","indexedDB","appName","db","LokiCatalog","cat","getAppKey","loadKey","saveCallback","success","rej","setAppKey","saveKey","deleteAppKey","deleteKey","deleteDatabasePartitions","getDatabaseList","str","startsWith","callback","getAppKeys","names","getKeyList","getCatalogSummary","getAllKeys","size","oapp","okey","oval","entries","initializeLokiCatalog","openRequest","open","onupgradeneeded","thisDB","target","objectStoreNames","contains","deleteObjectStore","objectStore","createObjectStore","keyPath","autoIncrement","createIndex","onsuccess","onerror","transaction","store","appkey","request","usercallback","lres","getAppKeyById","requestPut","put","evt","singleKeyRange","IDBKeyRange","only","cursor","openCursor","localdata","continue"],"mappings":"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","file":"lokijs.core.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"core\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"core\"] = factory();\n\telse\n\t\troot[\"lokijs\"] = root[\"lokijs\"] || {}, root[\"lokijs\"][\"core\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"core\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"core\"] = factory();\n\telse\n\t\troot[\"lokijs\"] = root[\"lokijs\"] || {}, root[\"lokijs\"][\"core\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _lokicore = __webpack_require__(1);\n\t\n\tmodule.exports = _lokicore.Loki;\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.Loki = undefined;\n\t\n\tvar _event_emitter = __webpack_require__(2);\n\t\n\tvar _fs_adapter = __webpack_require__(3);\n\t\n\tvar _local_storage_adapter = __webpack_require__(4);\n\t\n\tvar _collection = __webpack_require__(5);\n\t\n\tvar _utils = __webpack_require__(10);\n\t\n\t/*\n\t'LokiFsAdapter' is not defined                 no-undef\tx\n\t'LokiLocalStorageAdapter' is not defined       no-undef\tx\n\t'Collection' is not defined                    no-undef\tx\n\t'delim' is not defined                         no-undef\tx\n\t'Utils' is not defined                         no-undef\tx\n\t */\n\t\n\t/**\n\t * Loki: The main database class\n\t * @constructor Loki\n\t * @implements LokiEventEmitter\n\t * @param {string} filename - name of the file to be saved to\n\t * @param {object=} options - (Optional) config options object\n\t * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n\t * @param {boolean} options.verbose - enable console output (default is 'false')\n\t */\n\tclass Loki extends _event_emitter.LokiEventEmitter {\n\t\n\t\tconstructor(filename, options) {\n\t\t\tsuper();\n\t\t\tthis.filename = filename || 'loki.db';\n\t\t\tthis.collections = [];\n\t\n\t\t\t// persist version of code which created the database to the database.\n\t\t\t// could use for upgrade scenarios\n\t\t\tthis.databaseVersion = 1.1;\n\t\t\tthis.engineVersion = 1.1;\n\t\n\t\t\t// autosave support (disabled by default)\n\t\t\t// pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n\t\t\tthis.autosave = false;\n\t\t\tthis.autosaveInterval = 5000;\n\t\t\tthis.autosaveHandle = null;\n\t\n\t\t\tthis.options = {\n\t\t\t\tserializationMethod: options && options.hasOwnProperty('serializationMethod') ? options.serializationMethod : 'normal',\n\t\t\t\tdestructureDelimiter: options && options.hasOwnProperty('destructureDelimiter') ? options.destructureDelimiter : '$<\\n'\n\t\t\t};\n\t\n\t\t\t// currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n\t\t\t// will not or cannot be deserialized.  You are required to configure persistence every time\n\t\t\t// you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\t\n\t\t\t// persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n\t\t\t// this is optional option param, otherwise environment detection will be used\n\t\t\t// if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n\t\t\tthis.persistenceMethod = null;\n\t\n\t\t\t// retain reference to optional (non-serializable) persistenceAdapter 'instance'\n\t\t\tthis.persistenceAdapter = null;\n\t\n\t\t\t// enable console output if verbose flag is set (disabled by default)\n\t\t\tthis.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;\n\t\n\t\t\tthis.events = {\n\t\t\t\t'init': [],\n\t\t\t\t'loaded': [],\n\t\t\t\t'flushChanges': [],\n\t\t\t\t'close': [],\n\t\t\t\t'changes': [],\n\t\t\t\t'warning': []\n\t\t\t};\n\t\n\t\t\tvar getENV = function () {\n\t\t\t\tif (typeof window === 'undefined') {\n\t\t\t\t\treturn 'NODEJS';\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof global !== 'undefined' && global.window) {\n\t\t\t\t\treturn 'NODEJS'; //node-webkit\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof document !== 'undefined') {\n\t\t\t\t\tif (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n\t\t\t\t\t\treturn 'CORDOVA';\n\t\t\t\t\t}\n\t\t\t\t\treturn 'BROWSER';\n\t\t\t\t}\n\t\t\t\treturn 'CORDOVA';\n\t\t\t};\n\t\n\t\t\t// refactored environment detection due to invalid detection for browser environments.\n\t\t\t// if they do not specify an options.env we want to detect env rather than default to nodejs.\n\t\t\t// currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n\t\t\t//   might want to review whether we can consolidate.\n\t\t\tif (options && options.hasOwnProperty('env')) {\n\t\t\t\tthis.ENV = options.env;\n\t\t\t} else {\n\t\t\t\tthis.ENV = getENV();\n\t\t\t}\n\t\n\t\t\tthis.on('init', this.clearChanges);\n\t\t}\n\t\n\t\t// experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n\t\t// Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n\t\tgetIndexedAdapter() {\n\t\t\tvar adapter;\n\t\n\t\t\tif (true) {\n\t\t\t\tadapter = __webpack_require__(13);\n\t\t\t}\n\t\n\t\t\treturn adapter;\n\t\t}\n\t\n\t\t/**\n\t  * configures options related to database persistence.\n\t  *\n\t  * @param {object} options - configuration options to apply to loki db object\n\t  * @param {adapter} options.adapter - an instance of a loki persistence adapter\n\t  * @param {boolean} options.autosave - enables autosave\n\t  * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n\t  * @param {boolean} options.autoload - enables autoload on loki instantiation\n\t  * @param {object} options.inflate - options that are passed to loadDatabase if autoload enabled\n\t  * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']\n\t  * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n\t  * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n\t  * @memberof Loki\n\t  */\n\t\tinitializePersistence(options) {\n\t\t\tvar self = this;\n\t\t\tvar defaultPersistence = {\n\t\t\t\t'NODEJS': 'fs',\n\t\t\t\t'BROWSER': 'localStorage',\n\t\t\t\t'CORDOVA': 'localStorage'\n\t\t\t},\n\t\t\t    persistenceMethods = {\n\t\t\t\t'fs': _fs_adapter.LokiFsAdapter,\n\t\t\t\t'localStorage': _local_storage_adapter.LokiLocalStorageAdapter\n\t\t\t};\n\t\n\t\t\tthis.options = options || {};\n\t\n\t\t\tthis.persistenceMethod = null;\n\t\t\t// retain reference to optional persistence adapter 'instance'\n\t\t\t// currently keeping outside options because it can't be serialized\n\t\t\tthis.persistenceAdapter = null;\n\t\n\t\t\t// process the options\n\t\t\tif (this.options.hasOwnProperty('persistenceMethod')) {\n\t\t\t\t// check if the specified persistence method is known\n\t\t\t\tif (typeof persistenceMethods[this.options.persistenceMethod] === 'function') {\n\t\t\t\t\tthis.persistenceMethod = this.options.persistenceMethod;\n\t\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.options.persistenceMethod]();\n\t\t\t\t}\n\t\t\t\t// should be throw an error here, or just fall back to defaults ??\n\t\t\t}\n\t\n\t\t\t// ensure defaults exists for options which were not set\n\t\t\tif (!this.options.hasOwnProperty('serializationMethod')) {\n\t\t\t\tthis.options.serializationMethod = 'normal';\n\t\t\t}\n\t\n\t\t\t// ensure passed or default option exists\n\t\t\tif (!this.options.hasOwnProperty('destructureDelimiter')) {\n\t\t\t\tthis.options.destructureDelimiter = '$<\\n';\n\t\t\t}\n\t\n\t\t\t// if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n\t\t\tif (this.persistenceAdapter === null) {\n\t\t\t\tthis.persistenceMethod = defaultPersistence[this.ENV];\n\t\t\t\tif (this.persistenceMethod) {\n\t\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n\t\t\tif (this.options.hasOwnProperty('adapter')) {\n\t\t\t\tthis.persistenceMethod = 'adapter';\n\t\t\t\tthis.persistenceAdapter = this.options.adapter;\n\t\t\t}\n\t\n\t\t\tif (this.options.hasOwnProperty('autosaveInterval')) {\n\t\t\t\tthis.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n\t\t\t}\n\t\n\t\t\tthis.autosaveDisable();\n\t\n\t\t\tvar loaded;\n\t\n\t\t\t// if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n\t\t\tif (this.options.autoload) {\n\t\t\t\tloaded = this.loadDatabase(this.options.inflate);\n\t\t\t} else {\n\t\t\t\tloaded = Promise.resolve();\n\t\t\t}\n\t\n\t\t\treturn loaded.then(function () {\n\t\t\t\tif (self.options.autosave) {\n\t\t\t\t\tself.autosaveEnable();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t  * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n\t  *\n\t  * @param {object} options - apply or override collection level settings\n\t  * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n\t  * @memberof Loki\n\t  */\n\t\tcopy(options) {\n\t\t\tvar databaseCopy = new Loki(this.filename);\n\t\t\tvar clen, idx;\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\t// currently inverting and letting loadJSONObject do most of the work\n\t\t\tdatabaseCopy.loadJSONObject(this, {\n\t\t\t\tretainDirtyFlags: true\n\t\t\t});\n\t\n\t\t\t// since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic\n\t\t\tif (options.hasOwnProperty(\"removeNonSerializable\") && options.removeNonSerializable === true) {\n\t\t\t\tdatabaseCopy.autosaveHandle = null;\n\t\t\t\tdatabaseCopy.persistenceAdapter = null;\n\t\n\t\t\t\tclen = databaseCopy.collections.length;\n\t\t\t\tfor (idx = 0; idx < clen; idx++) {\n\t\t\t\t\tdatabaseCopy.collections[idx].constraints = null;\n\t\t\t\t\tdatabaseCopy.collections[idx].ttl = null;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn databaseCopy;\n\t\t}\n\t\n\t\t/**\n\t  * Shorthand method for quickly creating and populating an anonymous collection.\n\t  *    This collection is not referenced internally so upon losing scope it will be garbage collected.\n\t  *\n\t  * @example\n\t  * var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });\n\t  *\n\t  * @param {Array} docs - document array to initialize the anonymous collection with\n\t  * @param {object} options - configuration object, see {@link Loki#addCollection} options\n\t  * @returns {Collection} New collection which you can query or chain\n\t  * @memberof Loki\n\t  */\n\t\tanonym(docs, options) {\n\t\t\tvar collection = new _collection.Collection('anonym', options);\n\t\t\tcollection.insert(docs);\n\t\n\t\t\tif (this.verbose) collection.console = console;\n\t\n\t\t\treturn collection;\n\t\t}\n\t\n\t\t/**\n\t  * Adds a collection to the database.\n\t  * @param {string} name - name of collection to add\n\t  * @param {object=} options - (optional) options to configure collection with.\n\t  * @param {array} options.unique - array of property names to define unique constraints for\n\t  * @param {array} options.exact - array of property names to define exact constraints for\n\t  * @param {array} options.indices - array property names to define binary indexes for\n\t  * @param {boolean} options.asyncListeners - default is false\n\t  * @param {boolean} options.disableChangesApi - default is true\n\t  * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n\t  * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n\t  * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n\t  * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n\t  * @returns {Collection} a reference to the collection which was just added\n\t  * @memberof Loki\n\t  */\n\t\taddCollection(name, options) {\n\t\t\tvar collection = new _collection.Collection(name, options);\n\t\t\tthis.collections.push(collection);\n\t\n\t\t\tif (this.verbose) collection.console = console;\n\t\n\t\t\treturn collection;\n\t\t}\n\t\n\t\tloadCollection(collection) {\n\t\t\tif (!collection.name) {\n\t\t\t\tthrow new Error('Collection must have a name property to be loaded');\n\t\t\t}\n\t\t\tthis.collections.push(collection);\n\t\t}\n\t\n\t\t/**\n\t  * Retrieves reference to a collection by name.\n\t  * @param {string} collectionName - name of collection to look up\n\t  * @returns {Collection} Reference to collection in database by that name, or null if not found\n\t  * @memberof Loki\n\t  */\n\t\tgetCollection(collectionName) {\n\t\t\tvar i,\n\t\t\t    len = this.collections.length;\n\t\n\t\t\tfor (i = 0; i < len; i += 1) {\n\t\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\t\treturn this.collections[i];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// no such collection\n\t\t\tthis.emit('warning', 'collection ' + collectionName + ' not found');\n\t\t\treturn null;\n\t\t}\n\t\n\t\tlistCollections() {\n\t\n\t\t\tvar i = this.collections.length,\n\t\t\t    colls = [];\n\t\n\t\t\twhile (i--) {\n\t\t\t\tcolls.push({\n\t\t\t\t\tname: this.collections[i].name,\n\t\t\t\t\ttype: this.collections[i].objType,\n\t\t\t\t\tcount: this.collections[i].data.length\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn colls;\n\t\t}\n\t\n\t\t/**\n\t  * Removes a collection from the database.\n\t  * @param {string} collectionName - name of collection to remove\n\t  * @memberof Loki\n\t  */\n\t\tremoveCollection(collectionName) {\n\t\t\tvar i,\n\t\t\t    len = this.collections.length;\n\t\n\t\t\tfor (i = 0; i < len; i += 1) {\n\t\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\t\tvar tmpcol = new _collection.Collection(collectionName, {});\n\t\t\t\t\tvar curcol = this.collections[i];\n\t\t\t\t\tfor (var prop in curcol) {\n\t\t\t\t\t\tif (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n\t\t\t\t\t\t\tcurcol[prop] = tmpcol[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.collections.splice(i, 1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tgetName() {\n\t\t\treturn this.name;\n\t\t}\n\t\n\t\t/**\n\t  * serializeReplacer - used to prevent certain properties from being serialized\n\t  *\n\t  */\n\t\tserializeReplacer(key, value) {\n\t\t\tswitch (key) {\n\t\t\t\tcase 'autosaveHandle':\n\t\t\t\tcase 'persistenceAdapter':\n\t\t\t\tcase 'constraints':\n\t\t\t\tcase 'ttl':\n\t\t\t\t\treturn null;\n\t\t\t\tdefault:\n\t\t\t\t\treturn value;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n\t  *\n\t  * @returns {string} Stringified representation of the loki database.\n\t  * @memberof Loki\n\t  */\n\t\tserialize(options) {\n\t\t\toptions = options || {};\n\t\n\t\t\tif (!options.hasOwnProperty(\"serializationMethod\")) {\n\t\t\t\toptions.serializationMethod = this.options.serializationMethod;\n\t\t\t}\n\t\n\t\t\tswitch (options.serializationMethod) {\n\t\t\t\tcase \"normal\":\n\t\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t\t\tcase \"pretty\":\n\t\t\t\t\treturn JSON.stringify(this, this.serializeReplacer, 2);\n\t\t\t\tcase \"destructured\":\n\t\t\t\t\treturn this.serializeDestructured(); // use default options\n\t\t\t\tdefault:\n\t\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t\t}\n\t\t}\n\t\n\t\t// alias of serialize\n\t\ttoJson() {\n\t\t\treturn this.serialize;\n\t\t}\n\t\n\t\t/**\n\t  * Destructured JSON serialization routine to allow alternate serialization methods.\n\t  * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t  * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t  * your own structured persistence or data exchange.\n\t  *\n\t  * @param {object=} options - output format options for use externally to loki\n\t  * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t  * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n\t  * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t  * @param {string=} options.delimiter - override default delimiter\n\t  *\n\t  * @returns {string|array} A custom, restructured aggregation of independent serializations.\n\t  * @memberof Loki\n\t  */\n\t\tserializeDestructured(options) {\n\t\t\tvar idx, sidx, result, resultlen;\n\t\t\tvar reconstruct = [];\n\t\t\tvar dbcopy;\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\t\toptions.partitioned = false;\n\t\t\t}\n\t\n\t\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\t\toptions.delimited = true;\n\t\t\t}\n\t\n\t\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t\t}\n\t\n\t\t\t// 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n\t\t\tif (options.partitioned === true && options.hasOwnProperty(\"partition\") && options.partition >= 0) {\n\t\t\t\treturn this.serializeCollection({\n\t\t\t\t\tdelimited: options.delimited,\n\t\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\t\tcollectionIndex: options.partition\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// not just an individual collection, so we will need to serialize db container via shallow copy\n\t\t\tdbcopy = new Loki(this.filename);\n\t\t\tdbcopy.loadJSONObject(this);\n\t\n\t\t\tfor (idx = 0; idx < dbcopy.collections.length; idx++) {\n\t\t\t\tdbcopy.collections[idx].data = [];\n\t\t\t}\n\t\n\t\t\t// if we -only- wanted the db container portion, return it now\n\t\t\tif (options.partitioned === true && options.partition === -1) {\n\t\t\t\t// since we are deconstructing, override serializationMethod to normal for here\n\t\t\t\treturn dbcopy.serialize({\n\t\t\t\t\tserializationMethod: \"normal\"\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// at this point we must be deconstructing the entire database\n\t\t\t// start by pushing db serialization into first array element\n\t\t\treconstruct.push(dbcopy.serialize({\n\t\t\t\tserializationMethod: \"normal\"\n\t\t\t}));\n\t\n\t\t\tdbcopy = null;\n\t\n\t\t\t// push collection data into subsequent elements\n\t\t\tfor (idx = 0; idx < this.collections.length; idx++) {\n\t\t\t\tresult = this.serializeCollection({\n\t\t\t\t\tdelimited: options.delimited,\n\t\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\t\tcollectionIndex: idx\n\t\t\t\t});\n\t\n\t\t\t\t// NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n\t\t\t\tif (options.partitioned === false && options.delimited === false) {\n\t\t\t\t\tif (!Array.isArray(result)) {\n\t\t\t\t\t\tthrow new Error(\"a nondelimited, non partitioned collection serialization did not return an expected array\");\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Array.concat would probably duplicate memory overhead for copying strings.\n\t\t\t\t\t// Instead copy each individually, and clear old value after each copy.\n\t\t\t\t\t// Hopefully this will allow g.c. to reduce memory pressure, if needed.\n\t\t\t\t\tresultlen = result.length;\n\t\n\t\t\t\t\tfor (sidx = 0; sidx < resultlen; sidx++) {\n\t\t\t\t\t\treconstruct.push(result[sidx]);\n\t\t\t\t\t\tresult[sidx] = null;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treconstruct.push(\"\");\n\t\t\t\t} else {\n\t\t\t\t\treconstruct.push(result);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n\t\t\tif (options.partitioned) {\n\t\t\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t\t\t// useful for simple future adaptations of existing persistence adapters to save collections separately\n\t\t\t\tif (options.delimited) {\n\t\t\t\t\treturn reconstruct;\n\t\t\t\t}\n\t\t\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t\t\t// This format might be the most versatile for 'rolling your own' partitioned sync or save.\n\t\t\t\t// Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n\t\t\t\telse {\n\t\t\t\t\t\treturn reconstruct;\n\t\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t\t\t// This is the method Loki will use internally if 'destructured'.\n\t\t\t\t// Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n\t\t\t\tif (options.delimited) {\n\t\t\t\t\t// indicate no more collections\n\t\t\t\t\treconstruct.push(\"\");\n\t\n\t\t\t\t\treturn reconstruct.join(options.delimiter);\n\t\t\t\t}\n\t\t\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\t\t\t\t// This format might be best candidate for custom synchronous syncs or saves\n\t\t\t\telse {\n\t\t\t\t\t\t// indicate no more collections\n\t\t\t\t\t\treconstruct.push(\"\");\n\t\n\t\t\t\t\t\treturn reconstruct;\n\t\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treconstruct.push(\"\");\n\t\n\t\t\treturn reconstruct.join(delim);\n\t\t}\n\t\n\t\t/**\n\t  * Utility method to serialize a collection in a 'destructured' format\n\t  *\n\t  * @param {object} options - used to determine output of method\n\t  * @param {int=} options.delimited - whether to return single delimited string or an array\n\t  * @param {string=} options.delimiter - (optional) if delimited, this is delimiter to use\n\t  * @param {int} options.collectionIndex -  specify which collection to serialize data for\n\t  *\n\t  * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n\t  * @memberof Loki\n\t  */\n\t\tserializeCollection(options) {\n\t\t\tvar doccount,\n\t\t\t    docidx,\n\t\t\t    resultlines = [];\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\t\toptions.delimited = true;\n\t\t\t}\n\t\n\t\t\tif (!options.hasOwnProperty(\"collectionIndex\")) {\n\t\t\t\tthrow new Error(\"serializeCollection called without 'collectionIndex' option\");\n\t\t\t}\n\t\n\t\t\tdoccount = this.collections[options.collectionIndex].data.length;\n\t\n\t\t\tresultlines = [];\n\t\n\t\t\tfor (docidx = 0; docidx < doccount; docidx++) {\n\t\t\t\tresultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));\n\t\t\t}\n\t\n\t\t\t// D and DA\n\t\t\tif (options.delimited) {\n\t\t\t\t// indicate no more documents in collection (via empty delimited string)\n\t\t\t\tresultlines.push(\"\");\n\t\n\t\t\t\treturn resultlines.join(options.delimiter);\n\t\t\t} else {\n\t\t\t\t// NDAA and NDA\n\t\t\t\treturn resultlines;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Destructured JSON deserialization routine to minimize memory overhead.\n\t  * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t  * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t  * your own structured persistence or data exchange.\n\t  *\n\t  * @param {string|array} destructuredSource - destructured json or array to deserialize from\n\t  * @param {object=} options - source format options\n\t  * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t  * @param {int=} options.partition - can be used to deserialize only a single partition\n\t  * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t  * @param {string=} options.delimiter - override default delimiter\n\t  *\n\t  * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n\t  * @memberof Loki\n\t  */\n\t\tdeserializeDestructured(destructuredSource, options) {\n\t\t\tvar workarray = [];\n\t\t\tvar len, cdb;\n\t\t\tvar idx,\n\t\t\t    collIndex = 0,\n\t\t\t    collCount,\n\t\t\t    lineIndex = 1,\n\t\t\t    done = false;\n\t\t\tvar currLine, currObject;\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\t\toptions.partitioned = false;\n\t\t\t}\n\t\n\t\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\t\toptions.delimited = true;\n\t\t\t}\n\t\n\t\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t\t}\n\t\n\t\t\t// Partitioned\n\t\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t\t// -or- single partition\n\t\t\tif (options.partitioned) {\n\t\t\t\t// handle single partition\n\t\t\t\tif (options.hasOwnProperty('partition')) {\n\t\t\t\t\t// db only\n\t\t\t\t\tif (options.partition === -1) {\n\t\t\t\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\t\n\t\t\t\t\t\treturn cdb;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// single collection, return doc array\n\t\t\t\t\treturn this.deserializeCollection(destructuredSource[options.partition + 1], options);\n\t\t\t\t}\n\t\n\t\t\t\t// Otherwise we are restoring an entire partitioned db\n\t\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\t\t\t\tcollCount = cdb.collections.length;\n\t\t\t\tfor (collIndex = 0; collIndex < collCount; collIndex++) {\n\t\t\t\t\t// attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n\t\t\t\t\tcdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n\t\t\t\t}\n\t\n\t\t\t\treturn cdb;\n\t\t\t}\n\t\n\t\t\t// Non-Partitioned\n\t\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\t\n\t\t\t// D\n\t\t\tif (options.delimited) {\n\t\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\t\tdestructuredSource = null; // lower memory pressure\n\t\t\t\tlen = workarray.length;\n\t\n\t\t\t\tif (len === 0) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// NDA\n\t\t\telse {\n\t\t\t\t\tworkarray = destructuredSource;\n\t\t\t\t}\n\t\n\t\t\t// first line is database and collection shells\n\t\t\tcdb = JSON.parse(workarray[0]);\n\t\t\tcollCount = cdb.collections.length;\n\t\t\tworkarray[0] = null;\n\t\n\t\t\twhile (!done) {\n\t\t\t\tcurrLine = workarray[lineIndex];\n\t\n\t\t\t\t// empty string indicates either end of collection or end of file\n\t\t\t\tif (workarray[lineIndex] === \"\") {\n\t\t\t\t\t// if no more collections to load into, we are done\n\t\t\t\t\tif (++collIndex > collCount) {\n\t\t\t\t\t\tdone = true;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tcurrObject = JSON.parse(workarray[lineIndex]);\n\t\t\t\t\tcdb.collections[collIndex].data.push(currObject);\n\t\t\t\t}\n\t\n\t\t\t\t// lower memory pressure and advance iterator\n\t\t\t\tworkarray[lineIndex++] = null;\n\t\t\t}\n\t\n\t\t\treturn cdb;\n\t\t}\n\t\n\t\t/**\n\t  * Deserializes a destructured collection.\n\t  *\n\t  * @param {string|array} destructuredSource - destructured representation of collection to inflate\n\t  * @param {object} options - used to describe format of destructuredSource input\n\t  * @param {int} options.delimited - whether source is delimited string or an array\n\t  * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n\t  *\n\t  * @returns {array} an array of documents to attach to collection.data.\n\t  * @memberof Loki\n\t  */\n\t\tdeserializeCollection(destructuredSource, options) {\n\t\t\tvar workarray = [];\n\t\t\tvar idx, len;\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\t\toptions.partitioned = false;\n\t\t\t}\n\t\n\t\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\t\toptions.delimited = true;\n\t\t\t}\n\t\n\t\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t\t}\n\t\n\t\t\tif (options.delimited) {\n\t\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\t\tworkarray.pop();\n\t\t\t} else {\n\t\t\t\tworkarray = destructuredSource;\n\t\t\t}\n\t\n\t\t\tlen = workarray.length;\n\t\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\t\tworkarray[idx] = JSON.parse(workarray[idx]);\n\t\t\t}\n\t\n\t\t\treturn workarray;\n\t\t}\n\t\n\t\t/**\n\t  * Inflates a loki database from a serialized JSON string\n\t  *\n\t  * @param {string} serializedDb - a serialized loki database string\n\t  * @param {object} options - apply or override collection level settings\n\t  * @memberof Loki\n\t  */\n\t\tloadJSON(serializedDb, options) {\n\t\t\tvar dbObject;\n\t\t\tif (serializedDb.length === 0) {\n\t\t\t\tdbObject = {};\n\t\t\t} else {\n\t\t\t\t// using option defined in instantiated db not what was in serialized db\n\t\t\t\tswitch (this.options.serializationMethod) {\n\t\t\t\t\tcase \"normal\":\n\t\t\t\t\tcase \"pretty\":\n\t\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"destructured\":\n\t\t\t\t\t\tdbObject = this.deserializeDestructured(serializedDb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis.loadJSONObject(dbObject, options);\n\t\t}\n\t\n\t\t/**\n\t  * Inflates a loki database from a JS object\n\t  *\n\t  * @param {object} dbObject - a serialized loki database string\n\t  * @param {object} options - apply or override collection level settings\n\t  * @param {bool?} options.retainDirtyFlags - whether collection dirty flags will be preserved\n\t  * @memberof Loki\n\t  */\n\t\tloadJSONObject(dbObject, options) {\n\t\t\tvar i = 0,\n\t\t\t    len = dbObject.collections ? dbObject.collections.length : 0,\n\t\t\t    coll,\n\t\t\t    copyColl,\n\t\t\t    clen,\n\t\t\t    j,\n\t\t\t    loader,\n\t\t\t    collObj;\n\t\n\t\t\tthis.name = dbObject.name;\n\t\n\t\t\t// restore database version\n\t\t\tthis.databaseVersion = 1.0;\n\t\t\tif (dbObject.hasOwnProperty('databaseVersion')) {\n\t\t\t\tthis.databaseVersion = dbObject.databaseVersion;\n\t\t\t}\n\t\n\t\t\tthis.collections = [];\n\t\n\t\t\tfunction makeLoader(coll) {\n\t\t\t\tvar collOptions = options[coll.name];\n\t\t\t\tvar inflater;\n\t\n\t\t\t\tif (collOptions.proto) {\n\t\t\t\t\tinflater = collOptions.inflate || _utils.Utils.copyProperties;\n\t\n\t\t\t\t\treturn function (data) {\n\t\t\t\t\t\tvar collObj = new collOptions.proto();\n\t\t\t\t\t\tinflater(data, collObj);\n\t\t\t\t\t\treturn collObj;\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\treturn collOptions.inflate;\n\t\t\t}\n\t\n\t\t\tfor (i; i < len; i += 1) {\n\t\t\t\tcoll = dbObject.collections[i];\n\t\t\t\tcopyColl = this.addCollection(coll.name);\n\t\n\t\t\t\tcopyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? coll.adaptiveBinaryIndices === true : false;\n\t\t\t\tcopyColl.transactional = coll.transactional;\n\t\t\t\tcopyColl.asyncListeners = coll.asyncListeners;\n\t\t\t\tcopyColl.disableChangesApi = coll.disableChangesApi;\n\t\t\t\tcopyColl.cloneObjects = coll.cloneObjects;\n\t\t\t\tcopyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n\t\t\t\tcopyColl.autoupdate = coll.autoupdate;\n\t\t\t\tcopyColl.changes = coll.changes;\n\t\n\t\t\t\tif (options && options.retainDirtyFlags === true) {\n\t\t\t\t\tcopyColl.dirty = coll.dirty;\n\t\t\t\t} else {\n\t\t\t\t\tcopyColl.dirty = false;\n\t\t\t\t}\n\t\n\t\t\t\t// load each element individually\n\t\t\t\tclen = coll.data.length;\n\t\t\t\tj = 0;\n\t\t\t\tif (options && options.hasOwnProperty(coll.name)) {\n\t\t\t\t\tloader = makeLoader(coll);\n\t\n\t\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\t\tcollObj = loader(coll.data[j]);\n\t\t\t\t\t\tcopyColl.data[j] = collObj;\n\t\t\t\t\t\tcopyColl.addAutoUpdateObserver(collObj);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\n\t\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\t\tcopyColl.data[j] = coll.data[j];\n\t\t\t\t\t\tcopyColl.addAutoUpdateObserver(copyColl.data[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tcopyColl.maxId = coll.data.length === 0 ? 0 : coll.maxId;\n\t\t\t\tcopyColl.idIndex = coll.idIndex;\n\t\t\t\tif (typeof coll.binaryIndices !== 'undefined') {\n\t\t\t\t\tcopyColl.binaryIndices = coll.binaryIndices;\n\t\t\t\t}\n\t\t\t\tif (typeof coll.transforms !== 'undefined') {\n\t\t\t\t\tcopyColl.transforms = coll.transforms;\n\t\t\t\t}\n\t\n\t\t\t\tcopyColl.ensureId();\n\t\n\t\t\t\t// regenerate unique indexes\n\t\t\t\tcopyColl.uniqueNames = [];\n\t\t\t\tif (coll.hasOwnProperty(\"uniqueNames\")) {\n\t\t\t\t\tcopyColl.uniqueNames = coll.uniqueNames;\n\t\t\t\t\tfor (j = 0; j < copyColl.uniqueNames.length; j++) {\n\t\t\t\t\t\tcopyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// in case they are loading a database created before we added dynamic views, handle undefined\n\t\t\t\tif (typeof coll.DynamicViews === 'undefined') continue;\n\t\n\t\t\t\t// reinflate DynamicViews and attached Resultsets\n\t\t\t\tfor (var idx = 0; idx < coll.DynamicViews.length; idx++) {\n\t\t\t\t\tvar colldv = coll.DynamicViews[idx];\n\t\n\t\t\t\t\tvar dv = copyColl.addDynamicView(colldv.name, colldv.options);\n\t\t\t\t\tdv.resultdata = colldv.resultdata;\n\t\t\t\t\tdv.resultsdirty = colldv.resultsdirty;\n\t\t\t\t\tdv.filterPipeline = colldv.filterPipeline;\n\t\n\t\t\t\t\tdv.sortCriteria = colldv.sortCriteria;\n\t\t\t\t\tdv.sortFunction = null;\n\t\n\t\t\t\t\tdv.sortDirty = colldv.sortDirty;\n\t\t\t\t\tdv.resultset.filteredrows = colldv.resultset.filteredrows;\n\t\t\t\t\tdv.resultset.searchIsChained = colldv.resultset.searchIsChained;\n\t\t\t\t\tdv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\t\n\t\t\t\t\tdv.rematerialize({\n\t\t\t\t\t\tremoveWhereFilters: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n\t  * Does not actually destroy the db.\n\t  *\n\t  * @returns {Promise} a Promise that resolves after closing the database succeeded\n\t  * @memberof Loki\n\t  */\n\t\tclose() {\n\t\t\tvar self = this;\n\t\t\tvar saved;\n\t\n\t\t\t// for autosave scenarios, we will let close perform final save (if dirty)\n\t\t\t// For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n\t\t\tif (this.autosave) {\n\t\t\t\tthis.autosaveDisable();\n\t\t\t\tif (this.autosaveDirty()) {\n\t\t\t\t\tsaved = this.saveDatabase();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn Promise.resolve(saved).then(function () {\n\t\t\t\tself.emit('close');\n\t\t\t});\n\t\t}\n\t\n\t\t/**-------------------------+\n\t  | Changes API               |\n\t  +--------------------------*/\n\t\n\t\t/**\n\t  * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n\t  * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n\t  */\n\t\n\t\t/**\n\t  * (Changes API) : takes all the changes stored in each\n\t  * collection and creates a single array for the entire database. If an array of names\n\t  * of collections is passed then only the included collections will be tracked.\n\t  *\n\t  * @param {array=} optional array of collection names. No arg means all collections are processed.\n\t  * @returns {array} array of changes\n\t  * @see private method createChange() in Collection\n\t  * @memberof Loki\n\t  */\n\t\tgenerateChangesNotification(arrayOfCollectionNames) {\n\t\t\tfunction getCollName(coll) {\n\t\t\t\treturn coll.name;\n\t\t\t}\n\t\t\tvar changes = [],\n\t\t\t    selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\t\n\t\t\tthis.collections.forEach(function (coll) {\n\t\t\t\tif (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n\t\t\t\t\tchanges = changes.concat(coll.getChanges());\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn changes;\n\t\t}\n\t\n\t\t/**\n\t  * (Changes API) - stringify changes for network transmission\n\t  * @returns {string} string representation of the changes\n\t  * @memberof Loki\n\t  */\n\t\tserializeChanges(collectionNamesArray) {\n\t\t\treturn JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n\t\t}\n\t\n\t\t/**\n\t  * (Changes API) : clears all the changes in all collections.\n\t  * @memberof Loki\n\t  */\n\t\tclearChanges() {\n\t\t\tthis.collections.forEach(function (coll) {\n\t\t\t\tif (coll.flushChanges) {\n\t\t\t\t\tcoll.flushChanges();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t  * Handles loading from file system, local storage, or adapter (indexeddb).\n\t  *\n\t  * @param {object} options - an object containing inflation options for each collection\n\t  * @returns {Promise} a Promise that resolves after the database is loaded\n\t  * @memberof Loki\n\t  */\n\t\tloadDatabase(options) {\n\t\t\tvar self = this;\n\t\n\t\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\t\tif (this.persistenceAdapter === null) {\n\t\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t\t}\n\t\n\t\t\treturn Promise.resolve(this.persistenceAdapter.loadDatabase(this.filename)).then(function loadDatabaseCallback(dbString) {\n\t\t\t\tif (typeof dbString === 'string') {\n\t\t\t\t\tself.loadJSON(dbString, options || {});\n\t\t\t\t\tself.emit('load', self);\n\t\t\t\t} else {\n\t\t\t\t\t// if adapter has returned an js object (other than null or error) attempt to load from JSON object\n\t\t\t\t\tif (typeof dbString === \"object\" && dbString !== null && !(dbString instanceof Error)) {\n\t\t\t\t\t\tself.loadJSONObject(dbString, options || {});\n\t\t\t\t\t\tself.emit('load', self);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dbString instanceof Error) throw dbString;\n\t\n\t\t\t\t\t\tthrow new TypeError('The persistence adapter did not load a serialized DB string or object.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t  * Handles saving to file system, local storage, or adapter (indexeddb)\n\t  *\n\t  * @memberof Loki\n\t  * @returns {Promise} a Promise that resolves after the database is persisted\n\t  */\n\t\tsaveDatabase() {\n\t\t\tvar self = this;\n\t\n\t\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\t\tif (this.persistenceAdapter === null) {\n\t\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t\t}\n\t\n\t\t\tvar saved;\n\t\n\t\t\t// check if the adapter is requesting (and supports) a 'reference' mode export\n\t\t\tif (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n\t\t\t\t// filename may seem redundant but loadDatabase will need to expect this same filename\n\t\t\t\tsaved = this.persistenceAdapter.exportDatabase(this.filename, this.copy({\n\t\t\t\t\tremoveNonSerializable: true\n\t\t\t\t}));\n\t\t\t}\n\t\t\t// otherwise just pass the serialized database to adapter\n\t\t\telse {\n\t\t\t\t\tsaved = this.persistenceAdapter.saveDatabase(this.filename, self.serialize());\n\t\t\t\t}\n\t\n\t\t\treturn Promise.resolve(saved).then(function () {\n\t\t\t\tself.autosaveClearFlags();\n\t\t\t\tself.emit(\"save\");\n\t\t\t});\n\t\t}\n\t\n\t\t// alias\n\t\tsave() {\n\t\t\treturn this.saveDatabase();\n\t\t}\n\t\n\t\t/**\n\t  * Handles deleting a database from file system, local storage, or adapter (indexeddb)\n\t  *\n\t  * @returns {Promise} a Promise that resolves after the database is deleted\n\t  * @memberof Loki\n\t  */\n\t\tdeleteDatabase() {\n\t\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\t\tif (this.persistenceAdapter === null) {\n\t\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t\t}\n\t\n\t\t\treturn Promise.resolve(this.persistenceAdapter.deleteDatabase(this.filename));\n\t\t}\n\t\n\t\t/**\n\t  * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n\t  *\n\t  * @returns {boolean} - true if database has changed since last autosave, false if not.\n\t  */\n\t\tautosaveDirty() {\n\t\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\t\tif (this.collections[idx].dirty) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn false;\n\t\t}\n\t\n\t\t/**\n\t  * autosaveClearFlags - resets dirty flags on all collections.\n\t  *    Called from saveDatabase() after db is saved.\n\t  *\n\t  */\n\t\tautosaveClearFlags() {\n\t\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\t\tthis.collections[idx].dirty = false;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * autosaveEnable - begin a javascript interval to periodically save the database.\n\t  *\n\t  */\n\t\tautosaveEnable() {\n\t\t\tif (this.autosaveHandle) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar self = this;\n\t\t\tvar running = true;\n\t\n\t\t\tthis.autosave = true;\n\t\t\tthis.autosaveHandle = function () {\n\t\t\t\trunning = false;\n\t\t\t\tself.autosaveHandle = undefined;\n\t\t\t};\n\t\n\t\t\t(function saveDatabase() {\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tif (running) {\n\t\t\t\t\t\tself.saveDatabase().then(saveDatabase, saveDatabase);\n\t\t\t\t\t}\n\t\t\t\t}, self.autosaveInterval);\n\t\t\t})();\n\t\t}\n\t\n\t\t/**\n\t  * autosaveDisable - stop the autosave interval timer.\n\t  *\n\t  */\n\t\tautosaveDisable() {\n\t\t\tthis.autosave = false;\n\t\n\t\t\tif (this.autosaveHandle) {\n\t\t\t\tthis.autosaveHandle();\n\t\t\t}\n\t\t}\n\t}\n\texports.Loki = Loki;\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\t/*\n\t 'listen' is not defined  no-undef\n\t */\n\t\n\t/**\n\t * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n\t * constructor that inherits EventEmitter to emit events and trigger\n\t * listeners that have been added to the event through the on(event, callback) method\n\t *\n\t * @constructor LokiEventEmitter\n\t */\n\tclass LokiEventEmitter {\n\t\n\t\tconstructor() {\n\t\t\t/**\n\t   * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n\t   * @memberof LokiEventEmitter\n\t   */\n\t\t\tthis.events = {};\n\t\n\t\t\t/**\n\t   * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n\t   * should happen in an async fashion or not\n\t   * Default is false, which means events are synchronous\n\t   * @memberof LokiEventEmitter\n\t   */\n\t\t\tthis.asyncListeners = false;\n\t\t}\n\t\n\t\t/**\n\t  * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t  * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t  * @param {function} listener - callback function of listener to attach\n\t  * @returns {int} the index of the callback in the array of listeners for a particular event\n\t  * @memberof LokiEventEmitter\n\t  */\n\t\ton(eventName, listener) {\n\t\t\tvar event;\n\t\t\tvar self = this;\n\t\n\t\t\tif (Array.isArray(eventName)) {\n\t\t\t\teventName.forEach(function (currentEventName) {\n\t\t\t\t\tself.on(currentEventName, listener);\n\t\t\t\t});\n\t\t\t\treturn listener;\n\t\t\t}\n\t\n\t\t\tevent = this.events[eventName];\n\t\t\tif (!event) {\n\t\t\t\tevent = this.events[eventName] = [];\n\t\t\t}\n\t\t\tevent.push(listener);\n\t\t\treturn listener;\n\t\t}\n\t\n\t\t/**\n\t  * emit(eventName, data) - emits a particular event\n\t  * with the option of passing optional parameters which are going to be processed by the callback\n\t  * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n\t  * @param {string} eventName - the name of the event\n\t  * @param {object=} data - optional object passed with the event\n\t  * @memberof LokiEventEmitter\n\t  */\n\t\temit(eventName, data) {\n\t\t\tvar self = this;\n\t\t\tif (eventName && this.events[eventName]) {\n\t\t\t\tthis.events[eventName].forEach(function (listener) {\n\t\t\t\t\tif (self.asyncListeners) {\n\t\t\t\t\t\tsetTimeout(function () {\n\t\t\t\t\t\t\tlistener(data);\n\t\t\t\t\t\t}, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlistener(data);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Alias of LokiEventEmitter.prototype.on\n\t  * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t  * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t  * @param {function} listener - callback function of listener to attach\n\t  * @returns {int} the index of the callback in the array of listeners for a particular event\n\t  * @memberof LokiEventEmitter\n\t  */\n\t\taddListener(eventName, listener) {\n\t\t\treturn this.on(eventName, listener);\n\t\t}\n\t\n\t\t/**\n\t  * removeListener() - removes the listener at position 'index' from the event 'eventName'\n\t  * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n\t  * @param {function} listener - the listener callback function to remove from emitter\n\t  * @memberof LokiEventEmitter\n\t  */\n\t\tremoveListener(eventName, listener) {\n\t\t\tvar self = this;\n\t\t\tif (Array.isArray(eventName)) {\n\t\t\t\teventName.forEach(function (currentEventName) {\n\t\t\t\t\tself.removeListener(currentEventName, listen);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tif (this.events[eventName]) {\n\t\t\t\tvar listeners = this.events[eventName];\n\t\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t\t}\n\t\t}\n\t}\n\texports.LokiEventEmitter = LokiEventEmitter;\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\t/**\n\t * A loki persistence adapter which persists using node fs module\n\t * @constructor LokiFsAdapter\n\t */\n\tclass LokiFsAdapter {\n\t\n\t\tconstructor() {\n\t\t\tthis.fs = undefined; //TODO require('fs');\n\t\t}\n\t\n\t\t/**\n\t  * loadDatabase() - Load data from file, will throw an error if the file does not exist\n\t  * @param {string} dbname - the filename of the database to load\n\t  * @returns {Promise} a Promise that resolves after the database was loaded\n\t  * @memberof LokiFsAdapter\n\t  */\n\t\tloadDatabase(dbname) {\n\t\t\tvar self = this;\n\t\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tself.fs.stat(dbname, function (err, stats) {\n\t\t\t\t\tif (!err && stats.isFile()) {\n\t\t\t\t\t\tself.fs.readFile(dbname, {\n\t\t\t\t\t\t\tencoding: 'utf8'\n\t\t\t\t\t\t}, function readFileCallback(err, data) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t  * saveDatabase() - save data to file, will throw an error if the file can't be saved\n\t  * might want to expand this to avoid dataloss on partial save\n\t  * @param {string} dbname - the filename of the database to load\n\t  * @returns {Promise} a Promise that resolves after the database was persisted\n\t  * @memberof LokiFsAdapter\n\t  */\n\t\tsaveDatabase(dbname, dbstring) {\n\t\t\tvar self = this;\n\t\t\tvar tmpdbname = dbname + '~';\n\t\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tself.fs.writeFile(tmpdbname, dbstring, function (err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.fs.rename(tmpdbname, dbname, function (err) {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t  * deleteDatabase() - delete the database file, will throw an error if the\n\t  * file can't be deleted\n\t  * @param {string} dbname - the filename of the database to delete\n\t  * @returns {Promise} a Promise that resolves after the database was deleted\n\t  * @memberof LokiFsAdapter\n\t  */\n\t\tdeleteDatabase(dbname) {\n\t\t\tvar self = this;\n\t\n\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\tself.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\texports.LokiFsAdapter = LokiFsAdapter;\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t\n\tfunction localStorageAvailable() {\n\t\ttry {\n\t\t\treturn window && window.localStorage !== undefined && window.localStorage !== null;\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t/*\n\t 'localStorageAvailable' is not defined\n\t */\n\t\n\t/**\n\t * A loki persistence adapter which persists to web browser's local storage object\n\t * @constructor LokiLocalStorageAdapter\n\t */\n\tclass LokiLocalStorageAdapter {\n\t\n\t\t/**\n\t  * loadDatabase() - Load data from localstorage\n\t  * @param {string} dbname - the name of the database to load\n\t  * @returns {Promise} a Promise that resolves after the database was loaded\n\t  * @memberof LokiLocalStorageAdapter\n\t  */\n\t\tloadDatabase(dbname) {\n\t\t\tif (localStorageAvailable()) {\n\t\t\t\treturn Promise.resolve(localStorage.getItem(dbname));\n\t\t\t}\n\t\n\t\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t\t}\n\t\n\t\t/**\n\t  * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n\t  * might want to expand this to avoid dataloss on partial save\n\t  * @param {string} dbname - the filename of the database to load\n\t  * @returns {Promise} a Promise that resolves after the database was saved\n\t  * @memberof LokiLocalStorageAdapter\n\t  */\n\t\tsaveDatabase(dbname, dbstring) {\n\t\t\tif (localStorageAvailable()) {\n\t\t\t\tlocalStorage.setItem(dbname, dbstring);\n\t\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\n\t\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t\t}\n\t\n\t\t/**\n\t  * deleteDatabase() - delete the database from localstorage, will throw an error if it\n\t  * can't be deleted\n\t  * @param {string} dbname - the filename of the database to delete\n\t  * @returns {Promise} a Promise that resolves after the database was deleted\n\t  * @memberof LokiLocalStorageAdapter\n\t  */\n\t\tdeleteDatabase(dbname) {\n\t\t\tif (localStorageAvailable()) {\n\t\t\t\tlocalStorage.removeItem(dbname);\n\t\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\n\t\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t\t}\n\t}\n\texports.LokiLocalStorageAdapter = LokiLocalStorageAdapter;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.Collection = undefined;\n\t\n\tvar _event_emitter = __webpack_require__(2);\n\t\n\tvar _unique_index = __webpack_require__(6);\n\t\n\tvar _exact_index = __webpack_require__(7);\n\t\n\tvar _resultset = __webpack_require__(8);\n\t\n\tvar _dynamic_view = __webpack_require__(12);\n\t\n\tvar _clone = __webpack_require__(9);\n\t\n\tvar _helper = __webpack_require__(11);\n\t\n\t/**\n\t * General utils, including statistical functions\n\t */\n\tfunction isDeepProperty(field) {\n\t\treturn field.indexOf('.') !== -1;\n\t}\n\t\n\tfunction parseBase10(num) {\n\t\treturn parseFloat(num, 10);\n\t}\n\t\n\tfunction add(a, b) {\n\t\treturn a + b;\n\t}\n\t\n\tfunction sub(a, b) {\n\t\treturn a - b;\n\t}\n\t\n\tfunction average(array) {\n\t\treturn array.reduce(add, 0) / array.length;\n\t}\n\t\n\tfunction standardDeviation(values) {\n\t\tvar avg = average(values);\n\t\tvar squareDiffs = values.map(function (value) {\n\t\t\tvar diff = value - avg;\n\t\t\tvar sqrDiff = diff * diff;\n\t\t\treturn sqrDiff;\n\t\t});\n\t\n\t\tvar avgSquareDiff = average(squareDiffs);\n\t\n\t\tvar stdDev = Math.sqrt(avgSquareDiff);\n\t\treturn stdDev;\n\t}\n\t\n\tfunction deepProperty(obj, property, isDeep) {\n\t\tif (isDeep === false) {\n\t\t\t// pass without processing\n\t\t\treturn obj[property];\n\t\t}\n\t\tvar pieces = property.split('.'),\n\t\t    root = obj;\n\t\twhile (pieces.length > 0) {\n\t\t\troot = root[pieces.shift()];\n\t\t}\n\t\treturn root;\n\t}\n\t\n\t/*\n\t'UniqueIndex' is not defined                 no-undef\n\t'ExactIndex' is not defined                  no-undef\n\t'ltHelper' is not defined                    no-undef\n\t'gtHelper' is not defined                    no-undef\n\t'DynamicView' is not defined                 no-undef\n\t'clone' is not defined                       no-undef\n\t'Resultset' is not defined                   no-undef\n\t'cloneObjectArray' is not defined            no-undef\n\t\n\t'isDeepProperty' is not defined              no-undef\n\t'deepProperty' is not defined                no-undef\n\t'average' is not defined                     no-undef\n\t'standardDeviation' is not defined           no-undef\n\t'sub' is not defined                         no-undef\n\t */\n\t\n\t/**\n\t * Collection class that handles documents of same type\n\t * @constructor Collection\n\t * @implements LokiEventEmitter\n\t * @param {string} name - collection name\n\t * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n\t * @param {array} options.unique - array of property names to define unique constraints for\n\t * @param {array} options.exact - array of property names to define exact constraints for\n\t * @param {array} options.indices - array property names to define binary indexes for\n\t * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily (default: true)\n\t * @param {boolean} options.asyncListeners - default is false\n\t * @param {boolean} options.disableChangesApi - default is true\n\t * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n\t * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n\t * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n\t * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n\t * @see {@link Loki#addCollection} for normal creation of collections\n\t */\n\tclass Collection extends _event_emitter.LokiEventEmitter {\n\t\n\t\tconstructor(name, options) {\n\t\t\tsuper();\n\t\t\t// the name of the collection\n\t\n\t\t\tthis.name = name;\n\t\t\t// the data held by the collection\n\t\t\tthis.data = [];\n\t\t\tthis.idIndex = []; // index of id\n\t\t\tthis.binaryIndices = {}; // user defined indexes\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\t\n\t\t\t// unique contraints contain duplicate object references, so they are not persisted.\n\t\t\t// we will keep track of properties which have unique contraint applied here, and regenerate on load\n\t\t\tthis.uniqueNames = [];\n\t\n\t\t\t// transforms will be used to store frequently used query chains as a series of steps\n\t\t\t// which itself can be stored along with the database.\n\t\t\tthis.transforms = {};\n\t\n\t\t\t// the object type of the collection\n\t\t\tthis.objType = name;\n\t\n\t\t\t// in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n\t\t\t// currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n\t\t\t// defaulting to true since this is called from addCollection and adding a collection should trigger save\n\t\t\tthis.dirty = true;\n\t\n\t\t\t// private holders for cached data\n\t\t\tthis.cachedIndex = null;\n\t\t\tthis.cachedBinaryIndex = null;\n\t\t\tthis.cachedData = null;\n\t\t\tvar self = this;\n\t\n\t\t\t/* OPTIONS */\n\t\t\toptions = options || {};\n\t\n\t\t\t// exact match and unique constraints\n\t\t\tif (options.hasOwnProperty('unique')) {\n\t\t\t\tif (!Array.isArray(options.unique)) {\n\t\t\t\t\toptions.unique = [options.unique];\n\t\t\t\t}\n\t\t\t\toptions.unique.forEach(function (prop) {\n\t\t\t\t\tself.uniqueNames.push(prop); // used to regenerate on subsequent database loads\n\t\t\t\t\tself.constraints.unique[prop] = new _unique_index.UniqueIndex(prop);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tif (options.hasOwnProperty('exact')) {\n\t\t\t\toptions.exact.forEach(function (prop) {\n\t\t\t\t\tself.constraints.exact[prop] = new _exact_index.ExactIndex(prop);\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n\t\t\t// if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n\t\t\tthis.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;\n\t\n\t\t\t// is collection transactional\n\t\t\tthis.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;\n\t\n\t\t\t// options to clone objects when inserting them\n\t\t\tthis.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;\n\t\n\t\t\t// default clone method (if enabled) is parse-stringify\n\t\t\tthis.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : \"parse-stringify\";\n\t\n\t\t\t// option to make event listeners async, default is sync\n\t\t\tthis.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;\n\t\n\t\t\t// disable track changes\n\t\t\tthis.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;\n\t\n\t\t\t// option to observe objects and update them automatically, ignored if Object.observe is not supported\n\t\t\tthis.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;\n\t\n\t\t\t//option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n\t\t\tthis.ttl = {\n\t\t\t\tage: null,\n\t\t\t\tttlInterval: null,\n\t\t\t\tdaemon: null\n\t\t\t};\n\t\t\tthis.setTTL(options.ttl || -1, options.ttlInterval);\n\t\n\t\t\t// currentMaxId - change manually at your own peril!\n\t\t\tthis.maxId = 0;\n\t\n\t\t\tthis.DynamicViews = [];\n\t\n\t\t\t// events\n\t\t\tthis.events = {\n\t\t\t\t'insert': [],\n\t\t\t\t'update': [],\n\t\t\t\t'pre-insert': [],\n\t\t\t\t'pre-update': [],\n\t\t\t\t'close': [],\n\t\t\t\t'flushbuffer': [],\n\t\t\t\t'error': [],\n\t\t\t\t'delete': [],\n\t\t\t\t'warning': []\n\t\t\t};\n\t\n\t\t\t// changes are tracked by collection and aggregated by the db\n\t\t\tthis.changes = [];\n\t\n\t\t\t// initialize the id index\n\t\t\tthis.ensureId();\n\t\t\tvar indices = [];\n\t\t\t// initialize optional user-supplied indices array ['age', 'lname', 'zip']\n\t\t\tif (options && options.indices) {\n\t\t\t\tif (Object.prototype.toString.call(options.indices) === '[object Array]') {\n\t\t\t\t\tindices = options.indices;\n\t\t\t\t} else if (typeof options.indices === 'string') {\n\t\t\t\t\tindices = [options.indices];\n\t\t\t\t} else {\n\t\t\t\t\tthrow new TypeError('Indices needs to be a string or an array of strings');\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tfor (var idx = 0; idx < indices.length; idx++) {\n\t\t\t\tthis.ensureIndex(indices[idx]);\n\t\t\t}\n\t\n\t\t\tfunction observerCallback(changes) {\n\t\n\t\t\t\tvar changedObjects = typeof Set === 'function' ? new Set() : [];\n\t\n\t\t\t\tif (!changedObjects.add) changedObjects.add = function (object) {\n\t\t\t\t\tif (this.indexOf(object) === -1) this.push(object);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\n\t\t\t\tchanges.forEach(function (change) {\n\t\t\t\t\tchangedObjects.add(change.object);\n\t\t\t\t});\n\t\n\t\t\t\tchangedObjects.forEach(function (object) {\n\t\t\t\t\tif (!hasOwnProperty.call(object, '$loki')) return self.removeAutoUpdateObserver(object);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tself.update(object);\n\t\t\t\t\t} catch (err) {}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tthis.observerCallback = observerCallback;\n\t\n\t\t\t/*\n\t   * This method creates a clone of the current status of an object and associates operation and collection name,\n\t   * so the parent db can aggregate and generate a changes object for the entire db\n\t   */\n\t\t\tfunction createChange(name, op, obj) {\n\t\t\t\tself.changes.push({\n\t\t\t\t\tname: name,\n\t\t\t\t\toperation: op,\n\t\t\t\t\tobj: JSON.parse(JSON.stringify(obj))\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// clear all the changes\n\t\t\tfunction flushChanges() {\n\t\t\t\tself.changes = [];\n\t\t\t}\n\t\n\t\t\tthis.getChanges = function () {\n\t\t\t\treturn self.changes;\n\t\t\t};\n\t\n\t\t\tthis.flushChanges = flushChanges;\n\t\n\t\t\t/**\n\t   * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled\n\t   */\n\t\t\tfunction insertMeta(obj) {\n\t\t\t\tif (!obj) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!obj.meta) {\n\t\t\t\t\tobj.meta = {};\n\t\t\t\t}\n\t\n\t\t\t\tobj.meta.created = new Date().getTime();\n\t\t\t\tobj.meta.revision = 0;\n\t\t\t}\n\t\n\t\t\tfunction updateMeta(obj) {\n\t\t\t\tif (!obj) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tobj.meta.updated = new Date().getTime();\n\t\t\t\tobj.meta.revision += 1;\n\t\t\t}\n\t\n\t\t\tfunction createInsertChange(obj) {\n\t\t\t\tcreateChange(self.name, 'I', obj);\n\t\t\t}\n\t\n\t\t\tfunction createUpdateChange(obj) {\n\t\t\t\tcreateChange(self.name, 'U', obj);\n\t\t\t}\n\t\n\t\t\tfunction insertMetaWithChange(obj) {\n\t\t\t\tinsertMeta(obj);\n\t\t\t\tcreateInsertChange(obj);\n\t\t\t}\n\t\n\t\t\tfunction updateMetaWithChange(obj) {\n\t\t\t\tupdateMeta(obj);\n\t\t\t\tcreateUpdateChange(obj);\n\t\t\t}\n\t\n\t\t\t/* assign correct handler based on ChangesAPI flag */\n\t\t\tvar insertHandler, updateHandler;\n\t\n\t\t\tfunction setHandlers() {\n\t\t\t\tinsertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;\n\t\t\t\tupdateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;\n\t\t\t}\n\t\n\t\t\tsetHandlers();\n\t\n\t\t\tthis.setChangesApi = function (enabled) {\n\t\t\t\tself.disableChangesApi = !enabled;\n\t\t\t\tsetHandlers();\n\t\t\t};\n\t\t\t/**\n\t   * built-in events\n\t   */\n\t\t\tthis.on('insert', function insertCallback(obj) {\n\t\t\t\tinsertHandler(obj);\n\t\t\t});\n\t\n\t\t\tthis.on('update', function updateCallback(obj) {\n\t\t\t\tupdateHandler(obj);\n\t\t\t});\n\t\n\t\t\tthis.on('delete', function deleteCallback(obj) {\n\t\t\t\tif (!self.disableChangesApi) {\n\t\t\t\t\tcreateChange(self.name, 'R', obj);\n\t\t\t\t}\n\t\t\t});\n\t\n\t\t\tthis.on('warning', function (warning) {\n\t\t\t\tself.console.warn(warning);\n\t\t\t});\n\t\t\t// for de-serialization purposes\n\t\t\tflushChanges();\n\t\n\t\t\tthis.console = {\n\t\t\t\tlog: function () {},\n\t\t\t\twarn: function () {},\n\t\t\t\terror: function () {}\n\t\t\t};\n\t\n\t\t\t/* ------ STAGING API -------- */\n\t\t\t/**\n\t   * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t   * manipulated without affecting the data in the original collection\n\t   */\n\t\t\tthis.stages = {};\n\t\t\tthis.commitLog = [];\n\t\t}\n\t\n\t\taddAutoUpdateObserver(object) {\n\t\t\tif (!this.autoupdate || typeof Object.observe !== 'function') return;\n\t\n\t\t\tObject.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n\t\t}\n\t\n\t\tremoveAutoUpdateObserver(object) {\n\t\t\tif (!this.autoupdate || typeof Object.observe !== 'function') return;\n\t\n\t\t\tObject.unobserve(object, this.observerCallback);\n\t\t}\n\t\n\t\t/**\n\t  * Adds a named collection transform to the collection\n\t  * @param {string} name - name to associate with transform\n\t  * @param {array} transform - an array of transformation 'step' objects to save into the collection\n\t  * @memberof Collection\n\t  */\n\t\taddTransform(name, transform) {\n\t\t\tif (this.transforms.hasOwnProperty(name)) {\n\t\t\t\tthrow new Error(\"a transform by that name already exists\");\n\t\t\t}\n\t\n\t\t\tthis.transforms[name] = transform;\n\t\t}\n\t\n\t\t/**\n\t  * Updates a named collection transform to the collection\n\t  * @param {string} name - name to associate with transform\n\t  * @param {object} transform - a transformation object to save into collection\n\t  * @memberof Collection\n\t  */\n\t\tsetTransform(name, transform) {\n\t\t\tthis.transforms[name] = transform;\n\t\t}\n\t\n\t\t/**\n\t  * Removes a named collection transform from the collection\n\t  * @param {string} name - name of collection transform to remove\n\t  * @memberof Collection\n\t  */\n\t\tremoveTransform(name) {\n\t\t\tdelete this.transforms[name];\n\t\t}\n\t\n\t\tbyExample(template) {\n\t\t\tvar k, obj, query;\n\t\t\tquery = [];\n\t\t\tfor (k in template) {\n\t\t\t\tif (!template.hasOwnProperty(k)) continue;\n\t\t\t\tquery.push((obj = {}, obj[k] = template[k], obj));\n\t\t\t}\n\t\t\treturn {\n\t\t\t\t'$and': query\n\t\t\t};\n\t\t}\n\t\n\t\tfindObject(template) {\n\t\t\treturn this.findOne(this.byExample(template));\n\t\t}\n\t\n\t\tfindObjects(template) {\n\t\t\treturn this.find(this.byExample(template));\n\t\t}\n\t\n\t\t/*----------------------------+\n\t  | TTL daemon                  |\n\t  +----------------------------*/\n\t\tttlDaemonFuncGen() {\n\t\t\tvar collection = this;\n\t\t\tvar age = this.ttl.age;\n\t\t\treturn function ttlDaemon() {\n\t\t\t\tvar now = Date.now();\n\t\t\t\tvar toRemove = collection.chain().where(function daemonFilter(member) {\n\t\t\t\t\tvar timestamp = member.meta.updated || member.meta.created;\n\t\t\t\t\tvar diff = now - timestamp;\n\t\t\t\t\treturn age < diff;\n\t\t\t\t});\n\t\t\t\ttoRemove.remove();\n\t\t\t};\n\t\t}\n\t\n\t\tsetTTL(age, interval) {\n\t\t\tif (age < 0) {\n\t\t\t\tclearInterval(this.ttl.daemon);\n\t\t\t} else {\n\t\t\t\tthis.ttl.age = age;\n\t\t\t\tthis.ttl.ttlInterval = interval;\n\t\t\t\tthis.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n\t\t\t}\n\t\t}\n\t\n\t\t/*----------------------------+\n\t  | INDEXING                    |\n\t  +----------------------------*/\n\t\n\t\t/**\n\t  * create a row filter that covers all documents in the collection\n\t  */\n\t\tprepareFullDocIndex() {\n\t\t\tvar len = this.data.length;\n\t\t\tvar indexes = new Array(len);\n\t\t\tfor (var i = 0; i < len; i += 1) {\n\t\t\t\tindexes[i] = i;\n\t\t\t}\n\t\t\treturn indexes;\n\t\t}\n\t\n\t\t/**\n\t  * Will allow reconfiguring certain collection options.\n\t  * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n\t  * @memberof Collection\n\t  */\n\t\tconfigureOptions(options) {\n\t\t\toptions = options || {};\n\t\n\t\t\tif (options.hasOwnProperty('adaptiveBinaryIndices')) {\n\t\t\t\tthis.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\t\n\t\t\t\t// if switching to adaptive binary indices, make sure none are 'dirty'\n\t\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t\tthis.ensureAllIndexes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Ensure binary index on a certain field\n\t  * @param {string} property - name of property to create binary index on\n\t  * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n\t  * @memberof Collection\n\t  */\n\t\tensureIndex(property, force) {\n\t\t\t// optional parameter to force rebuild whether flagged as dirty or not\n\t\t\tif (typeof force === 'undefined') {\n\t\t\t\tforce = false;\n\t\t\t}\n\t\n\t\t\tif (property === null || property === undefined) {\n\t\t\t\tthrow new Error('Attempting to set index without an associated property');\n\t\t\t}\n\t\n\t\t\tif (this.binaryIndices[property] && !force) {\n\t\t\t\tif (!this.binaryIndices[property].dirty) return;\n\t\t\t}\n\t\n\t\t\t// if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n\t\t\tif (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar index = {\n\t\t\t\t'name': property,\n\t\t\t\t'dirty': true,\n\t\t\t\t'values': this.prepareFullDocIndex()\n\t\t\t};\n\t\t\tthis.binaryIndices[property] = index;\n\t\n\t\t\tvar wrappedComparer = function (p, data) {\n\t\t\t\treturn function (a, b) {\n\t\t\t\t\tvar objAp = data[a][p],\n\t\t\t\t\t    objBp = data[b][p];\n\t\t\t\t\tif (objAp !== objBp) {\n\t\t\t\t\t\tif ((0, _helper.ltHelper)(objAp, objBp, false)) return -1;\n\t\t\t\t\t\tif ((0, _helper.gtHelper)(objAp, objBp, false)) return 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\t}(property, this.data);\n\t\n\t\t\tindex.values.sort(wrappedComparer);\n\t\t\tindex.dirty = false;\n\t\n\t\t\tthis.dirty = true; // for autosave scenarios\n\t\t}\n\t\n\t\tgetSequencedIndexValues(property) {\n\t\t\tvar idx,\n\t\t\t    idxvals = this.binaryIndices[property].values;\n\t\t\tvar result = \"\";\n\t\n\t\t\tfor (idx = 0; idx < idxvals.length; idx++) {\n\t\t\t\tresult += \" [\" + idx + \"] \" + this.data[idxvals[idx]][property];\n\t\t\t}\n\t\n\t\t\treturn result;\n\t\t}\n\t\n\t\tensureUniqueIndex(field) {\n\t\t\tvar index = this.constraints.unique[field];\n\t\t\tif (!index) {\n\t\t\t\t// keep track of new unique index for regenerate after database (re)load.\n\t\t\t\tif (this.uniqueNames.indexOf(field) == -1) {\n\t\t\t\t\tthis.uniqueNames.push(field);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// if index already existed, (re)loading it will likely cause collisions, rebuild always\n\t\t\tthis.constraints.unique[field] = index = new _unique_index.UniqueIndex(field);\n\t\t\tthis.data.forEach(function (obj) {\n\t\t\t\tindex.set(obj);\n\t\t\t});\n\t\t\treturn index;\n\t\t}\n\t\n\t\t/**\n\t  * Ensure all binary indices\n\t  */\n\t\tensureAllIndexes(force) {\n\t\t\tvar key,\n\t\t\t    bIndices = this.binaryIndices;\n\t\t\tfor (key in bIndices) {\n\t\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\t\tthis.ensureIndex(key, force);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tflagBinaryIndexesDirty() {\n\t\t\tvar key,\n\t\t\t    bIndices = this.binaryIndices;\n\t\t\tfor (key in bIndices) {\n\t\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\t\tbIndices[key].dirty = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tflagBinaryIndexDirty(index) {\n\t\t\tif (this.binaryIndices[index]) this.binaryIndices[index].dirty = true;\n\t\t}\n\t\n\t\t/**\n\t  * Quickly determine number of documents in collection (or query)\n\t  * @param {object=} query - (optional) query object to count results of\n\t  * @returns {number} number of documents in the collection\n\t  * @memberof Collection\n\t  */\n\t\tcount(query) {\n\t\t\tif (!query) {\n\t\t\t\treturn this.data.length;\n\t\t\t}\n\t\n\t\t\treturn this.chain().find(query).filteredrows.length;\n\t\t}\n\t\n\t\t/**\n\t  * Rebuild idIndex\n\t  */\n\t\tensureId() {\n\t\t\tvar len = this.data.length,\n\t\t\t    i = 0;\n\t\n\t\t\tthis.idIndex = [];\n\t\t\tfor (i; i < len; i += 1) {\n\t\t\t\tthis.idIndex.push(this.data[i].$loki);\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Add a dynamic view to the collection\n\t  * @param {string} name - name of dynamic view to add\n\t  * @param {object=} options - (optional) options to configure dynamic view with\n\t  * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t  * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t  * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t  * @returns {DynamicView} reference to the dynamic view added\n\t  * @memberof Collection\n\t  **/\n\t\n\t\taddDynamicView(name, options) {\n\t\t\tvar dv = new _dynamic_view.DynamicView(this, name, options);\n\t\t\tthis.DynamicViews.push(dv);\n\t\n\t\t\treturn dv;\n\t\t}\n\t\n\t\t/**\n\t  * Remove a dynamic view from the collection\n\t  * @param {string} name - name of dynamic view to remove\n\t  * @memberof Collection\n\t  **/\n\t\tremoveDynamicView(name) {\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\t\tthis.DynamicViews.splice(idx, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Look up dynamic view reference from within the collection\n\t  * @param {string} name - name of dynamic view to retrieve reference of\n\t  * @returns {DynamicView} A reference to the dynamic view with that name\n\t  * @memberof Collection\n\t  **/\n\t\tgetDynamicView(name) {\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\t\treturn this.DynamicViews[idx];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn null;\n\t\t}\n\t\n\t\t/**\n\t  * Applies a 'mongo-like' find query object and passes all results to an update function.\n\t  * For filter function querying you should migrate to [updateWhere()]{@link Collection#updateWhere}.\n\t  *\n\t  * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n\t  * @param {function} updateFunction - update function to run against filtered documents\n\t  * @memberof Collection\n\t  */\n\t\tfindAndUpdate(filterObject, updateFunction) {\n\t\t\tif (typeof filterObject === \"function\") {\n\t\t\t\tthis.updateWhere(filterObject, updateFunction);\n\t\t\t} else {\n\t\t\t\tthis.chain().find(filterObject).update(updateFunction);\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Applies a 'mongo-like' find query object removes all documents which match that filter.\n\t  *\n\t  * @param {object} filterObject - 'mongo-like' query object\n\t  * @memberof Collection\n\t  */\n\t\tfindAndRemove(filterObject) {\n\t\t\tthis.chain().find(filterObject).remove();\n\t\t}\n\t\n\t\t/**\n\t  * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n\t  * @param {(object|array)} doc - the document (or array of documents) to be inserted\n\t  * @returns {(object|array)} document or documents inserted\n\t  * @memberof Collection\n\t  */\n\t\tinsert(doc) {\n\t\t\tif (!Array.isArray(doc)) {\n\t\t\t\treturn this.insertOne(doc);\n\t\t\t}\n\t\n\t\t\t// holder to the clone of the object inserted if collections is set to clone objects\n\t\t\tvar obj;\n\t\t\tvar results = [];\n\t\n\t\t\tthis.emit('pre-insert', doc);\n\t\t\tfor (var i = 0, len = doc.length; i < len; i++) {\n\t\t\t\tobj = this.insertOne(doc[i], true);\n\t\t\t\tif (!obj) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tresults.push(obj);\n\t\t\t}\n\t\t\tthis.emit('insert', doc);\n\t\t\treturn results.length === 1 ? results[0] : results;\n\t\t}\n\t\n\t\t/**\n\t  * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n\t  * @param {object} doc - the document to be inserted\n\t  * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n\t  * @returns {object} document or 'undefined' if there was a problem inserting it\n\t  * @memberof Collection\n\t  */\n\t\tinsertOne(doc, bulkInsert) {\n\t\t\tvar err = null;\n\t\t\tvar returnObj;\n\t\n\t\t\tif (typeof doc !== 'object') {\n\t\t\t\terr = new TypeError('Document needs to be an object');\n\t\t\t} else if (doc === null) {\n\t\t\t\terr = new TypeError('Object cannot be null');\n\t\t\t}\n\t\n\t\t\tif (err !== null) {\n\t\t\t\tthis.emit('error', err);\n\t\t\t\tthrow err;\n\t\t\t}\n\t\n\t\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\t\tvar obj = this.cloneObjects ? (0, _clone.clone)(doc, this.cloneMethod) : doc;\n\t\n\t\t\tif (typeof obj.meta === 'undefined') {\n\t\t\t\tobj.meta = {\n\t\t\t\t\trevision: 0,\n\t\t\t\t\tcreated: 0\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t// allow pre-insert to modify actual collection reference even if cloning\n\t\t\tif (!bulkInsert) {\n\t\t\t\tthis.emit('pre-insert', obj);\n\t\t\t}\n\t\t\tif (!this.add(obj)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\n\t\t\t// if cloning, give user back clone of 'cloned' object with $loki and meta\n\t\t\treturnObj = this.cloneObjects ? (0, _clone.clone)(obj, this.cloneMethod) : obj;\n\t\n\t\t\tthis.addAutoUpdateObserver(returnObj);\n\t\t\tif (!bulkInsert) {\n\t\t\t\tthis.emit('insert', returnObj);\n\t\t\t}\n\t\t\treturn returnObj;\n\t\t}\n\t\n\t\t/**\n\t  * Empties the collection.\n\t  * @param {object=} options - configure clear behavior\n\t  * @param {bool=} options.removeIndices - (default: false)\n\t  * @memberof Collection\n\t  */\n\t\tclear(options) {\n\t\t\tvar self = this;\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tthis.data = [];\n\t\t\tthis.idIndex = [];\n\t\t\tthis.cachedIndex = null;\n\t\t\tthis.cachedBinaryIndex = null;\n\t\t\tthis.cachedData = null;\n\t\t\tthis.maxId = 0;\n\t\t\tthis.DynamicViews = [];\n\t\t\tthis.dirty = true;\n\t\n\t\t\t// if removing indices entirely\n\t\t\tif (options.removeIndices === true) {\n\t\t\t\tthis.binaryIndices = {};\n\t\n\t\t\t\tthis.constraints = {\n\t\t\t\t\tunique: {},\n\t\t\t\t\texact: {}\n\t\t\t\t};\n\t\t\t\tthis.uniqueNames = [];\n\t\t\t}\n\t\t\t// clear indices but leave definitions in place\n\t\t\telse {\n\t\t\t\t\t// clear binary indices\n\t\t\t\t\tvar keys = Object.keys(this.binaryIndices);\n\t\t\t\t\tkeys.forEach(function (biname) {\n\t\t\t\t\t\tself.binaryIndices[biname].dirty = false;\n\t\t\t\t\t\tself.binaryIndices[biname].values = [];\n\t\t\t\t\t});\n\t\n\t\t\t\t\t// clear entire unique indices definition\n\t\t\t\t\tthis.constraints = {\n\t\t\t\t\t\tunique: {},\n\t\t\t\t\t\texact: {}\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// add definitions back\n\t\t\t\t\tthis.uniqueNames.forEach(function (uiname) {\n\t\t\t\t\t\tself.ensureUniqueIndex(uiname);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Updates an object and notifies collection that the document has changed.\n\t  * @param {object} doc - document to update within the collection\n\t  * @memberof Collection\n\t  */\n\t\tupdate(doc) {\n\t\t\tif (Array.isArray(doc)) {\n\t\t\t\tvar k = 0,\n\t\t\t\t    len = doc.length;\n\t\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\t\tthis.update(doc[k]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// verify object is a properly formed document\n\t\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\t\tthrow new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tthis.startTransaction();\n\t\t\t\tvar arr = this.get(doc.$loki, true),\n\t\t\t\t    oldInternal,\n\t\t\t\t    // ref to existing obj\n\t\t\t\tnewInternal,\n\t\t\t\t    // ref to new internal obj\n\t\t\t\tposition,\n\t\t\t\t    self = this;\n\t\n\t\t\t\tif (!arr) {\n\t\t\t\t\tthrow new Error('Trying to update a document not in collection.');\n\t\t\t\t}\n\t\n\t\t\t\toldInternal = arr[0]; // -internal- obj ref\n\t\t\t\tposition = arr[1]; // position in data array\n\t\n\t\t\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\t\t\tnewInternal = this.cloneObjects ? (0, _clone.clone)(doc, this.cloneMethod) : doc;\n\t\n\t\t\t\tthis.emit('pre-update', doc);\n\t\n\t\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\t\tself.constraints.unique[key].update(oldInternal, newInternal);\n\t\t\t\t});\n\t\n\t\t\t\t// operate the update\n\t\t\t\tthis.data[position] = newInternal;\n\t\n\t\t\t\tif (newInternal !== doc) {\n\t\t\t\t\tthis.addAutoUpdateObserver(doc);\n\t\t\t\t}\n\t\n\t\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\t\tthis.DynamicViews[idx].evaluateDocument(position, false);\n\t\t\t\t}\n\t\n\t\t\t\tvar key;\n\t\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\t\tthis.adaptiveBinaryIndexUpdate(position, key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t\t}\n\t\n\t\t\t\tthis.idIndex[position] = newInternal.$loki;\n\t\t\t\t//this.flagBinaryIndexesDirty();\n\t\n\t\t\t\tthis.commit();\n\t\t\t\tthis.dirty = true; // for autosave scenarios\n\t\n\t\t\t\tthis.emit('update', doc, this.cloneObjects ? (0, _clone.clone)(oldInternal, this.cloneMethod) : null);\n\t\t\t\treturn doc;\n\t\t\t} catch (err) {\n\t\t\t\tthis.rollback();\n\t\t\t\tthis.console.error(err.message);\n\t\t\t\tthis.emit('error', err);\n\t\t\t\tthrow err; // re-throw error so user does not think it succeeded\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Add object to collection\n\t  */\n\t\tadd(obj) {\n\t\t\t// if parameter isn't object exit with throw\n\t\t\tif ('object' !== typeof obj) {\n\t\t\t\tthrow new TypeError('Object being added needs to be an object');\n\t\t\t}\n\t\t\t// if object you are adding already has id column it is either already in the collection\n\t\t\t// or the object is carrying its own 'id' property.  If it also has a meta property,\n\t\t\t// then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n\t\t\tif (typeof obj.$loki !== 'undefined') {\n\t\t\t\tthrow new Error('Document is already in collection, please use update()');\n\t\t\t}\n\t\n\t\t\t/*\n\t   * try adding object to collection\n\t   */\n\t\t\ttry {\n\t\t\t\tthis.startTransaction();\n\t\t\t\tthis.maxId++;\n\t\n\t\t\t\tif (isNaN(this.maxId)) {\n\t\t\t\t\tthis.maxId = this.data[this.data.length - 1].$loki + 1;\n\t\t\t\t}\n\t\n\t\t\t\tobj.$loki = this.maxId;\n\t\t\t\tobj.meta.version = 0;\n\t\n\t\t\t\tvar key,\n\t\t\t\t    constrUnique = this.constraints.unique;\n\t\t\t\tfor (key in constrUnique) {\n\t\t\t\t\tif (hasOwnProperty.call(constrUnique, key)) {\n\t\t\t\t\t\tconstrUnique[key].set(obj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// add new obj id to idIndex\n\t\t\t\tthis.idIndex.push(obj.$loki);\n\t\n\t\t\t\t// add the object\n\t\t\t\tthis.data.push(obj);\n\t\n\t\t\t\tvar addedPos = this.data.length - 1;\n\t\n\t\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\t\tvar dvlen = this.DynamicViews.length;\n\t\t\t\tfor (var i = 0; i < dvlen; i++) {\n\t\t\t\t\tthis.DynamicViews[i].evaluateDocument(addedPos, true);\n\t\t\t\t}\n\t\n\t\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\t\tthis.adaptiveBinaryIndexInsert(addedPos, key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t\t}\n\t\n\t\t\t\tthis.commit();\n\t\t\t\tthis.dirty = true; // for autosave scenarios\n\t\n\t\t\t\treturn this.cloneObjects ? (0, _clone.clone)(obj, this.cloneMethod) : obj;\n\t\t\t} catch (err) {\n\t\t\t\tthis.rollback();\n\t\t\t\tthis.console.error(err.message);\n\t\t\t\tthis.emit('error', err);\n\t\t\t\tthrow err; // re-throw error so user does not think it succeeded\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Applies a filter function and passes all results to an update function.\n\t  *\n\t  * @param {function} filterFunction - filter function whose results will execute update\n\t  * @param {function} updateFunction - update function to run against filtered documents\n\t  * @memberof Collection\n\t  */\n\t\tupdateWhere(filterFunction, updateFunction) {\n\t\t\tvar results = this.where(filterFunction),\n\t\t\t    i = 0,\n\t\t\t    obj;\n\t\t\ttry {\n\t\t\t\tfor (i; i < results.length; i++) {\n\t\t\t\t\tobj = updateFunction(results[i]);\n\t\t\t\t\tthis.update(obj);\n\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tthis.rollback();\n\t\t\t\tthis.console.error(err.message);\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Remove all documents matching supplied filter function.\n\t  * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n\t  * @param {function|object} query - query object to filter on\n\t  * @memberof Collection\n\t  */\n\t\tremoveWhere(query) {\n\t\t\tvar list;\n\t\t\tif (typeof query === 'function') {\n\t\t\t\tlist = this.data.filter(query);\n\t\t\t\tthis.remove(list);\n\t\t\t} else {\n\t\t\t\tthis.chain().find(query).remove();\n\t\t\t}\n\t\t}\n\t\n\t\tremoveDataOnly() {\n\t\t\tthis.remove(this.data.slice());\n\t\t}\n\t\n\t\t/**\n\t  * Remove a document from the collection\n\t  * @param {object} doc - document to remove from collection\n\t  * @memberof Collection\n\t  */\n\t\tremove(doc) {\n\t\t\tif (typeof doc === 'number') {\n\t\t\t\tdoc = this.get(doc);\n\t\t\t}\n\t\n\t\t\tif ('object' !== typeof doc) {\n\t\t\t\tthrow new Error('Parameter is not an object');\n\t\t\t}\n\t\t\tif (Array.isArray(doc)) {\n\t\t\t\tvar k = 0,\n\t\t\t\t    len = doc.length;\n\t\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\t\tthis.remove(doc[k]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\t\tthrow new Error('Object is not a document stored in the collection');\n\t\t\t}\n\t\n\t\t\ttry {\n\t\t\t\tthis.startTransaction();\n\t\t\t\tvar arr = this.get(doc.$loki, true),\n\t\n\t\t\t\t// obj = arr[0],\n\t\t\t\tposition = arr[1];\n\t\t\t\tvar self = this;\n\t\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\t\tif (doc[key] !== null && typeof doc[key] !== 'undefined') {\n\t\t\t\t\t\tself.constraints.unique[key].remove(doc[key]);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t\t// submit it for all registered DynamicViews to remove\n\t\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\t\tthis.DynamicViews[idx].removeDocument(position);\n\t\t\t\t}\n\t\n\t\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\t\tvar key,\n\t\t\t\t\t    bIndices = this.binaryIndices;\n\t\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\t\tthis.adaptiveBinaryIndexRemove(position, key);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t\t}\n\t\n\t\t\t\tthis.data.splice(position, 1);\n\t\t\t\tthis.removeAutoUpdateObserver(doc);\n\t\n\t\t\t\t// remove id from idIndex\n\t\t\t\tthis.idIndex.splice(position, 1);\n\t\n\t\t\t\tthis.commit();\n\t\t\t\tthis.dirty = true; // for autosave scenarios\n\t\t\t\tthis.emit('delete', arr[0]);\n\t\t\t\tdelete doc.$loki;\n\t\t\t\tdelete doc.meta;\n\t\t\t\treturn doc;\n\t\t\t} catch (err) {\n\t\t\t\tthis.rollback();\n\t\t\t\tthis.console.error(err.message);\n\t\t\t\tthis.emit('error', err);\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\n\t\t/*---------------------+\n\t  | Finding methods     |\n\t  +----------------------*/\n\t\n\t\t/**\n\t  * Get by Id - faster than other methods because of the searching algorithm\n\t  * @param {int} id - $loki id of document you want to retrieve\n\t  * @param {boolean} returnPosition - if 'true' we will return [object, position]\n\t  * @returns {(object|array|null)} Object reference if document was found, null if not,\n\t  *     or an array if 'returnPosition' was passed.\n\t  * @memberof Collection\n\t  */\n\t\tget(id, returnPosition) {\n\t\t\tvar retpos = returnPosition || false,\n\t\t\t    data = this.idIndex,\n\t\t\t    max = data.length - 1,\n\t\t\t    min = 0,\n\t\t\t    mid = min + max >> 1;\n\t\n\t\t\tid = typeof id === 'number' ? id : parseInt(id, 10);\n\t\n\t\t\tif (isNaN(id)) {\n\t\t\t\tthrow new TypeError('Passed id is not an integer');\n\t\t\t}\n\t\n\t\t\twhile (data[min] < data[max]) {\n\t\t\t\tmid = min + max >> 1;\n\t\n\t\t\t\tif (data[mid] < id) {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmax = mid;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (max === min && data[min] === id) {\n\t\t\t\tif (retpos) {\n\t\t\t\t\treturn [this.data[min], min];\n\t\t\t\t}\n\t\t\t\treturn this.data[min];\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\n\t\t/**\n\t  * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n\t  *    Since multiple documents may contain the same value (which the index is sorted on),\n\t  *    we hone in on range and then linear scan range to find exact index array position.\n\t  * @param {int} dataPosition : coll.data array index/position\n\t  * @param {string} binaryIndexName : index to search for dataPosition in\n\t  */\n\t\tgetBinaryIndexPosition(dataPosition, binaryIndexName) {\n\t\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\n\t\t\t// i think calculateRange can probably be moved to collection\n\t\t\t// as it doesn't seem to need resultset.  need to verify\n\t\t\t//var rs = new Resultset(this, null, null);\n\t\t\tvar range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\t\n\t\t\tif (range[0] === 0 && range[1] === -1) {\n\t\t\t\t// uhoh didn't find range\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\tvar min = range[0];\n\t\t\tvar max = range[1];\n\t\n\t\t\t// narrow down the sub-segment of index values\n\t\t\t// where the indexed property value exactly matches our\n\t\t\t// value and then linear scan to find exact -index- position\n\t\t\tfor (var idx = min; idx <= max; idx++) {\n\t\t\t\tif (index[idx] === dataPosition) return idx;\n\t\t\t}\n\t\n\t\t\t// uhoh\n\t\t\treturn null;\n\t\t}\n\t\n\t\t/**\n\t  * Adaptively insert a selected item to the index.\n\t  * @param {int} dataPosition : coll.data array index/position\n\t  * @param {string} binaryIndexName : index to search for dataPosition in\n\t  */\n\t\tadaptiveBinaryIndexInsert(dataPosition, binaryIndexName) {\n\t\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\t\t//var rs = new Resultset(this, null, null);\n\t\t\tvar idxPos = this.calculateRangeStart(binaryIndexName, val);\n\t\n\t\t\t// insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n\t\t\t// doing this after adjusting dataPositions so no clash with previous item at that position.\n\t\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n\t\t}\n\t\n\t\t/**\n\t  * Adaptively update a selected item within an index.\n\t  * @param {int} dataPosition : coll.data array index/position\n\t  * @param {string} binaryIndexName : index to search for dataPosition in\n\t  */\n\t\tadaptiveBinaryIndexUpdate(dataPosition, binaryIndexName) {\n\t\t\t// linear scan needed to find old position within index unless we optimize for clone scenarios later\n\t\t\t// within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n\t\t\tvar idxPos,\n\t\t\t    index = this.binaryIndices[binaryIndexName].values,\n\t\t\t    len = index.length;\n\t\n\t\t\tfor (idxPos = 0; idxPos < len; idxPos++) {\n\t\t\t\tif (index[idxPos] === dataPosition) break;\n\t\t\t}\n\t\n\t\t\t//var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n\t\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\t\n\t\t\t//this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n\t\t\tthis.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n\t\t}\n\t\n\t\t/**\n\t  * Adaptively remove a selected item from the index.\n\t  * @param {int} dataPosition : coll.data array index/position\n\t  * @param {string} binaryIndexName : index to search for dataPosition in\n\t  */\n\t\tadaptiveBinaryIndexRemove(dataPosition, binaryIndexName, removedFromIndexOnly) {\n\t\t\tvar idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\t\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\t\tvar len, idx;\n\t\n\t\t\tif (idxPos === null) {\n\t\t\t\t// throw new Error('unable to determine binary index position');\n\t\t\t\treturn null;\n\t\t\t}\n\t\n\t\t\t// remove document from index\n\t\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\t\n\t\t\t// if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n\t\t\t// in which case data positions stay the same.\n\t\t\tif (removedFromIndexOnly === true) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// since index stores data array positions, if we remove a document\n\t\t\t// we need to adjust array positions -1 for all document positions greater than removed position\n\t\t\tlen = index.length;\n\t\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\t\tif (index[idx] > dataPosition) {\n\t\t\t\t\tindex[idx]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Internal method used for index maintenance.  Given a prop (index name), and a value\n\t  * (which may or may not yet exist) this will find the proper location where it can be added.\n\t  */\n\t\tcalculateRangeStart(prop, val) {\n\t\t\tvar rcd = this.data;\n\t\t\tvar index = this.binaryIndices[prop].values;\n\t\t\tvar min = 0;\n\t\t\tvar max = index.length - 1;\n\t\t\tvar mid = 0;\n\t\n\t\t\tif (index.length === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\tvar minVal = rcd[index[min]][prop];\n\t\t\tvar maxVal = rcd[index[max]][prop];\n\t\n\t\t\t// hone in on start position of value\n\t\t\twhile (min < max) {\n\t\t\t\tmid = min + max >> 1;\n\t\n\t\t\t\tif ((0, _helper.ltHelper)(rcd[index[mid]][prop], val, false)) {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmax = mid;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar lbound = min;\n\t\n\t\t\tif ((0, _helper.ltHelper)(rcd[index[lbound]][prop], val, false)) {\n\t\t\t\treturn lbound + 1;\n\t\t\t} else {\n\t\t\t\treturn lbound;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Internal method used for indexed $between.  Given a prop (index name), and a value\n\t  * (which may or may not yet exist) this will find the final position of that upper range value.\n\t  */\n\t\tcalculateRangeEnd(prop, val) {\n\t\t\tvar rcd = this.data;\n\t\t\tvar index = this.binaryIndices[prop].values;\n\t\t\tvar min = 0;\n\t\t\tvar max = index.length - 1;\n\t\t\tvar mid = 0;\n\t\n\t\t\tif (index.length === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\n\t\t\tvar minVal = rcd[index[min]][prop];\n\t\t\tvar maxVal = rcd[index[max]][prop];\n\t\n\t\t\t// hone in on start position of value\n\t\t\twhile (min < max) {\n\t\t\t\tmid = min + max >> 1;\n\t\n\t\t\t\tif ((0, _helper.ltHelper)(val, rcd[index[mid]][prop], false)) {\n\t\t\t\t\tmax = mid;\n\t\t\t\t} else {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar ubound = max;\n\t\n\t\t\tif ((0, _helper.gtHelper)(rcd[index[ubound]][prop], val, false)) {\n\t\t\t\treturn ubound - 1;\n\t\t\t} else {\n\t\t\t\treturn ubound;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n\t  *    this is used for collection.find() and first find filter of resultset/dynview\n\t  *    slightly different than get() binary search in that get() hones in on 1 value,\n\t  *    but we have to hone in on many (range)\n\t  * @param {string} op - operation, such as $eq\n\t  * @param {string} prop - name of property to calculate range for\n\t  * @param {object} val - value to use for range calculation.\n\t  * @returns {array} [start, end] index array positions\n\t  */\n\t\tcalculateRange(op, prop, val) {\n\t\t\tvar rcd = this.data;\n\t\t\tvar index = this.binaryIndices[prop].values;\n\t\t\tvar min = 0;\n\t\t\tvar max = index.length - 1;\n\t\t\tvar mid = 0;\n\t\n\t\t\t// when no documents are in collection, return empty range condition\n\t\t\tif (rcd.length === 0) {\n\t\t\t\treturn [0, -1];\n\t\t\t}\n\t\n\t\t\tvar minVal = rcd[index[min]][prop];\n\t\t\tvar maxVal = rcd[index[max]][prop];\n\t\n\t\t\t// if value falls outside of our range return [0, -1] to designate no results\n\t\t\tswitch (op) {\n\t\t\t\tcase '$eq':\n\t\t\t\tcase '$aeq':\n\t\t\t\t\tif ((0, _helper.ltHelper)(val, minVal, false) || (0, _helper.gtHelper)(val, maxVal, false)) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$dteq':\n\t\t\t\t\tif ((0, _helper.ltHelper)(val, minVal, false) || (0, _helper.gtHelper)(val, maxVal, false)) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$gt':\n\t\t\t\t\tif ((0, _helper.gtHelper)(val, maxVal, true)) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$gte':\n\t\t\t\t\tif ((0, _helper.gtHelper)(val, maxVal, false)) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$lt':\n\t\t\t\t\tif ((0, _helper.ltHelper)(val, minVal, true)) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\t\t\t\tif ((0, _helper.ltHelper)(maxVal, val, false)) {\n\t\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$lte':\n\t\t\t\t\tif ((0, _helper.ltHelper)(val, minVal, false)) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\t\t\t\tif ((0, _helper.ltHelper)(maxVal, val, true)) {\n\t\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '$between':\n\t\t\t\t\treturn [this.calculateRangeStart(prop, val[0]), this.calculateRangeEnd(prop, val[1])];\n\t\t\t\tcase '$in':\n\t\t\t\t\tvar idxset = [],\n\t\t\t\t\t    segResult = [];\n\t\t\t\t\t// query each value '$eq' operator and merge the seqment results.\n\t\t\t\t\tfor (var j = 0, len = val.length; j < len; j++) {\n\t\t\t\t\t\tvar seg = this.calculateRange('$eq', prop, val[j]);\n\t\n\t\t\t\t\t\tfor (var i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\t\tif (idxset[i] === undefined) {\n\t\t\t\t\t\t\t\tidxset[i] = true;\n\t\t\t\t\t\t\t\tsegResult.push(i);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn segResult;\n\t\t\t}\n\t\n\t\t\t// hone in on start position of value\n\t\t\twhile (min < max) {\n\t\t\t\tmid = min + max >> 1;\n\t\n\t\t\t\tif ((0, _helper.ltHelper)(rcd[index[mid]][prop], val, false)) {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t} else {\n\t\t\t\t\tmax = mid;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar lbound = min;\n\t\n\t\t\t// do not reset min, as the upper bound cannot be prior to the found low bound\n\t\t\tmax = index.length - 1;\n\t\n\t\t\t// hone in on end position of value\n\t\t\twhile (min < max) {\n\t\t\t\tmid = min + max >> 1;\n\t\n\t\t\t\tif ((0, _helper.ltHelper)(val, rcd[index[mid]][prop], false)) {\n\t\t\t\t\tmax = mid;\n\t\t\t\t} else {\n\t\t\t\t\tmin = mid + 1;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar ubound = max;\n\t\n\t\t\tvar lval = rcd[index[lbound]][prop];\n\t\t\tvar uval = rcd[index[ubound]][prop];\n\t\n\t\t\tswitch (op) {\n\t\t\t\tcase '$eq':\n\t\t\t\t\tif (lval !== val) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\t\t\t\tif (uval !== val) {\n\t\t\t\t\t\tubound--;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn [lbound, ubound];\n\t\t\t\tcase '$dteq':\n\t\t\t\t\tif (lval > val || lval < val) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\t\t\t\tif (uval > val || uval < val) {\n\t\t\t\t\t\tubound--;\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn [lbound, ubound];\n\t\n\t\t\t\tcase '$gt':\n\t\t\t\t\tif ((0, _helper.ltHelper)(uval, val, true)) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn [ubound, rcd.length - 1];\n\t\n\t\t\t\tcase '$gte':\n\t\t\t\t\tif ((0, _helper.ltHelper)(lval, val, false)) {\n\t\t\t\t\t\treturn [0, -1];\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn [lbound, rcd.length - 1];\n\t\n\t\t\t\tcase '$lt':\n\t\t\t\t\tif (lbound === 0 && (0, _helper.ltHelper)(lval, val, false)) {\n\t\t\t\t\t\treturn [0, 0];\n\t\t\t\t\t}\n\t\t\t\t\treturn [0, lbound - 1];\n\t\n\t\t\t\tcase '$lte':\n\t\t\t\t\tif (uval !== val) {\n\t\t\t\t\t\tubound--;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (ubound === 0 && (0, _helper.ltHelper)(uval, val, false)) {\n\t\t\t\t\t\treturn [0, 0];\n\t\t\t\t\t}\n\t\t\t\t\treturn [0, ubound];\n\t\n\t\t\t\tdefault:\n\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Retrieve doc by Unique index\n\t  * @param {string} field - name of uniquely indexed property to use when doing lookup\n\t  * @param {value} value - unique value to search for\n\t  * @returns {object} document matching the value passed\n\t  * @memberof Collection\n\t  */\n\t\tby(field, value) {\n\t\t\tvar self;\n\t\t\tif (value === undefined) {\n\t\t\t\tself = this;\n\t\t\t\treturn function (value) {\n\t\t\t\t\treturn self.by(field, value);\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\tvar result = this.constraints.unique[field].get(value);\n\t\t\tif (!this.cloneObjects) {\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn (0, _clone.clone)(result, this.cloneMethod);\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Find one object by index property, by property equal to value\n\t  * @param {object} query - query object used to perform search with\n\t  * @returns {(object|null)} First matching document, or null if none\n\t  * @memberof Collection\n\t  */\n\t\tfindOne(query) {\n\t\t\tquery = query || {};\n\t\n\t\t\t// Instantiate Resultset and exec find op passing firstOnly = true param\n\t\t\tvar result = new _resultset.Resultset(this, {\n\t\t\t\tqueryObj: query,\n\t\t\t\tfirstOnly: true\n\t\t\t});\n\t\n\t\t\tif (Array.isArray(result) && result.length === 0) {\n\t\t\t\treturn null;\n\t\t\t} else {\n\t\t\t\tif (!this.cloneObjects) {\n\t\t\t\t\treturn result;\n\t\t\t\t} else {\n\t\t\t\t\treturn (0, _clone.clone)(result, this.cloneMethod);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Chain method, used for beginning a series of chained find() and/or view() operations\n\t  * on a collection.\n\t  *\n\t  * @param {array} transform - Ordered array of transform step objects similar to chain\n\t  * @param {object} parameters - Object containing properties representing parameters to substitute\n\t  * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n\t  * @memberof Collection\n\t  */\n\t\tchain(transform, parameters) {\n\t\t\tvar rs = new _resultset.Resultset(this);\n\t\n\t\t\tif (typeof transform === 'undefined') {\n\t\t\t\treturn rs;\n\t\t\t}\n\t\n\t\t\treturn rs.transform(transform, parameters);\n\t\t}\n\t\n\t\t/**\n\t  * Find method, api is similar to mongodb.\n\t  * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n\t  * @example {@tutorial Query Examples}\n\t  * @param {object} query - 'mongo-like' query object\n\t  * @returns {array} Array of matching documents\n\t  * @memberof Collection\n\t  */\n\t\tfind(query) {\n\t\t\tif (typeof query === 'undefined') {\n\t\t\t\tquery = 'getAll';\n\t\t\t}\n\t\n\t\t\tvar results = new _resultset.Resultset(this, {\n\t\t\t\tqueryObj: query\n\t\t\t});\n\t\t\tif (!this.cloneObjects) {\n\t\t\t\treturn results;\n\t\t\t} else {\n\t\t\t\treturn (0, _clone.cloneObjectArray)(results, this.cloneMethod);\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Find object by unindexed field by property equal to value,\n\t  * simply iterates and returns the first element matching the query\n\t  */\n\t\tfindOneUnindexed(prop, value) {\n\t\t\tvar i = this.data.length,\n\t\t\t    doc;\n\t\t\twhile (i--) {\n\t\t\t\tif (this.data[i][prop] === value) {\n\t\t\t\t\tdoc = this.data[i];\n\t\t\t\t\treturn doc;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t\n\t\t/**\n\t  * Transaction methods\n\t  */\n\t\n\t\t/** start the transation */\n\t\tstartTransaction() {\n\t\t\tif (this.transactional) {\n\t\t\t\tthis.cachedData = (0, _clone.clone)(this.data, this.cloneMethod);\n\t\t\t\tthis.cachedIndex = this.idIndex;\n\t\t\t\tthis.cachedBinaryIndex = this.binaryIndices;\n\t\n\t\t\t\t// propagate startTransaction to dynamic views\n\t\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\t\tthis.DynamicViews[idx].startTransaction();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/** commit the transation */\n\t\tcommit() {\n\t\t\tif (this.transactional) {\n\t\t\t\tthis.cachedData = null;\n\t\t\t\tthis.cachedIndex = null;\n\t\t\t\tthis.cachedBinaryIndex = null;\n\t\n\t\t\t\t// propagate commit to dynamic views\n\t\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\t\tthis.DynamicViews[idx].commit();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/** roll back the transation */\n\t\trollback() {\n\t\t\tif (this.transactional) {\n\t\t\t\tif (this.cachedData !== null && this.cachedIndex !== null) {\n\t\t\t\t\tthis.data = this.cachedData;\n\t\t\t\t\tthis.idIndex = this.cachedIndex;\n\t\t\t\t\tthis.binaryIndices = this.cachedBinaryIndex;\n\t\t\t\t}\n\t\n\t\t\t\t// propagate rollback to dynamic views\n\t\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\t\tthis.DynamicViews[idx].rollback();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Query the collection by supplying a javascript filter function.\n\t  * @example\n\t  * var results = coll.where(function(obj) {\n\t  *   return obj.legs === 8;\n\t  * });\n\t  *\n\t  * @param {function} fun - filter function to run against all collection docs\n\t  * @returns {array} all documents which pass your filter function\n\t  * @memberof Collection\n\t  */\n\t\twhere(fun) {\n\t\t\tvar results = new _resultset.Resultset(this, {\n\t\t\t\tqueryFunc: fun\n\t\t\t});\n\t\t\tif (!this.cloneObjects) {\n\t\t\t\treturn results;\n\t\t\t} else {\n\t\t\t\treturn (0, _clone.cloneObjectArray)(results, this.cloneMethod);\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Map Reduce operation\n\t  *\n\t  * @param {function} mapFunction - function to use as map function\n\t  * @param {function} reduceFunction - function to use as reduce function\n\t  * @returns {data} The result of your mapReduce operation\n\t  * @memberof Collection\n\t  */\n\t\tmapReduce(mapFunction, reduceFunction) {\n\t\t\ttry {\n\t\t\t\treturn reduceFunction(this.data.map(mapFunction));\n\t\t\t} catch (err) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Join two collections on specified properties\n\t  *\n\t  * @param {array} joinData - array of documents to 'join' to this collection\n\t  * @param {string} leftJoinProp - property name in collection\n\t  * @param {string} rightJoinProp - property name in joinData\n\t  * @param {function=} mapFun - (Optional) map function to use\n\t  * @returns {Resultset} Result of the mapping operation\n\t  * @memberof Collection\n\t  */\n\t\teqJoin(joinData, leftJoinProp, rightJoinProp, mapFun) {\n\t\t\t// logic in Resultset class\n\t\t\treturn new _resultset.Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);\n\t\t}\n\t\n\t\t/* ------ STAGING API -------- */\n\t\t/**\n\t  * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t  * manipulated without affecting the data in the original collection\n\t  */\n\t\n\t\t/**\n\t  * (Staging API) create a stage and/or retrieve it\n\t  * @memberof Collection\n\t  */\n\t\tgetStage(name) {\n\t\t\tif (!this.stages[name]) {\n\t\t\t\tthis.stages[name] = {};\n\t\t\t}\n\t\t\treturn this.stages[name];\n\t\t}\n\t\n\t\t/**\n\t  * a collection of objects recording the changes applied through a commmitStage\n\t  */\n\t\n\t\t/**\n\t  * (Staging API) create a copy of an object and insert it into a stage\n\t  * @memberof Collection\n\t  */\n\t\tstage(stageName, obj) {\n\t\t\tvar copy = JSON.parse(JSON.stringify(obj));\n\t\t\tthis.getStage(stageName)[obj.$loki] = copy;\n\t\t\treturn copy;\n\t\t}\n\t\n\t\t/**\n\t  * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n\t  * then create a message to be inserted in the commitlog\n\t  * @param {string} stageName - name of stage\n\t  * @param {string} message\n\t  * @memberof Collection\n\t  */\n\t\tcommitStage(stageName, message) {\n\t\t\tvar stage = this.getStage(stageName),\n\t\t\t    prop,\n\t\t\t    timestamp = new Date().getTime();\n\t\n\t\t\tfor (prop in stage) {\n\t\n\t\t\t\tthis.update(stage[prop]);\n\t\t\t\tthis.commitLog.push({\n\t\t\t\t\ttimestamp: timestamp,\n\t\t\t\t\tmessage: message,\n\t\t\t\t\tdata: JSON.parse(JSON.stringify(stage[prop]))\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.stages[stageName] = {};\n\t\t}\n\t\n\t\tno_op() {\n\t\t\treturn;\n\t\t}\n\t\n\t\t/**\n\t  * @memberof Collection\n\t  */\n\t\textract(field) {\n\t\t\tvar i = 0,\n\t\t\t    len = this.data.length,\n\t\t\t    isDotNotation = isDeepProperty(field),\n\t\t\t    result = [];\n\t\t\tfor (i; i < len; i += 1) {\n\t\t\t\tresult.push(deepProperty(this.data[i], field, isDotNotation));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\n\t\t/**\n\t  * @memberof Collection\n\t  */\n\t\tmax(field) {\n\t\t\treturn Math.max.apply(null, this.extract(field));\n\t\t}\n\t\n\t\t/**\n\t  * @memberof Collection\n\t  */\n\t\tmin(field) {\n\t\t\treturn Math.min.apply(null, this.extract(field));\n\t\t}\n\t\n\t\t/**\n\t  * @memberof Collection\n\t  */\n\t\tmaxRecord(field) {\n\t\t\tvar i = 0,\n\t\t\t    len = this.data.length,\n\t\t\t    deep = isDeepProperty(field),\n\t\t\t    result = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\t    max;\n\t\n\t\t\tfor (i; i < len; i += 1) {\n\t\t\t\tif (max !== undefined) {\n\t\t\t\t\tif (max < deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.value = max;\n\t\t\treturn result;\n\t\t}\n\t\n\t\t/**\n\t  * @memberof Collection\n\t  */\n\t\tminRecord(field) {\n\t\t\tvar i = 0,\n\t\t\t    len = this.data.length,\n\t\t\t    deep = isDeepProperty(field),\n\t\t\t    result = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\t    min;\n\t\n\t\t\tfor (i; i < len; i += 1) {\n\t\t\t\tif (min !== undefined) {\n\t\t\t\t\tif (min > deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult.value = min;\n\t\t\treturn result;\n\t\t}\n\t\n\t\t/**\n\t  * @memberof Collection\n\t  */\n\t\textractNumerical(field) {\n\t\t\treturn this.extract(field).map(parseBase10).filter(Number).filter(function (n) {\n\t\t\t\treturn !isNaN(n);\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t  * Calculates the average numerical value of a property\n\t  *\n\t  * @param {string} field - name of property in docs to average\n\t  * @returns {number} average of property in all docs in the collection\n\t  * @memberof Collection\n\t  */\n\t\tavg(field) {\n\t\t\treturn average(this.extractNumerical(field));\n\t\t}\n\t\n\t\t/**\n\t  * Calculate standard deviation of a field\n\t  * @memberof Collection\n\t  * @param {string} field\n\t  */\n\t\tstdDev(field) {\n\t\t\treturn standardDeviation(this.extractNumerical(field));\n\t\t}\n\t\n\t\t/**\n\t  * @memberof Collection\n\t  * @param {string} field\n\t  */\n\t\tmode(field) {\n\t\t\tvar dict = {},\n\t\t\t    data = this.extract(field);\n\t\t\tdata.forEach(function (obj) {\n\t\t\t\tif (dict[obj]) {\n\t\t\t\t\tdict[obj] += 1;\n\t\t\t\t} else {\n\t\t\t\t\tdict[obj] = 1;\n\t\t\t\t}\n\t\t\t});\n\t\t\tvar max, prop, mode;\n\t\t\tfor (prop in dict) {\n\t\t\t\tif (max) {\n\t\t\t\t\tif (max < dict[prop]) {\n\t\t\t\t\t\tmode = prop;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmode = prop;\n\t\t\t\t\tmax = dict[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn mode;\n\t\t}\n\t\n\t\t/**\n\t  * @memberof Collection\n\t  * @param {string} field - property name\n\t  */\n\t\tmedian(field) {\n\t\t\tvar values = this.extractNumerical(field);\n\t\t\tvalues.sort(sub);\n\t\n\t\t\tvar half = Math.floor(values.length / 2);\n\t\n\t\t\tif (values.length % 2) {\n\t\t\t\treturn values[half];\n\t\t\t} else {\n\t\t\t\treturn (values[half - 1] + values[half]) / 2.0;\n\t\t\t}\n\t\t}\n\t}\n\texports.Collection = Collection;\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\tclass UniqueIndex {\n\t\n\t\tconstructor(uniqueField) {\n\t\t\tthis.field = uniqueField;\n\t\t\tthis.keyMap = {};\n\t\t\tthis.lokiMap = {};\n\t\t}\n\t\n\t\tset(obj) {\n\t\t\tvar fieldValue = obj[this.field];\n\t\t\tif (fieldValue !== null && typeof fieldValue !== 'undefined') {\n\t\t\t\tif (this.keyMap[fieldValue]) {\n\t\t\t\t\tthrow new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n\t\t\t\t} else {\n\t\t\t\t\tthis.keyMap[fieldValue] = obj;\n\t\t\t\t\tthis.lokiMap[obj.$loki] = fieldValue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\tget(key) {\n\t\t\tconsole.log(key);\n\t\t\treturn this.keyMap[key];\n\t\t}\n\t\n\t\tbyId(id) {\n\t\t\tconsole.log(\"byId\", key);\n\t\t\treturn this.keyMap[this.lokiMap[id]];\n\t\t}\n\t\n\t\t/**\n\t  * Updates a document's unique index given an updated object.\n\t  * @param  {Object} obj Original document object\n\t  * @param  {Object} doc New document object (likely the same as obj)\n\t  */\n\t\tupdate(obj, doc) {\n\t\t\tif (this.lokiMap[obj.$loki] !== doc[this.field]) {\n\t\t\t\tvar old = this.lokiMap[obj.$loki];\n\t\t\t\tthis.set(doc);\n\t\t\t\t// make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n\t\t\t\tthis.keyMap[old] = undefined;\n\t\t\t} else {\n\t\t\t\tthis.keyMap[obj[this.field]] = doc;\n\t\t\t}\n\t\t}\n\t\tremove(key) {\n\t\t\tvar obj = this.keyMap[key];\n\t\t\tif (obj !== null && typeof obj !== 'undefined') {\n\t\t\t\tthis.keyMap[key] = undefined;\n\t\t\t\tthis.lokiMap[obj.$loki] = undefined;\n\t\t\t} else {\n\t\t\t\tthrow new Error('Key is not in unique index: ' + this.field);\n\t\t\t}\n\t\t}\n\t\tclear() {\n\t\t\tthis.keyMap = {};\n\t\t\tthis.lokiMap = {};\n\t\t}\n\t}\n\texports.UniqueIndex = UniqueIndex;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\tclass ExactIndex {\n\t\n\t\tconstructor(exactField) {\n\t\t\tthis.index = {};\n\t\t\tthis.field = exactField;\n\t\t}\n\t\n\t\t// add the value you want returned to the key in the index\n\t\tset(key, val) {\n\t\t\tif (this.index[key]) {\n\t\t\t\tthis.index[key].push(val);\n\t\t\t} else {\n\t\t\t\tthis.index[key] = [val];\n\t\t\t}\n\t\t\tconsole.log(\"?\");\n\t\t}\n\t\n\t\t// remove the value from the index, if the value was the last one, remove the key\n\t\tremove(key, val) {\n\t\t\tvar idxSet = this.index[key];\n\t\t\tfor (var i in idxSet) {\n\t\t\t\tif (idxSet[i] == val) {\n\t\t\t\t\tidxSet.splice(i, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (idxSet.length < 1) {\n\t\t\t\tthis.index[key] = undefined;\n\t\t\t}\n\t\t}\n\t\n\t\t// get the values related to the key, could be more than one\n\t\tget(key) {\n\t\t\tconsole.log(\"!\");\n\t\t\treturn this.index[key];\n\t\t}\n\t\n\t\t// clear will zap the index\n\t\tclear(key) {\n\t\t\tthis.index = {};\n\t\t}\n\t}\n\texports.ExactIndex = ExactIndex;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.Resultset = exports.LokiOps = undefined;\n\t\n\tvar _event_emitter = __webpack_require__(2);\n\t\n\tvar _clone = __webpack_require__(9);\n\t\n\tvar _collection = __webpack_require__(5);\n\t\n\tvar _utils = __webpack_require__(10);\n\t\n\tvar _helper = __webpack_require__(11);\n\t\n\tfunction containsCheckFn(a) {\n\t\tif (typeof a === 'string' || Array.isArray(a)) {\n\t\t\treturn function (b) {\n\t\t\t\treturn a.indexOf(b) !== -1;\n\t\t\t};\n\t\t} else if (typeof a === 'object' && a !== null) {\n\t\t\treturn function (b) {\n\t\t\t\treturn hasOwnProperty.call(a, b);\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tfunction doQueryOp(val, op) {\n\t\tfor (var p in op) {\n\t\t\tif (hasOwnProperty.call(op, p)) {\n\t\t\t\treturn LokiOps[p](val, op[p]);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tvar LokiOps = exports.LokiOps = {\n\t\t// comparison operators\n\t\t// a is the value in the collection\n\t\t// b is the query value\n\t\t$eq: function (a, b) {\n\t\t\treturn a === b;\n\t\t},\n\t\n\t\t// abstract/loose equality\n\t\t$aeq: function (a, b) {\n\t\t\treturn a == b;\n\t\t},\n\t\n\t\t$ne: function (a, b) {\n\t\t\t// ecma 5 safe test for NaN\n\t\t\tif (b !== b) {\n\t\t\t\t// ecma 5 test value is not NaN\n\t\t\t\treturn a === a;\n\t\t\t}\n\t\n\t\t\treturn a !== b;\n\t\t},\n\t\n\t\t$dteq: function (a, b) {\n\t\t\tif ((0, _helper.ltHelper)(a, b, false)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn !(0, _helper.gtHelper)(a, b, false);\n\t\t},\n\t\n\t\t$gt: function (a, b) {\n\t\t\treturn (0, _helper.gtHelper)(a, b, false);\n\t\t},\n\t\n\t\t$gte: function (a, b) {\n\t\t\treturn (0, _helper.gtHelper)(a, b, true);\n\t\t},\n\t\n\t\t$lt: function (a, b) {\n\t\t\treturn (0, _helper.ltHelper)(a, b, false);\n\t\t},\n\t\n\t\t$lte: function (a, b) {\n\t\t\treturn (0, _helper.ltHelper)(a, b, true);\n\t\t},\n\t\n\t\t// ex : coll.find({'orderCount': {$between: [10, 50]}});\n\t\t$between: function (a, vals) {\n\t\t\tif (a === undefined || a === null) return false;\n\t\t\treturn (0, _helper.gtHelper)(a, vals[0], true) && (0, _helper.ltHelper)(a, vals[1], true);\n\t\t},\n\t\n\t\t$in: function (a, b) {\n\t\t\treturn b.indexOf(a) !== -1;\n\t\t},\n\t\n\t\t$nin: function (a, b) {\n\t\t\treturn b.indexOf(a) === -1;\n\t\t},\n\t\n\t\t$keyin: function (a, b) {\n\t\t\treturn a in b;\n\t\t},\n\t\n\t\t$nkeyin: function (a, b) {\n\t\t\treturn !(a in b);\n\t\t},\n\t\n\t\t$definedin: function (a, b) {\n\t\t\treturn b[a] !== undefined;\n\t\t},\n\t\n\t\t$undefinedin: function (a, b) {\n\t\t\treturn b[a] === undefined;\n\t\t},\n\t\n\t\t$regex: function (a, b) {\n\t\t\treturn b.test(a);\n\t\t},\n\t\n\t\t$containsString: function (a, b) {\n\t\t\treturn typeof a === 'string' && a.indexOf(b) !== -1;\n\t\t},\n\t\n\t\t$containsNone: function (a, b) {\n\t\t\treturn !LokiOps.$containsAny(a, b);\n\t\t},\n\t\n\t\t$containsAny: function (a, b) {\n\t\t\tvar checkFn = containsCheckFn(a);\n\t\t\tif (checkFn !== null) {\n\t\t\t\treturn Array.isArray(b) ? b.some(checkFn) : checkFn(b);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\t$contains: function (a, b) {\n\t\t\tvar checkFn = containsCheckFn(a);\n\t\t\tif (checkFn !== null) {\n\t\t\t\treturn Array.isArray(b) ? b.every(checkFn) : checkFn(b);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\t$type: function (a, b) {\n\t\t\tvar type = typeof a;\n\t\t\tif (type === 'object') {\n\t\t\t\tif (Array.isArray(a)) {\n\t\t\t\t\ttype = 'array';\n\t\t\t\t} else if (a instanceof Date) {\n\t\t\t\t\ttype = 'date';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn typeof b !== 'object' ? type === b : doQueryOp(type, b);\n\t\t},\n\t\n\t\t$size: function (a, b) {\n\t\t\tif (Array.isArray(a)) {\n\t\t\t\treturn typeof b !== 'object' ? a.length === b : doQueryOp(a.length, b);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\t$len: function (a, b) {\n\t\t\tif (typeof a === 'string') {\n\t\t\t\treturn typeof b !== 'object' ? a.length === b : doQueryOp(a.length, b);\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\n\t\t$where: function (a, b) {\n\t\t\treturn b(a) === true;\n\t\t},\n\t\n\t\t// field-level logical operators\n\t\t// a is the value in the collection\n\t\t// b is the nested query operation (for '$not')\n\t\t//   or an array of nested query operations (for '$and' and '$or')\n\t\t$not: function (a, b) {\n\t\t\treturn !doQueryOp(a, b);\n\t\t},\n\t\n\t\t$and: function (a, b) {\n\t\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\t\tif (!doQueryOp(a, b[idx])) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\n\t\t$or: function (a, b) {\n\t\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\t\tif (doQueryOp(a, b[idx])) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t};\n\t\n\t// making indexing opt-in... our range function knows how to deal with these ops :\n\tvar indexedOpsList = ['$eq', '$aeq', '$dteq', '$gt', '$gte', '$lt', '$lte', '$in', '$between'];\n\t\n\tfunction sortHelper(prop1, prop2, desc) {\n\t\tif (prop1 === prop2) {\n\t\t\treturn 0;\n\t\t}\n\t\n\t\tif ((0, _helper.ltHelper)(prop1, prop2, false)) {\n\t\t\treturn desc ? 1 : -1;\n\t\t}\n\t\n\t\tif ((0, _helper.gtHelper)(prop1, prop2, false)) {\n\t\t\treturn desc ? -1 : 1;\n\t\t}\n\t\n\t\t// not lt, not gt so implied equality-- date compatible\n\t\treturn 0;\n\t}\n\t\n\t/**\n\t * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n\t *\n\t * @param {array} properties - array of property names, in order, by which to evaluate sort order\n\t * @param {object} obj1 - first object to compare\n\t * @param {object} obj2 - second object to compare\n\t * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n\t */\n\tfunction compoundeval(properties, obj1, obj2) {\n\t\tvar res = 0;\n\t\tvar prop, field;\n\t\tfor (var i = 0, len = properties.length; i < len; i++) {\n\t\t\tprop = properties[i];\n\t\t\tfield = prop[0];\n\t\t\tres = sortHelper(obj1[field], obj2[field], prop[1]);\n\t\t\tif (res !== 0) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\t/**\n\t * dotSubScan - helper function used for dot notation queries.\n\t *\n\t * @param {object} root - object to traverse\n\t * @param {array} paths - array of properties to drill into\n\t * @param {function} fun - evaluation function to test with\n\t * @param {any} value - comparative value to also pass to (compare) fun\n\t * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n\t */\n\tfunction dotSubScan(root, paths, fun, value, poffset) {\n\t\tvar pathOffset = poffset || 0;\n\t\tvar path = paths[pathOffset];\n\t\tif (root === undefined || root === null || !hasOwnProperty.call(root, path)) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar valueFound = false;\n\t\tvar element = root[path];\n\t\tif (pathOffset + 1 >= paths.length) {\n\t\t\t// if we have already expanded out the dot notation,\n\t\t\t// then just evaluate the test function and value on the element\n\t\t\tvalueFound = fun(element, value);\n\t\t} else if (Array.isArray(element)) {\n\t\t\tfor (var index = 0, len = element.length; index < len; index += 1) {\n\t\t\t\tvalueFound = dotSubScan(element[index], paths, fun, value, pathOffset + 1);\n\t\t\t\tif (valueFound === true) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tvalueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);\n\t\t}\n\t\n\t\treturn valueFound;\n\t}\n\t\n\t/*\n\t'Utils' is not defined                 no-undef\tx\n\t'sortHelper' is not defined            no-undef\n\t'compoundeval' is not defined          no-undef\n\t'indexedOpsList' is not defined        no-undef\n\t'LokiOps' is not defined               no-undef\n\t'dotSubScan' is not defined            no-undef\n\t'clone' is not defined                 no-undef\n\t */\n\t\n\t/**\n\t * Resultset class allowing chainable queries.  Intended to be instanced internally.\n\t *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n\t *\n\t * @example\n\t *    mycollection.chain()\n\t *      .find({ 'doors' : 4 })\n\t *      .where(function(obj) { return obj.name === 'Toyota' })\n\t *      .data();\n\t *\n\t * @constructor Resultset\n\t * @param {Collection} collection - The collection which this Resultset will query against.\n\t * @param {Object=} options - Object containing one or more options.\n\t * @param {string} options.queryObj - Optional mongo-style query object to initialize resultset with.\n\t * @param {function} options.queryFunc - Optional javascript filter function to initialize resultset with.\n\t * @param {bool} options.firstOnly - Optional boolean used by collection.findOne().\n\t */\n\tclass Resultset {\n\t\n\t\tconstructor(collection, options) {\n\t\t\toptions = options || {};\n\t\n\t\t\toptions.queryObj = options.queryObj || null;\n\t\t\toptions.queryFunc = options.queryFunc || null;\n\t\t\toptions.firstOnly = options.firstOnly || false;\n\t\n\t\t\t// retain reference to collection we are querying against\n\t\t\tthis.collection = collection;\n\t\n\t\t\t// if chain() instantiates with null queryObj and queryFunc, so we will keep flag for later\n\t\t\tthis.searchIsChained = !options.queryObj && !options.queryFunc;\n\t\t\tthis.filteredrows = [];\n\t\t\tthis.filterInitialized = false;\n\t\n\t\t\t// if user supplied initial queryObj or queryFunc, apply it\n\t\t\tif (typeof options.queryObj !== \"undefined\" && options.queryObj !== null) {\n\t\t\t\treturn this.find(options.queryObj, options.firstOnly);\n\t\t\t}\n\t\t\tif (typeof options.queryFunc !== \"undefined\" && options.queryFunc !== null) {\n\t\t\t\treturn this.where(options.queryFunc);\n\t\t\t}\n\t\n\t\t\t// otherwise return unfiltered Resultset for future filtering\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * reset() - Reset the resultset to its initial state.\n\t  *\n\t  * @returns {Resultset} Reference to this resultset, for future chain operations.\n\t  */\n\t\treset() {\n\t\t\tif (this.filteredrows.length > 0) {\n\t\t\t\tthis.filteredrows = [];\n\t\t\t}\n\t\t\tthis.filterInitialized = false;\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * toJSON() - Override of toJSON to avoid circular references\n\t  *\n\t  */\n\t\ttoJSON() {\n\t\t\tvar copy = this.copy();\n\t\t\tcopy.collection = null;\n\t\t\treturn copy;\n\t\t}\n\t\n\t\t/**\n\t  * Allows you to limit the number of documents passed to next chain operation.\n\t  *    A resultset copy() is made to avoid altering original resultset.\n\t  *\n\t  * @param {int} qty - The number of documents to return.\n\t  * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n\t  * @memberof Resultset\n\t  */\n\t\tlimit(qty) {\n\t\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\n\t\t\tvar rscopy = new Resultset(this.collection);\n\t\t\trscopy.filteredrows = this.filteredrows.slice(0, qty);\n\t\t\trscopy.filterInitialized = true;\n\t\t\treturn rscopy;\n\t\t}\n\t\n\t\t/**\n\t  * Used for skipping 'pos' number of documents in the resultset.\n\t  *\n\t  * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n\t  * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n\t  * @memberof Resultset\n\t  */\n\t\toffset(pos) {\n\t\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\n\t\t\tvar rscopy = new Resultset(this.collection);\n\t\t\trscopy.filteredrows = this.filteredrows.slice(pos);\n\t\t\trscopy.filterInitialized = true;\n\t\t\treturn rscopy;\n\t\t}\n\t\n\t\t/**\n\t  * copy() - To support reuse of resultset in branched query situations.\n\t  *\n\t  * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n\t  * @memberof Resultset\n\t  */\n\t\tcopy() {\n\t\t\tvar result = new Resultset(this.collection);\n\t\n\t\t\tif (this.filteredrows.length > 0) {\n\t\t\t\tresult.filteredrows = this.filteredrows.slice();\n\t\t\t}\n\t\t\tresult.filterInitialized = this.filterInitialized;\n\t\n\t\t\treturn result;\n\t\t}\n\t\n\t\t/**\n\t  * Alias of copy()\n\t  * @memberof Resultset\n\t  */\n\t\tbranch() {\n\t\t\treturn this.copy();\n\t\t}\n\t\n\t\t/**\n\t  * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n\t  *\n\t  * @param transform {(string|array)} - name of collection transform or raw transform array\n\t  * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n\t  * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n\t  * @memberof Resultset\n\t  */\n\t\ttransform(transform, parameters) {\n\t\t\tvar idx,\n\t\t\t    step,\n\t\t\t    rs = this;\n\t\n\t\t\t// if transform is name, then do lookup first\n\t\t\tif (typeof transform === 'string') {\n\t\t\t\tif (this.collection.transforms.hasOwnProperty(transform)) {\n\t\t\t\t\ttransform = this.collection.transforms[transform];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// either they passed in raw transform array or we looked it up, so process\n\t\t\tif (typeof transform !== 'object' || !Array.isArray(transform)) {\n\t\t\t\tthrow new Error(\"Invalid transform\");\n\t\t\t}\n\t\n\t\t\tif (typeof parameters !== 'undefined') {\n\t\t\t\ttransform = _utils.Utils.resolveTransformParams(transform, parameters);\n\t\t\t}\n\t\n\t\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\t\tstep = transform[idx];\n\t\n\t\t\t\tswitch (step.type) {\n\t\t\t\t\tcase \"find\":\n\t\t\t\t\t\trs.find(step.value);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"where\":\n\t\t\t\t\t\trs.where(step.value);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"simplesort\":\n\t\t\t\t\t\trs.simplesort(step.property, step.desc);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"compoundsort\":\n\t\t\t\t\t\trs.compoundsort(step.value);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"sort\":\n\t\t\t\t\t\trs.sort(step.value);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"limit\":\n\t\t\t\t\t\trs = rs.limit(step.value);\n\t\t\t\t\t\tbreak; // limit makes copy so update reference\n\t\t\t\t\tcase \"offset\":\n\t\t\t\t\t\trs = rs.offset(step.value);\n\t\t\t\t\t\tbreak; // offset makes copy so update reference\n\t\t\t\t\tcase \"map\":\n\t\t\t\t\t\trs = rs.map(step.value);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"eqJoin\":\n\t\t\t\t\t\trs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// following cases break chain by returning array data so make any of these last in transform steps\n\t\t\t\t\tcase \"mapReduce\":\n\t\t\t\t\t\trs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t// following cases update documents in current filtered resultset (use carefully)\n\t\t\t\t\tcase \"update\":\n\t\t\t\t\t\trs.update(step.value);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"remove\":\n\t\t\t\t\t\trs.remove();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn rs;\n\t\t}\n\t\n\t\t/**\n\t  * Instances a new anonymous collection with the documents contained in the current resultset.\n\t  *\n\t  * @param {object} collectionOptions - Options to pass to new anonymous collection construction.\n\t  * @returns {Collection} A reference to an anonymous collection initialized with resultset data().\n\t  * @memberof Resultset\n\t  */\n\t\tinstance(collectionOptions) {\n\t\t\tvar docs = this.data();\n\t\t\tvar idx, doc;\n\t\n\t\t\tcollectionOptions = collectionOptions || {};\n\t\n\t\t\tvar instanceCollection = new _collection.Collection(collectionOptions);\n\t\n\t\t\tfor (idx = 0; idx < docs.length; idx++) {\n\t\t\t\tif (this.collection.cloneObjects) {\n\t\t\t\t\tdoc = docs[idx];\n\t\t\t\t} else {\n\t\t\t\t\tdoc = (0, _clone.clone)(docs[idx], this.collection.cloneMethod);\n\t\t\t\t}\n\t\n\t\t\t\tdelete doc.$loki;\n\t\t\t\tdelete doc.meta;\n\t\n\t\t\t\tinstanceCollection.insert(doc);\n\t\t\t}\n\t\n\t\t\treturn instanceCollection;\n\t\t}\n\t\n\t\t/**\n\t  * User supplied compare function is provided two documents to compare. (chainable)\n\t  * @example\n\t  *    rslt.sort(function(obj1, obj2) {\n\t  *      if (obj1.name === obj2.name) return 0;\n\t  *      if (obj1.name > obj2.name) return 1;\n\t  *      if (obj1.name < obj2.name) return -1;\n\t  *    });\n\t  *\n\t  * @param {function} comparefun - A javascript compare function used for sorting.\n\t  * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t  * @memberof Resultset\n\t  */\n\t\tsort(comparefun) {\n\t\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\n\t\t\tvar wrappedComparer = function (userComparer, data) {\n\t\t\t\treturn function (a, b) {\n\t\t\t\t\treturn userComparer(data[a], data[b]);\n\t\t\t\t};\n\t\t\t}(comparefun, this.collection.data);\n\t\n\t\t\tthis.filteredrows.sort(wrappedComparer);\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n\t  *    Sorting based on the same lt/gt helper functions used for binary indices.\n\t  *\n\t  * @param {string} propname - name of property to sort by.\n\t  * @param {bool=} isdesc - (Optional) If true, the property will be sorted in descending order\n\t  * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t  * @memberof Resultset\n\t  */\n\t\tsimplesort(propname, isdesc) {\n\t\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t\t// if we have a binary index and no other filters applied, we can use that instead of sorting (again)\n\t\t\t\tif (this.collection.binaryIndices.hasOwnProperty(propname)) {\n\t\t\t\t\t// make sure index is up-to-date\n\t\t\t\t\tthis.collection.ensureIndex(propname);\n\t\t\t\t\t// copy index values into filteredrows\n\t\t\t\t\tthis.filteredrows = this.collection.binaryIndices[propname].values.slice(0);\n\t\t\t\t\t// we are done, return this (resultset) for further chain ops\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\t// otherwise initialize array for sort below\n\t\t\t\telse {\n\t\t\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (typeof isdesc === 'undefined') {\n\t\t\t\tisdesc = false;\n\t\t\t}\n\t\n\t\t\tvar wrappedComparer = function (prop, desc, data) {\n\t\t\t\treturn function (a, b) {\n\t\t\t\t\treturn sortHelper(data[a][prop], data[b][prop], desc);\n\t\t\t\t};\n\t\t\t}(propname, isdesc, this.collection.data);\n\t\n\t\t\tthis.filteredrows.sort(wrappedComparer);\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * Allows sorting a resultset based on multiple columns.\n\t  * @example\n\t  * // to sort by age and then name (both ascending)\n\t  * rs.compoundsort(['age', 'name']);\n\t  * // to sort by age (ascending) and then by name (descending)\n\t  * rs.compoundsort(['age', ['name', true]);\n\t  *\n\t  * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t  * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t  * @memberof Resultset\n\t  */\n\t\tcompoundsort(properties) {\n\t\t\tif (properties.length === 0) {\n\t\t\t\tthrow new Error(\"Invalid call to compoundsort, need at least one property\");\n\t\t\t}\n\t\n\t\t\tvar prop;\n\t\t\tif (properties.length === 1) {\n\t\t\t\tprop = properties[0];\n\t\t\t\tif (Array.isArray(prop)) {\n\t\t\t\t\treturn this.simplesort(prop[0], prop[1]);\n\t\t\t\t}\n\t\t\t\treturn this.simplesort(prop, false);\n\t\t\t}\n\t\n\t\t\t// unify the structure of 'properties' to avoid checking it repeatedly while sorting\n\t\t\tfor (var i = 0, len = properties.length; i < len; i += 1) {\n\t\t\t\tprop = properties[i];\n\t\t\t\tif (!Array.isArray(prop)) {\n\t\t\t\t\tproperties[i] = [prop, false];\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\n\t\t\tvar wrappedComparer = function (props, data) {\n\t\t\t\treturn function (a, b) {\n\t\t\t\t\treturn compoundeval(props, data[a], data[b]);\n\t\t\t\t};\n\t\t\t}(properties, this.collection.data);\n\t\n\t\t\tthis.filteredrows.sort(wrappedComparer);\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * findOr() - oversee the operation of OR'ed query expressions.\n\t  *    OR'ed expression evaluation runs each expression individually against the full collection,\n\t  *    and finally does a set OR on each expression's results.\n\t  *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n\t  *\n\t  * @param {array} expressionArray - array of expressions\n\t  * @returns {Resultset} this resultset for further chain ops.\n\t  */\n\t\tfindOr(expressionArray) {\n\t\t\tvar fr = null,\n\t\t\t    fri = 0,\n\t\t\t    frlen = 0,\n\t\t\t    docset = [],\n\t\t\t    idxset = [],\n\t\t\t    idx = 0,\n\t\t\t    origCount = this.count();\n\t\n\t\t\t// If filter is already initialized, then we query against only those items already in filter.\n\t\t\t// This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n\t\t\tfor (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n\t\t\t\t// we need to branch existing query to run each filter separately and combine results\n\t\t\t\tfr = this.branch().find(expressionArray[ei]).filteredrows;\n\t\t\t\tfrlen = fr.length;\n\t\t\t\t// if the find operation did not reduce the initial set, then the initial set is the actual result\n\t\t\t\tif (frlen === origCount) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\n\t\t\t\t// add any document 'hits'\n\t\t\t\tfor (fri = 0; fri < frlen; fri++) {\n\t\t\t\t\tidx = fr[fri];\n\t\t\t\t\tif (idxset[idx] === undefined) {\n\t\t\t\t\t\tidxset[idx] = true;\n\t\t\t\t\t\tdocset.push(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis.filteredrows = docset;\n\t\t\tthis.filterInitialized = true;\n\t\n\t\t\treturn this;\n\t\t}\n\t\t$or() {\n\t\t\treturn this.findOr(...arguments);\n\t\t}\n\t\n\t\t/**\n\t  * findAnd() - oversee the operation of AND'ed query expressions.\n\t  *    AND'ed expression evaluation runs each expression progressively against the full collection,\n\t  *    internally utilizing existing chained resultset functionality.\n\t  *    Only the first filter can utilize a binary index.\n\t  *\n\t  * @param {array} expressionArray - array of expressions\n\t  * @returns {Resultset} this resultset for further chain ops.\n\t  */\n\t\tfindAnd(expressionArray) {\n\t\t\t// we have already implementing method chaining in this (our Resultset class)\n\t\t\t// so lets just progressively apply user supplied and filters\n\t\t\tfor (var i = 0, len = expressionArray.length; i < len; i++) {\n\t\t\t\tif (this.count() === 0) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\tthis.find(expressionArray[i]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\n\t\t$and() {\n\t\t\treturn this.findAnd(...arguments);\n\t\t}\n\t\n\t\t/**\n\t  * Used for querying via a mongo-style query object.\n\t  *\n\t  * @param {object} query - A mongo-style query object used for filtering current results.\n\t  * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n\t  * @returns {Resultset} this resultset for further chain ops.\n\t  * @memberof Resultset\n\t  */\n\t\tfind(query, firstOnly) {\n\t\t\tif (this.collection.data.length === 0) {\n\t\t\t\tif (this.searchIsChained) {\n\t\t\t\t\tthis.filteredrows = [];\n\t\t\t\t\tthis.filterInitialized = true;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\treturn [];\n\t\t\t}\n\t\n\t\t\tvar queryObject = query || 'getAll',\n\t\t\t    p,\n\t\t\t    property,\n\t\t\t    queryObjectOp,\n\t\t\t    operator,\n\t\t\t    value,\n\t\t\t    key,\n\t\t\t    searchByIndex = false,\n\t\t\t    result = [],\n\t\t\t    index = null;\n\t\n\t\t\t// if this was note invoked via findOne()\n\t\t\tfirstOnly = firstOnly || false;\n\t\n\t\t\tif (typeof queryObject === 'object') {\n\t\t\t\tfor (p in queryObject) {\n\t\t\t\t\tif (hasOwnProperty.call(queryObject, p)) {\n\t\t\t\t\t\tproperty = p;\n\t\t\t\t\t\tqueryObjectOp = queryObject[p];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// apply no filters if they want all\n\t\t\tif (!property || queryObject === 'getAll') {\n\t\t\t\t// coll.find(), coll.findOne(), coll.chain().find().data() all path here\n\t\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\treturn this.collection.data.length > 0 ? this.collection.data[0] : null;\n\t\t\t\t}\n\t\n\t\t\t\treturn this.searchIsChained ? this : this.collection.data.slice();\n\t\t\t}\n\t\n\t\t\t// injecting $and and $or expression tree evaluation here.\n\t\t\tif (property === '$and' || property === '$or') {\n\t\t\t\tif (this.searchIsChained) {\n\t\t\t\t\tthis[property](queryObjectOp);\n\t\n\t\t\t\t\t// for chained find with firstonly,\n\t\t\t\t\tif (firstOnly && this.filteredrows.length > 1) {\n\t\t\t\t\t\tthis.filteredrows = this.filteredrows.slice(0, 1);\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn this;\n\t\t\t\t} else {\n\t\t\t\t\t// our $and operation internally chains filters\n\t\t\t\t\tresult = this.collection.chain()[property](queryObjectOp).data();\n\t\n\t\t\t\t\t// if this was coll.findOne() return first object or empty array if null\n\t\t\t\t\t// since this is invoked from a constructor we can't return null, so we will\n\t\t\t\t\t// make null in coll.findOne();\n\t\t\t\t\tif (firstOnly) {\n\t\t\t\t\t\treturn result.length === 0 ? [] : result[0];\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// not first only return all results\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// see if query object is in shorthand mode (assuming eq operator)\n\t\t\tif (queryObjectOp === null || typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date) {\n\t\t\t\toperator = '$eq';\n\t\t\t\tvalue = queryObjectOp;\n\t\t\t} else if (typeof queryObjectOp === 'object') {\n\t\t\t\tfor (key in queryObjectOp) {\n\t\t\t\t\tif (hasOwnProperty.call(queryObjectOp, key)) {\n\t\t\t\t\t\toperator = key;\n\t\t\t\t\t\tvalue = queryObjectOp[key];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Do not know what you want to do.');\n\t\t\t}\n\t\n\t\t\t// for regex ops, precompile\n\t\t\tif (operator === '$regex') {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tvalue = new RegExp(value[0], value[1]);\n\t\t\t\t} else if (!(value instanceof RegExp)) {\n\t\t\t\t\tvalue = new RegExp(value);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// if user is deep querying the object such as find('name.first': 'odin')\n\t\t\tvar usingDotNotation = property.indexOf('.') !== -1;\n\t\n\t\t\t// if an index exists for the property being queried against, use it\n\t\t\t// for now only enabling for non-chained query (who's set of docs matches index)\n\t\t\t// or chained queries where it is the first filter applied and prop is indexed\n\t\t\tvar doIndexCheck = !usingDotNotation && (!this.searchIsChained || !this.filterInitialized);\n\t\n\t\t\tif (doIndexCheck && this.collection.binaryIndices[property] && indexedOpsList.indexOf(operator) !== -1) {\n\t\t\t\t// this is where our lazy index rebuilding will take place\n\t\t\t\t// basically we will leave all indexes dirty until we need them\n\t\t\t\t// so here we will rebuild only the index tied to this property\n\t\t\t\t// ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n\t\t\t\tif (this.collection.adaptiveBinaryIndices !== true) {\n\t\t\t\t\tthis.collection.ensureIndex(property);\n\t\t\t\t}\n\t\n\t\t\t\tsearchByIndex = true;\n\t\t\t\tindex = this.collection.binaryIndices[property];\n\t\t\t}\n\t\n\t\t\t// the comparison function\n\t\t\tvar fun = LokiOps[operator];\n\t\n\t\t\t// \"shortcut\" for collection data\n\t\t\tvar t = this.collection.data;\n\t\t\t// filter data length\n\t\t\tvar i = 0,\n\t\t\t    len = 0;\n\t\n\t\t\t// Query executed differently depending on :\n\t\t\t//    - whether it is chained or not\n\t\t\t//    - whether the property being queried has an index defined\n\t\t\t//    - if chained, we handle first pass differently for initial filteredrows[] population\n\t\t\t//\n\t\t\t// For performance reasons, each case has its own if block to minimize in-loop calculations\n\t\n\t\t\t// If not a chained query, bypass filteredrows and work directly against data\n\t\t\tif (!this.searchIsChained) {\n\t\t\t\tif (!searchByIndex) {\n\t\t\t\t\ti = t.length;\n\t\n\t\t\t\t\tif (firstOnly) {\n\t\t\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\t\t\treturn t[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\t\t\treturn t[i];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// if using dot notation then treat property as keypath such as 'name.first'.\n\t\t\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// searching by binary index via calculateRange() utility method\n\t\t\t\t\tvar seg = this.collection.calculateRange(operator, property, value);\n\t\n\t\t\t\t\t// not chained so this 'find' was designated in Resultset constructor\n\t\t\t\t\t// so return object itself\n\t\t\t\t\tif (firstOnly) {\n\t\t\t\t\t\tif (seg[1] !== -1) {\n\t\t\t\t\t\t\treturn t[index.values[seg[0]]];\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn [];\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\t\tfor (i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\t\tresult.push(t[index.values[i]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0, len = seg.length; i < len; i++) {\n\t\t\t\t\t\t\tresult.push(t[index.values[seg[i]]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// not a chained query so return result as data[]\n\t\t\t\treturn result;\n\t\t\t}\n\t\n\t\t\t// Otherwise this is a chained query\n\t\t\t// Chained queries now preserve results ordering at expense on slightly reduced unindexed performance\n\t\n\t\t\tvar filter,\n\t\t\t    rowIdx = 0;\n\t\n\t\t\t// If the filteredrows[] is already initialized, use it\n\t\t\tif (this.filterInitialized) {\n\t\t\t\tfilter = this.filteredrows;\n\t\t\t\tlen = filter.length;\n\t\n\t\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\t\tif (dotSubScan(t[rowIdx], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\t\tif (fun(t[rowIdx][property], value)) {\n\t\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// first chained query so work against data[] but put results in filteredrows\n\t\t\telse {\n\t\t\t\t\t// if not searching by index\n\t\t\t\t\tif (!searchByIndex) {\n\t\t\t\t\t\tlen = t.length;\n\t\n\t\t\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// search by index\n\t\t\t\t\t\tvar segm = this.collection.calculateRange(operator, property, value);\n\t\n\t\t\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\t\t\tfor (i = segm[0]; i <= segm[1]; i++) {\n\t\t\t\t\t\t\t\tresult.push(index.values[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (i = 0, len = segm.length; i < len; i++) {\n\t\t\t\t\t\t\t\tresult.push(index.values[segm[i]]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tthis.filterInitialized = true; // next time work against filteredrows[]\n\t\t\t\t}\n\t\n\t\t\tthis.filteredrows = result;\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * where() - Used for filtering via a javascript filter function.\n\t  *\n\t  * @param {function} fun - A javascript function used for filtering current results by.\n\t  * @returns {Resultset} this resultset for further chain ops.\n\t  * @memberof Resultset\n\t  */\n\t\twhere(fun) {\n\t\t\tvar viewFunction,\n\t\t\t    result = [];\n\t\n\t\t\tif ('function' === typeof fun) {\n\t\t\t\tviewFunction = fun;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Argument is not a stored view or a function');\n\t\t\t}\n\t\t\ttry {\n\t\t\t\t// if not a chained query then run directly against data[] and return object []\n\t\t\t\tif (!this.searchIsChained) {\n\t\t\t\t\tvar i = this.collection.data.length;\n\t\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (viewFunction(this.collection.data[i]) === true) {\n\t\t\t\t\t\t\tresult.push(this.collection.data[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// not a chained query so returning result as data[]\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t// else chained query, so run against filteredrows\n\t\t\t\telse {\n\t\t\t\t\t\t// If the filteredrows[] is already initialized, use it\n\t\t\t\t\t\tif (this.filterInitialized) {\n\t\t\t\t\t\t\tvar j = this.filteredrows.length;\n\t\n\t\t\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\t\t\tif (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n\t\t\t\t\t\t\t\t\tresult.push(this.filteredrows[j]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\tthis.filteredrows = result;\n\t\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise this is initial chained op, work against data, push into filteredrows[]\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tvar k = this.collection.data.length;\n\t\n\t\t\t\t\t\t\t\twhile (k--) {\n\t\t\t\t\t\t\t\t\tif (viewFunction(this.collection.data[k]) === true) {\n\t\t\t\t\t\t\t\t\t\tresult.push(k);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\t\t\t\tthis.filterInitialized = true;\n\t\n\t\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t} catch (err) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * count() - returns the number of documents in the resultset.\n\t  *\n\t  * @returns {number} The number of documents in the resultset.\n\t  * @memberof Resultset\n\t  */\n\t\tcount() {\n\t\t\tif (this.searchIsChained && this.filterInitialized) {\n\t\t\t\treturn this.filteredrows.length;\n\t\t\t}\n\t\t\treturn this.collection.count();\n\t\t}\n\t\n\t\t/**\n\t  * Terminates the chain and returns array of filtered documents\n\t  *\n\t  * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n\t  * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n\t  *        the collection is not configured for clone object.\n\t  * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n\t  *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'\n\t  *\n\t  * @returns {array} Array of documents in the resultset\n\t  * @memberof Resultset\n\t  */\n\t\tdata(options) {\n\t\t\tvar result = [],\n\t\t\t    data = this.collection.data,\n\t\t\t    len,\n\t\t\t    i,\n\t\t\t    method;\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\t// if this is chained resultset with no filters applied, just return collection.data\n\t\t\tif (this.searchIsChained && !this.filterInitialized) {\n\t\t\t\tif (this.filteredrows.length === 0) {\n\t\t\t\t\t// determine whether we need to clone objects or not\n\t\t\t\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\t\t\t\tlen = data.length;\n\t\t\t\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\t\n\t\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\t\tresult.push((0, _clone.clone)(data[i], method));\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\t// otherwise we are not cloning so return sliced array with same object references\n\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn data.slice();\n\t\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// filteredrows must have been set manually, so use it\n\t\t\t\t\tthis.filterInitialized = true;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar fr = this.filteredrows;\n\t\t\tlen = fr.length;\n\t\n\t\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tresult.push((0, _clone.clone)(data[fr[i]], method));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\tresult.push(data[fr[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\n\t\t/**\n\t  * Used to run an update operation on all documents currently in the resultset.\n\t  *\n\t  * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n\t  * @returns {Resultset} this resultset for further chain ops.\n\t  * @memberof Resultset\n\t  */\n\t\tupdate(updateFunction) {\n\t\n\t\t\tif (typeof updateFunction !== \"function\") {\n\t\t\t\tthrow new TypeError('Argument is not a function');\n\t\t\t}\n\t\n\t\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\n\t\t\tvar len = this.filteredrows.length,\n\t\t\t    rcd = this.collection.data;\n\t\n\t\t\tfor (var idx = 0; idx < len; idx++) {\n\t\t\t\t// pass in each document object currently in resultset to user supplied updateFunction\n\t\t\t\tupdateFunction(rcd[this.filteredrows[idx]]);\n\t\n\t\t\t\t// notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate\n\t\t\t\tthis.collection.update(rcd[this.filteredrows[idx]]);\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * Removes all document objects which are currently in resultset from collection (as well as resultset)\n\t  *\n\t  * @returns {Resultset} this (empty) resultset for further chain ops.\n\t  * @memberof Resultset\n\t  */\n\t\tremove() {\n\t\n\t\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\n\t\t\tthis.collection.remove(this.data());\n\t\n\t\t\tthis.filteredrows = [];\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * data transformation via user supplied functions\n\t  *\n\t  * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t  * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t  * @returns {value} The output of your reduceFunction\n\t  * @memberof Resultset\n\t  */\n\t\tmapReduce(mapFunction, reduceFunction) {\n\t\t\ttry {\n\t\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t\t} catch (err) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n\t  * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n\t  * @param {Array} joinData - Data array to join to.\n\t  * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n\t  * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n\t  * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n\t  * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n\t  * @memberof Resultset\n\t  */\n\t\teqJoin(joinData, leftJoinKey, rightJoinKey, mapFun) {\n\t\n\t\t\tvar leftData = [],\n\t\t\t    leftDataLength,\n\t\t\t    rightData = [],\n\t\t\t    rightDataLength,\n\t\t\t    key,\n\t\t\t    result = [],\n\t\t\t    leftKeyisFunction = typeof leftJoinKey === 'function',\n\t\t\t    rightKeyisFunction = typeof rightJoinKey === 'function',\n\t\t\t    joinMap = {};\n\t\n\t\t\t//get the left data\n\t\t\tleftData = this.data();\n\t\t\tleftDataLength = leftData.length;\n\t\n\t\t\t//get the right data\n\t\t\tif (joinData instanceof Resultset) {\n\t\t\t\trightData = joinData.data();\n\t\t\t} else if (Array.isArray(joinData)) {\n\t\t\t\trightData = joinData;\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('joinData needs to be an array or result set');\n\t\t\t}\n\t\t\trightDataLength = rightData.length;\n\t\n\t\t\t//construct a lookup table\n\t\n\t\t\tfor (var i = 0; i < rightDataLength; i++) {\n\t\t\t\tkey = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n\t\t\t\tjoinMap[key] = rightData[i];\n\t\t\t}\n\t\n\t\t\tif (!mapFun) {\n\t\t\t\tmapFun = function (left, right) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tleft: left,\n\t\t\t\t\t\tright: right\n\t\t\t\t\t};\n\t\t\t\t};\n\t\t\t}\n\t\n\t\t\t//Run map function over each object in the resultset\n\t\t\tfor (var j = 0; j < leftDataLength; j++) {\n\t\t\t\tkey = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n\t\t\t\tresult.push(mapFun(leftData[j], joinMap[key] || {}));\n\t\t\t}\n\t\n\t\t\t//return return a new resultset with no filters\n\t\t\tthis.collection = new _collection.Collection('joinData');\n\t\t\tthis.collection.insert(result);\n\t\t\tthis.filteredrows = [];\n\t\t\tthis.filterInitialized = false;\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\tmap(mapFun) {\n\t\t\tvar data = this.data().map(mapFun);\n\t\t\t//return return a new resultset with no filters\n\t\t\tthis.collection = new _collection.Collection('mappedData');\n\t\t\tthis.collection.insert(data);\n\t\t\tthis.filteredrows = [];\n\t\t\tthis.filterInitialized = false;\n\t\n\t\t\treturn this;\n\t\t}\n\t}\n\texports.Resultset = Resultset;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.clone = clone;\n\texports.cloneObjectArray = cloneObjectArray;\n\tfunction clone(data, method) {\n\t\tif (data === null || data === undefined) {\n\t\t\treturn null;\n\t\t}\n\t\n\t\tvar cloneMethod = method || 'parse-stringify',\n\t\t    cloned;\n\t\n\t\tswitch (cloneMethod) {\n\t\t\tcase \"parse-stringify\":\n\t\t\t\tcloned = JSON.parse(JSON.stringify(data));\n\t\t\t\tbreak;\n\t\t\tcase \"jquery-extend-deep\":\n\t\t\t\tcloned = jQuery.extend(true, {}, data);\n\t\t\t\tbreak;\n\t\t\tcase \"shallow\":\n\t\t\t\tcloned = Object.create(data.prototype || null);\n\t\t\t\tObject.keys(data).map(function (i) {\n\t\t\t\t\tcloned[i] = data[i];\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t\n\t\treturn cloned;\n\t}\n\t\n\tfunction cloneObjectArray(objarray, method) {\n\t\tvar i,\n\t\t    result = [];\n\t\n\t\tif (method == \"parse-stringify\") {\n\t\t\treturn clone(objarray, method);\n\t\t}\n\t\n\t\ti = objarray.length - 1;\n\t\n\t\tfor (; i <= 0; i--) {\n\t\t\tresult.push(clone(objarray[i], method));\n\t\t}\n\t\n\t\treturn result;\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t/**\n\t * Created by toni on 1/27/17.\n\t */\n\t\n\tvar Utils = exports.Utils = {\n\t\tcopyProperties: function (src, dest) {\n\t\t\tvar prop;\n\t\t\tfor (prop in src) {\n\t\t\t\tdest[prop] = src[prop];\n\t\t\t}\n\t\t},\n\t\t// used to recursively scan hierarchical transform step object for param substitution\n\t\tresolveTransformObject: function (subObj, params, depth) {\n\t\t\tvar prop, pname;\n\t\n\t\t\tif (typeof depth !== 'number') {\n\t\t\t\tdepth = 0;\n\t\t\t}\n\t\n\t\t\tif (++depth >= 10) return subObj;\n\t\n\t\t\tfor (prop in subObj) {\n\t\t\t\tif (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n\t\t\t\t\tpname = subObj[prop].substring(8);\n\t\t\t\t\tif (params.hasOwnProperty(pname)) {\n\t\t\t\t\t\tsubObj[prop] = params[pname];\n\t\t\t\t\t}\n\t\t\t\t} else if (typeof subObj[prop] === \"object\") {\n\t\t\t\t\tsubObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\treturn subObj;\n\t\t},\n\t\t// top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\n\t\tresolveTransformParams: function (transform, params) {\n\t\t\tvar idx,\n\t\t\t    clonedStep,\n\t\t\t    resolvedTransform = [];\n\t\n\t\t\tif (typeof params === 'undefined') return transform;\n\t\n\t\t\t// iterate all steps in the transform array\n\t\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\t\t// clone transform so our scan and replace can operate directly on cloned transform\n\t\t\t\tclonedStep = JSON.parse(JSON.stringify(transform[idx]));\n\t\t\t\tresolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));\n\t\t\t}\n\t\n\t\t\treturn resolvedTransform;\n\t\t}\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.ltHelper = ltHelper;\n\texports.gtHelper = gtHelper;\n\t/**\n\t * Created by toni on 1/27/17.\n\t */\n\t\n\t/** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n\t *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n\t *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n\t *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n\t */\n\tfunction ltHelper(prop1, prop2, equal) {\n\t\tvar cv1, cv2;\n\t\n\t\t// 'falsy' and Boolean handling\n\t\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\t\tif (equal) {\n\t\t\t\t\treturn prop1 === prop2;\n\t\t\t\t} else {\n\t\t\t\t\tif (prop1) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn prop2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\t\treturn equal;\n\t\t\t}\n\t\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\n\t\tif (prop1 === prop2) {\n\t\t\treturn equal;\n\t\t}\n\t\n\t\tif (prop1 < prop2) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif (prop1 > prop2) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\t\tcv1 = prop1.toString();\n\t\tcv2 = prop2.toString();\n\t\n\t\tif (cv1 == cv2) {\n\t\t\treturn equal;\n\t\t}\n\t\n\t\tif (cv1 < cv2) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\treturn false;\n\t}\n\t\n\tfunction gtHelper(prop1, prop2, equal) {\n\t\tvar cv1, cv2;\n\t\n\t\t// 'falsy' and Boolean handling\n\t\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\t\tif (equal) {\n\t\t\t\t\treturn prop1 === prop2;\n\t\t\t\t} else {\n\t\t\t\t\tif (prop1) {\n\t\t\t\t\t\treturn !prop2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\t\treturn equal;\n\t\t\t}\n\t\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\n\t\tif (prop1 === prop2) {\n\t\t\treturn equal;\n\t\t}\n\t\n\t\tif (prop1 > prop2) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\tif (prop1 < prop2) {\n\t\t\treturn false;\n\t\t}\n\t\n\t\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\t\tcv1 = prop1.toString();\n\t\tcv2 = prop2.toString();\n\t\n\t\tif (cv1 == cv2) {\n\t\t\treturn equal;\n\t\t}\n\t\n\t\tif (cv1 > cv2) {\n\t\t\treturn true;\n\t\t}\n\t\n\t\treturn false;\n\t}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\texports.DynamicView = undefined;\n\t\n\tvar _event_emitter = __webpack_require__(2);\n\t\n\tvar _resultset = __webpack_require__(8);\n\t\n\t/*\n\t'LokiEventEmitter' is not defined        no-undef\n\t'Resultset' is not defined               no-undef\n\t */\n\t\n\t/**\n\t * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n\t *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n\t *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n\t *\n\t * @example\n\t * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n\t * mydv.applyFind({ 'doors' : 4 });\n\t * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n\t * var results = mydv.data();\n\t *\n\t * @constructor DynamicView\n\t * @implements LokiEventEmitter\n\t * @param {Collection} collection - A reference to the collection to work against\n\t * @param {string} name - The name of this dynamic view\n\t * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n\t * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n\t */\n\tclass DynamicView extends _event_emitter.LokiEventEmitter {\n\t\n\t\tconstructor(collection, name, options) {\n\t\t\tsuper();\n\t\t\tthis.collection = collection;\n\t\t\tthis.name = name;\n\t\t\tthis.rebuildPending = false;\n\t\t\tthis.options = options || {};\n\t\n\t\t\tif (!this.options.hasOwnProperty('persistent')) {\n\t\t\t\tthis.options.persistent = false;\n\t\t\t}\n\t\n\t\t\t// 'persistentSortPriority':\n\t\t\t// 'passive' will defer the sort phase until they call data(). (most efficient overall)\n\t\t\t// 'active' will sort async whenever next idle. (prioritizes read speeds)\n\t\t\tif (!this.options.hasOwnProperty('sortPriority')) {\n\t\t\t\tthis.options.sortPriority = 'passive';\n\t\t\t}\n\t\n\t\t\tif (!this.options.hasOwnProperty('minRebuildInterval')) {\n\t\t\t\tthis.options.minRebuildInterval = 1;\n\t\t\t}\n\t\n\t\t\tthis.resultset = new _resultset.Resultset(collection);\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = false;\n\t\n\t\t\tthis.cachedresultset = null;\n\t\n\t\t\t// keep ordered filter pipeline\n\t\t\tthis.filterPipeline = [];\n\t\n\t\t\t// sorting member variables\n\t\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\t\tthis.sortFunction = null;\n\t\t\tthis.sortCriteria = null;\n\t\t\tthis.sortDirty = false;\n\t\n\t\t\t// for now just have 1 event for when we finally rebuilt lazy view\n\t\t\t// once we refactor transactions, i will tie in certain transactional events\n\t\n\t\t\tthis.events = {\n\t\t\t\t'rebuild': []\n\t\t\t};\n\t\t}\n\t\n\t\t/**\n\t  * rematerialize() - intended for use immediately after deserialization (loading)\n\t  *    This will clear out and reapply filterPipeline ops, recreating the view.\n\t  *    Since where filters do not persist correctly, this method allows\n\t  *    restoring the view to state where user can re-apply those where filters.\n\t  *\n\t  * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n\t  * @returns {DynamicView} This dynamic view for further chained ops.\n\t  * @memberof DynamicView\n\t  * @fires DynamicView.rebuild\n\t  */\n\t\trematerialize(options) {\n\t\t\tvar fpl, fpi, idx;\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t\tthis.resultset = new _resultset.Resultset(this.collection);\n\t\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.sortDirty = true;\n\t\t\t}\n\t\n\t\t\tif (options.hasOwnProperty('removeWhereFilters')) {\n\t\t\t\t// for each view see if it had any where filters applied... since they don't\n\t\t\t\t// serialize those functions lets remove those invalid filters\n\t\t\t\tfpl = this.filterPipeline.length;\n\t\t\t\tfpi = fpl;\n\t\t\t\twhile (fpi--) {\n\t\t\t\t\tif (this.filterPipeline[fpi].type === 'where') {\n\t\t\t\t\t\tif (fpi !== this.filterPipeline.length - 1) {\n\t\t\t\t\t\t\tthis.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tthis.filterPipeline.length--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n\t\t\tvar ofp = this.filterPipeline;\n\t\t\tthis.filterPipeline = [];\n\t\n\t\t\t// now re-apply 'find' filterPipeline ops\n\t\t\tfpl = ofp.length;\n\t\t\tfor (idx = 0; idx < fpl; idx++) {\n\t\t\t\tthis.applyFind(ofp[idx].val);\n\t\t\t}\n\t\n\t\t\t// during creation of unit tests, i will remove this forced refresh and leave lazy\n\t\t\tthis.data();\n\t\n\t\t\t// emit rebuild event in case user wants to be notified\n\t\t\tthis.emit('rebuild', this);\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * branchResultset() - Makes a copy of the internal resultset for branched queries.\n\t  *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n\t  *    so your branched query should be immediately resolved and not held for future evaluation.\n\t  *\n\t  * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n\t  * @param {object=} parameters - optional parameters (if optional transform requires them)\n\t  * @returns {Resultset} A copy of the internal resultset for branched queries.\n\t  * @memberof DynamicView\n\t  */\n\t\tbranchResultset(transform, parameters) {\n\t\t\tvar rs = this.resultset.branch();\n\t\n\t\t\tif (typeof transform === 'undefined') {\n\t\t\t\treturn rs;\n\t\t\t}\n\t\n\t\t\treturn rs.transform(transform, parameters);\n\t\t}\n\t\n\t\t/**\n\t  * toJSON() - Override of toJSON to avoid circular references\n\t  *\n\t  */\n\t\ttoJSON() {\n\t\t\tvar copy = new DynamicView(this.collection, this.name, this.options);\n\t\n\t\t\tcopy.resultset = this.resultset;\n\t\t\tcopy.resultdata = []; // let's not save data (copy) to minimize size\n\t\t\tcopy.resultsdirty = true;\n\t\t\tcopy.filterPipeline = this.filterPipeline;\n\t\t\tcopy.sortFunction = this.sortFunction;\n\t\t\tcopy.sortCriteria = this.sortCriteria;\n\t\t\tcopy.sortDirty = this.sortDirty;\n\t\n\t\t\t// avoid circular reference, reapply in db.loadJSON()\n\t\t\tcopy.collection = null;\n\t\n\t\t\treturn copy;\n\t\t}\n\t\n\t\t/**\n\t  * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n\t  *     Existing options should be retained.\n\t  * @param {object=} options - configure removeFilter behavior\n\t  * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n\t  * @memberof DynamicView\n\t  */\n\t\tremoveFilters(options) {\n\t\t\toptions = options || {};\n\t\n\t\t\tthis.rebuildPending = false;\n\t\t\tthis.resultset.reset();\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\n\t\t\tthis.cachedresultset = null;\n\t\n\t\t\t// keep ordered filter pipeline\n\t\t\tthis.filterPipeline = [];\n\t\n\t\t\t// sorting member variables\n\t\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\t\tthis.sortFunction = null;\n\t\t\tthis.sortCriteria = null;\n\t\t\tthis.sortDirty = false;\n\t\n\t\t\tif (options.queueSortPhase === true) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * applySort() - Used to apply a sort to the dynamic view\n\t  * @example\n\t  * dv.applySort(function(obj1, obj2) {\n\t  *   if (obj1.name === obj2.name) return 0;\n\t  *   if (obj1.name > obj2.name) return 1;\n\t  *   if (obj1.name < obj2.name) return -1;\n\t  * });\n\t  *\n\t  * @param {function} comparefun - a javascript compare function used for sorting\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  * @memberof DynamicView\n\t  */\n\t\tapplySort(comparefun) {\n\t\t\tthis.sortFunction = comparefun;\n\t\t\tthis.sortCriteria = null;\n\t\n\t\t\tthis.queueSortPhase();\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * applySimpleSort() - Used to specify a property used for view translation.\n\t  * @example\n\t  * dv.applySimpleSort(\"name\");\n\t  *\n\t  * @param {string} propname - Name of property by which to sort.\n\t  * @param {boolean=} isdesc - (Optional) If true, the sort will be in descending order.\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  * @memberof DynamicView\n\t  */\n\t\tapplySimpleSort(propname, isdesc) {\n\t\t\tthis.sortCriteria = [[propname, isdesc || false]];\n\t\t\tthis.sortFunction = null;\n\t\n\t\t\tthis.queueSortPhase();\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n\t  * @example\n\t  * // to sort by age and then name (both ascending)\n\t  * dv.applySortCriteria(['age', 'name']);\n\t  * // to sort by age (ascending) and then by name (descending)\n\t  * dv.applySortCriteria(['age', ['name', true]);\n\t  * // to sort by age (descending) and then by name (descending)\n\t  * dv.applySortCriteria(['age', true], ['name', true]);\n\t  *\n\t  * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t  * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n\t  * @memberof DynamicView\n\t  */\n\t\tapplySortCriteria(criteria) {\n\t\t\tthis.sortCriteria = criteria;\n\t\t\tthis.sortFunction = null;\n\t\n\t\t\tthis.queueSortPhase();\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * startTransaction() - marks the beginning of a transaction.\n\t  *\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  */\n\t\tstartTransaction() {\n\t\t\tthis.cachedresultset = this.resultset.copy();\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * commit() - commits a transaction.\n\t  *\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  */\n\t\tcommit() {\n\t\t\tthis.cachedresultset = null;\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * rollback() - rolls back a transaction.\n\t  *\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  */\n\t\trollback() {\n\t\t\tthis.resultset = this.cachedresultset;\n\t\n\t\t\tif (this.options.persistent) {\n\t\t\t\t// for now just rebuild the persistent dynamic view data in this worst case scenario\n\t\t\t\t// (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\n\t\t\t\tthis.emit('rebuild', this);\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * Implementation detail.\n\t  * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n\t  *\n\t  * @param {(string|number)} uid - The unique ID of the filter.\n\t  * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n\t  */\n\t\t_indexOfFilterWithId(uid) {\n\t\t\tif (typeof uid === 'string' || typeof uid === 'number') {\n\t\t\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n\t\t\t\t\tif (uid === this.filterPipeline[idx].uid) {\n\t\t\t\t\t\treturn idx;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t\n\t\t/**\n\t  * Implementation detail.\n\t  * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n\t  *\n\t  * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n\t  */\n\t\t_addFilter(filter) {\n\t\t\tthis.filterPipeline.push(filter);\n\t\t\tthis.resultset[filter.type](filter.val);\n\t\t}\n\t\n\t\t/**\n\t  * reapplyFilters() - Reapply all the filters in the current pipeline.\n\t  *\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  */\n\t\treapplyFilters() {\n\t\t\tthis.resultset.reset();\n\t\n\t\t\tthis.cachedresultset = null;\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = [];\n\t\t\t\tthis.resultsdirty = true;\n\t\t\t}\n\t\n\t\t\tvar filters = this.filterPipeline;\n\t\t\tthis.filterPipeline = [];\n\t\n\t\t\tfor (var idx = 0, len = filters.length; idx < len; idx += 1) {\n\t\t\t\tthis._addFilter(filters[idx]);\n\t\t\t}\n\t\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n\t  *\n\t  * @param {object} filter - A filter object to add to the pipeline.\n\t  *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  * @memberof DynamicView\n\t  */\n\t\tapplyFilter(filter) {\n\t\t\tvar idx = this._indexOfFilterWithId(filter.uid);\n\t\t\tif (idx >= 0) {\n\t\t\t\tthis.filterPipeline[idx] = filter;\n\t\t\t\treturn this.reapplyFilters();\n\t\t\t}\n\t\n\t\t\tthis.cachedresultset = null;\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = [];\n\t\t\t\tthis.resultsdirty = true;\n\t\t\t}\n\t\n\t\t\tthis._addFilter(filter);\n\t\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n\t  *\n\t  * @param {object} query - A mongo-style query object to apply to pipeline\n\t  * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  * @memberof DynamicView\n\t  */\n\t\tapplyFind(query, uid) {\n\t\t\tthis.applyFilter({\n\t\t\t\ttype: 'find',\n\t\t\t\tval: query,\n\t\t\t\tuid: uid\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n\t  *\n\t  * @param {function} fun - A javascript filter function to apply to pipeline\n\t  * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  * @memberof DynamicView\n\t  */\n\t\tapplyWhere(fun, uid) {\n\t\t\tthis.applyFilter({\n\t\t\t\ttype: 'where',\n\t\t\t\tval: fun,\n\t\t\t\tuid: uid\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n\t  *\n\t  * @param {(string|number)} uid - The unique ID of the filter to be removed.\n\t  * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t  * @memberof DynamicView\n\t  */\n\t\tremoveFilter(uid) {\n\t\t\tvar idx = this._indexOfFilterWithId(uid);\n\t\t\tif (idx < 0) {\n\t\t\t\tthrow new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n\t\t\t}\n\t\n\t\t\tthis.filterPipeline.splice(idx, 1);\n\t\t\tthis.reapplyFilters();\n\t\t\treturn this;\n\t\t}\n\t\n\t\t/**\n\t  * count() - returns the number of documents representing the current DynamicView contents.\n\t  *\n\t  * @returns {number} The number of documents representing the current DynamicView contents.\n\t  * @memberof DynamicView\n\t  */\n\t\tcount() {\n\t\t\t// in order to be accurate we will pay the minimum cost (and not alter dv state management)\n\t\t\t// recurring resultset data resolutions should know internally its already up to date.\n\t\t\t// for persistent data this will not update resultdata nor fire rebuild event.\n\t\t\tif (this.resultsdirty) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\n\t\t\treturn this.resultset.count();\n\t\t}\n\t\n\t\t/**\n\t  * data() - resolves and pending filtering and sorting, then returns document array as result.\n\t  *\n\t  * @returns {array} An array of documents representing the current DynamicView contents.\n\t  * @memberof DynamicView\n\t  */\n\t\tdata() {\n\t\t\t// using final sort phase as 'catch all' for a few use cases which require full rebuild\n\t\t\tif (this.sortDirty || this.resultsdirty) {\n\t\t\t\tthis.performSortPhase({\n\t\t\t\t\tsuppressRebuildEvent: true\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn this.options.persistent ? this.resultdata : this.resultset.data();\n\t\t}\n\t\n\t\t/**\n\t  * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n\t  *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n\t  */\n\t\tqueueRebuildEvent() {\n\t\t\tif (this.rebuildPending) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.rebuildPending = true;\n\t\n\t\t\tvar self = this;\n\t\t\tsetTimeout(function () {\n\t\t\t\tif (self.rebuildPending) {\n\t\t\t\t\tself.rebuildPending = false;\n\t\t\t\t\tself.emit('rebuild', self);\n\t\t\t\t}\n\t\t\t}, this.options.minRebuildInterval);\n\t\t}\n\t\n\t\t/**\n\t  * queueSortPhase : If the view is sorted we will throttle sorting to either :\n\t  *    (1) passive - when the user calls data(), or\n\t  *    (2) active - once they stop updating and yield js thread control\n\t  */\n\t\tqueueSortPhase() {\n\t\t\t// already queued? exit without queuing again\n\t\t\tif (this.sortDirty) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.sortDirty = true;\n\t\n\t\t\tvar self = this;\n\t\t\tif (this.options.sortPriority === \"active\") {\n\t\t\t\t// active sorting... once they are done and yield js thread, run async performSortPhase()\n\t\t\t\tsetTimeout(function () {\n\t\t\t\t\tself.performSortPhase();\n\t\t\t\t}, this.options.minRebuildInterval);\n\t\t\t} else {\n\t\t\t\t// must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n\t\t\t\t// potentially notify user that data has changed.\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n\t  *\n\t  */\n\t\tperformSortPhase(options) {\n\t\t\t// async call to this may have been pre-empted by synchronous call to data before async could fire\n\t\t\tif (!this.sortDirty && !this.resultsdirty) {\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\toptions = options || {};\n\t\n\t\t\tif (this.sortDirty) {\n\t\t\t\tif (this.sortFunction) {\n\t\t\t\t\tthis.resultset.sort(this.sortFunction);\n\t\t\t\t} else if (this.sortCriteria) {\n\t\t\t\t\tthis.resultset.compoundsort(this.sortCriteria);\n\t\t\t\t}\n\t\n\t\t\t\tthis.sortDirty = false;\n\t\t\t}\n\t\n\t\t\tif (this.options.persistent) {\n\t\t\t\t// persistent view, rebuild local resultdata array\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t\tthis.resultsdirty = false;\n\t\t\t}\n\t\n\t\t\tif (!options.suppressRebuildEvent) {\n\t\t\t\tthis.emit('rebuild', this);\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * evaluateDocument() - internal method for (re)evaluating document inclusion.\n\t  *    Called by : collection.insert() and collection.update().\n\t  *\n\t  * @param {int} objIndex - index of document to (re)run through filter pipeline.\n\t  * @param {bool} isNew - true if the document was just added to the collection.\n\t  */\n\t\tevaluateDocument(objIndex, isNew) {\n\t\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\t\tif (!this.resultset.filterInitialized) {\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t\t}\n\t\t\t\t// need to re-sort to sort new document\n\t\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\t\tthis.queueSortPhase();\n\t\t\t\t} else {\n\t\t\t\t\tthis.queueRebuildEvent();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar ofr = this.resultset.filteredrows;\n\t\t\tvar oldPos = isNew ? -1 : ofr.indexOf(+objIndex);\n\t\t\tvar oldlen = ofr.length;\n\t\n\t\t\t// creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n\t\t\t// mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n\t\t\tvar evalResultset = new _resultset.Resultset(this.collection);\n\t\t\tevalResultset.filteredrows = [objIndex];\n\t\t\tevalResultset.filterInitialized = true;\n\t\t\tvar filter;\n\t\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n\t\t\t\tfilter = this.filterPipeline[idx];\n\t\t\t\tevalResultset[filter.type](filter.val);\n\t\t\t}\n\t\n\t\t\t// not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n\t\t\tvar newPos = evalResultset.filteredrows.length === 0 ? -1 : 0;\n\t\n\t\t\t// wasn't in old, shouldn't be now... do nothing\n\t\t\tif (oldPos === -1 && newPos === -1) return;\n\t\n\t\t\t// wasn't in resultset, should be now... add\n\t\t\tif (oldPos === -1 && newPos !== -1) {\n\t\t\t\tofr.push(objIndex);\n\t\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.push(this.collection.data[objIndex]);\n\t\t\t\t}\n\t\n\t\t\t\t// need to re-sort to sort new document\n\t\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\t\tthis.queueSortPhase();\n\t\t\t\t} else {\n\t\t\t\t\tthis.queueRebuildEvent();\n\t\t\t\t}\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// was in resultset, shouldn't be now... delete\n\t\t\tif (oldPos !== -1 && newPos === -1) {\n\t\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\t\tofr.splice(oldPos, 1);\n\t\n\t\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\t\tthis.resultdata.splice(oldPos, 1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tofr.length = oldlen - 1;\n\t\n\t\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// in case changes to data altered a sort column\n\t\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\t\tthis.queueSortPhase();\n\t\t\t\t} else {\n\t\t\t\t\tthis.queueRebuildEvent();\n\t\t\t\t}\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// was in resultset, should still be now... (update persistent only?)\n\t\t\tif (oldPos !== -1 && newPos !== -1) {\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\t// in case document changed, replace persistent view data with the latest collection.data document\n\t\t\t\t\tthis.resultdata[oldPos] = this.collection.data[objIndex];\n\t\t\t\t}\n\t\n\t\t\t\t// in case changes to data altered a sort column\n\t\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\t\tthis.queueSortPhase();\n\t\t\t\t} else {\n\t\t\t\t\tthis.queueRebuildEvent();\n\t\t\t\t}\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * removeDocument() - internal function called on collection.delete()\n\t  */\n\t\tremoveDocument(objIndex) {\n\t\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\t\tif (!this.resultset.filterInitialized) {\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t\t}\n\t\t\t\t// in case changes to data altered a sort column\n\t\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\t\tthis.queueSortPhase();\n\t\t\t\t} else {\n\t\t\t\t\tthis.queueRebuildEvent();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\tvar ofr = this.resultset.filteredrows;\n\t\t\tvar oldPos = ofr.indexOf(+objIndex);\n\t\t\tvar oldlen = ofr.length;\n\t\t\tvar idx;\n\t\n\t\t\tif (oldPos !== -1) {\n\t\t\t\t// if not last row in resultdata, swap last to hole and truncate last row\n\t\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\t\tofr[oldPos] = ofr[oldlen - 1];\n\t\t\t\t\tofr.length = oldlen - 1;\n\t\n\t\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\t\tthis.resultdata[oldPos] = this.resultdata[oldlen - 1];\n\t\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// last row, so just truncate last row\n\t\t\t\telse {\n\t\t\t\t\t\tofr.length = oldlen - 1;\n\t\n\t\t\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t// in case changes to data altered a sort column\n\t\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\t\tthis.queueSortPhase();\n\t\t\t\t} else {\n\t\t\t\t\tthis.queueRebuildEvent();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// since we are using filteredrows to store data array positions\n\t\t\t// if they remove a document (whether in our view or not),\n\t\t\t// we need to adjust array positions -1 for all document array references after that position\n\t\t\toldlen = ofr.length;\n\t\t\tfor (idx = 0; idx < oldlen; idx++) {\n\t\t\t\tif (ofr[idx] > objIndex) {\n\t\t\t\t\tofr[idx]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * mapReduce() - data transformation via user supplied functions\n\t  *\n\t  * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t  * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t  * @returns The output of your reduceFunction\n\t  * @memberof DynamicView\n\t  */\n\t\tmapReduce(mapFunction, reduceFunction) {\n\t\t\ttry {\n\t\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t\t} catch (err) {\n\t\t\t\tthrow err;\n\t\t\t}\n\t\t}\n\t}\n\texports.DynamicView = DynamicView;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t\tvalue: true\n\t});\n\t/*\n\tLoki IndexedDb Adapter (need to include this script to use it)\n\t\n\tConsole Usage can be used for management/diagnostic, here are a few examples :\n\tadapter.getDatabaseList(); // with no callback passed, this method will log results to console\n\tadapter.saveDatabase(\"UserDatabase\", JSON.stringify(myDb));\n\tadapter.loadDatabase(\"UserDatabase\"); // will log the serialized db to console\n\tadapter.deleteDatabase(\"UserDatabase\");\n\t*/\n\t\n\t/**\n\t * Loki persistence adapter class for indexedDb.\n\t *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n\t *     Utilizes the included LokiCatalog app/key/value database for actual database persistence.\n\t *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n\t *     allow separate contexts for separate apps within a domain.\n\t *\n\t * @example\n\t * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t *\n\t * @constructor LokiIndexedAdapter\n\t *\n\t * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, \"loki\" by default\n\t */\n\tclass LokiIndexedAdapter {\n\t\n\t\tconstructor(appname) {\n\t\t\tthis.app = \"loki\";\n\t\n\t\t\tif (typeof appname !== \"undefined\") {\n\t\t\t\tthis.app = appname;\n\t\t\t}\n\t\n\t\t\t// keep reference to catalog class for base AKV operations\n\t\t\tthis.catalog = null;\n\t\n\t\t\tif (!this.checkAvailability()) {\n\t\t\t\tthrow new Error(\"indexedDB does not seem to be supported for your environment\");\n\t\t\t}\n\t\t}\n\t\n\t\t/**\n\t  * Used to check if adapter is available\n\t  *\n\t  * @returns {boolean} true if indexeddb is available, false if not.\n\t  * @memberof LokiIndexedAdapter\n\t  */\n\t\tcheckAvailability() {\n\t\t\tif (typeof indexedDB !== \"undefined\" && indexedDB) return true;\n\t\n\t\t\treturn false;\n\t\t}\n\t\n\t\t/**\n\t  * Retrieves a serialized db string from the catalog.\n\t  *\n\t  * @example\n\t  * // LOAD\n\t  * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t  * var db = new loki(\"test\", { adapter: idbAdapter });\n\t  *   db.loadDatabase(function(result) {\n\t  *   console.log(\"done\");\n\t  * });\n\t  *\n\t  * @param {string} dbname - the name of the database to retrieve.\n\t  * @returns {Promise} a Promise that resolves after the database was loaded\n\t  * @memberof LokiIndexedAdapter\n\t  */\n\t\tloadDatabase(dbname) {\n\t\t\tvar appName = this.app;\n\t\t\tvar adapter = this;\n\t\n\t\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\tadapter.catalog = new LokiCatalog(function (cat) {\n\t\t\t\t\t\tadapter.catalog = cat;\n\t\n\t\t\t\t\t\tresolve(adapter.loadDatabase(dbname));\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// lookup up db string in AKV db\n\t\t\treturn new Promise(function (resolve) {\n\t\t\t\tthis.catalog.getAppKey(appName, dbname, function (result) {\n\t\t\t\t\tif (result.id === 0) {\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tresolve(result.val);\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\n\t\t// alias\n\t\tloadKey(dbname) {\n\t\t\treturn this.loadDatabase(dbname);\n\t\t}\n\t\n\t\t/**\n\t  * Saves a serialized db to the catalog.\n\t  *\n\t  * @example\n\t  * // SAVE : will save App/Key/Val as \"finance\"/\"test\"/{serializedDb}\n\t  * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t  * var db = new loki(\"test\", { adapter: idbAdapter });\n\t  * var coll = db.addCollection(\"testColl\");\n\t  * coll.insert({test: \"val\"});\n\t  * db.saveDatabase();  // could pass callback if needed for async complete\n\t  *\n\t  * @param {string} dbname - the name to give the serialized database within the catalog.\n\t  * @param {string} dbstring - the serialized db string to save.\n\t  * @returns {Promise} a Promise that resolves after the database was persisted\n\t  * @memberof LokiIndexedAdapter\n\t  */\n\t\tsaveDatabase(dbname, dbstring) {\n\t\t\tvar appName = this.app;\n\t\t\tvar adapter = this;\n\t\n\t\t\tvar resolve, reject;\n\t\t\tvar result = new Promise(function (res, rej) {\n\t\t\t\tresolve = res;\n\t\t\t\treject = rej;\n\t\t\t});\n\t\n\t\t\tfunction saveCallback(result) {\n\t\t\t\tif (result && result.success === true) {\n\t\t\t\t\tresolve();\n\t\t\t\t} else {\n\t\t\t\t\treject(new Error(\"Error saving database\"));\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\t\tthis.catalog = new LokiCatalog(function (cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\t\n\t\t\t\t\t// now that catalog has been initialized, set (add/update) the AKV entry\n\t\t\t\t\tcat.setAppKey(appName, dbname, dbstring, saveCallback);\n\t\t\t\t});\n\t\n\t\t\t\treturn result;\n\t\t\t}\n\t\n\t\t\t// set (add/update) entry to AKV database\n\t\t\tthis.catalog.setAppKey(appName, dbname, dbstring, saveCallback);\n\t\n\t\t\treturn result;\n\t\t}\n\t\n\t\t// alias\n\t\tsaveKey(dbname, dbstring) {\n\t\t\treturn this.saveDatabase(dbname, dbstring);\n\t\t}\n\t\n\t\t/**\n\t  * Deletes a serialized db from the catalog.\n\t  *\n\t  * @example\n\t  * // DELETE DATABASE\n\t  * // delete \"finance\"/\"test\" value from catalog\n\t  * idbAdapter.deleteDatabase(\"test\", function {\n\t  *   // database deleted\n\t  * });\n\t  *\n\t  * @param {string} dbname - the name of the database to delete from the catalog.\n\t  * @returns {Promise} a Promise that resolves after the database was deleted\n\t  * @memberof LokiIndexedAdapter\n\t  */\n\t\tdeleteDatabase(dbname) {\n\t\t\tvar appName = this.app;\n\t\t\tvar adapter = this;\n\t\n\t\t\t// lazy open/create db reference and pass callback ahead\n\t\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\t\treturn new Promise(function (resolve) {\n\t\t\t\t\tadapter.catalog = new LokiCatalog(function (cat) {\n\t\t\t\t\t\tadapter.catalog = cat;\n\t\n\t\t\t\t\t\tresolve(adapter.deleteDatabase(dbname));\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\t// catalog was already initialized, so just lookup object and delete by id\n\t\t\treturn new Promise(function (resolve) {\n\t\t\t\tthis.catalog.getAppKey(appName, dbname, function (result) {\n\t\t\t\t\tvar id = result.id;\n\t\n\t\t\t\t\tif (id !== 0) {\n\t\t\t\t\t\tadapter.catalog.deleteAppKey(id);\n\t\t\t\t\t}\n\t\n\t\t\t\t\tresolve();\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\n\t\t// alias\n\t\tdeleteKey(dbname) {\n\t\t\treturn this.deleteDatabase(dbname);\n\t\t}\n\t\n\t\t/**\n\t  * Removes all database partitions and pages with the base filename passed in.\n\t  * This utility method does not (yet) guarantee async deletions will be completed before returning\n\t  *\n\t  * @param {string} dbname - the base filename which container, partitions, or pages are derived\n\t  * @memberof LokiIndexedAdapter\n\t  */\n\t\tdeleteDatabasePartitions(dbname) {\n\t\t\tvar self = this;\n\t\t\tthis.getDatabaseList(function (result) {\n\t\t\t\tresult.forEach(function (str) {\n\t\t\t\t\tif (str.startsWith(dbname)) {\n\t\t\t\t\t\tself.deleteDatabase(str);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\n\t\t/**\n\t  * Retrieves object array of catalog entries for current app.\n\t  *\n\t  * @example\n\t  * idbAdapter.getDatabaseList(function(result) {\n\t  *   // result is array of string names for that appcontext (\"finance\")\n\t  *   result.forEach(function(str) {\n\t  *     console.log(str);\n\t  *   });\n\t  * });\n\t  *\n\t  * @param {function} callback - should accept array of database names in the catalog for current app.\n\t  * @memberof LokiIndexedAdapter\n\t  */\n\t\tgetDatabaseList(callback) {\n\t\t\tvar appName = this.app;\n\t\t\tvar adapter = this;\n\t\n\t\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\t\tthis.catalog = new LokiCatalog(function (cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\t\n\t\t\t\t\tadapter.getDatabaseList(callback);\n\t\t\t\t});\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// catalog already initialized\n\t\t\t// get all keys for current appName, and transpose results so just string array\n\t\t\tthis.catalog.getAppKeys(appName, function (results) {\n\t\t\t\tvar names = [];\n\t\n\t\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\t\tnames.push(results[idx].key);\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\tcallback(names);\n\t\t\t\t} else {\n\t\t\t\t\tnames.forEach(function (obj) {\n\t\t\t\t\t\tconsole.log(obj);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\n\t\t// alias\n\t\tgetKeyList(callback) {\n\t\t\treturn this.getDatabaseList(callback);\n\t\t}\n\t\n\t\t/**\n\t  * Allows retrieval of list of all keys in catalog along with size\n\t  *\n\t  * @param {function} callback - (Optional) callback to accept result array.\n\t  * @memberof LokiIndexedAdapter\n\t  */\n\t\tgetCatalogSummary(callback) {\n\t\t\tvar appName = this.app;\n\t\t\tvar adapter = this;\n\t\n\t\t\t// lazy open/create db reference\n\t\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\t\tthis.catalog = new LokiCatalog(function (cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\t\n\t\t\t\t\tadapter.getCatalogSummary(callback);\n\t\t\t\t});\n\t\n\t\t\t\treturn;\n\t\t\t}\n\t\n\t\t\t// catalog already initialized\n\t\t\t// get all keys for current appName, and transpose results so just string array\n\t\t\tthis.catalog.getAllKeys(function (results) {\n\t\t\t\tvar entries = [];\n\t\t\t\tvar obj, size, oapp, okey, oval;\n\t\n\t\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\t\tobj = results[idx];\n\t\t\t\t\toapp = obj.app || '';\n\t\t\t\t\tokey = obj.key || '';\n\t\t\t\t\toval = obj.val || '';\n\t\n\t\t\t\t\t// app and key are composited into an appkey column so we will mult by 2\n\t\t\t\t\tsize = oapp.length * 2 + okey.length * 2 + oval.length + 1;\n\t\n\t\t\t\t\tentries.push({\n\t\t\t\t\t\t\"app\": obj.app,\n\t\t\t\t\t\t\"key\": obj.key,\n\t\t\t\t\t\t\"size\": size\n\t\t\t\t\t});\n\t\t\t\t}\n\t\n\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\tcallback(entries);\n\t\t\t\t} else {\n\t\t\t\t\tentries.forEach(function (obj) {\n\t\t\t\t\t\tconsole.log(obj);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\t\n\texports.LokiIndexedAdapter = LokiIndexedAdapter; /**\n\t                                                  * LokiCatalog - underlying App/Key/Value catalog persistence\n\t                                                  *    This non-interface class implements the actual persistence.\n\t                                                  *    Used by the IndexedAdapter class.\n\t                                                  */\n\t\n\tclass LokiCatalog {\n\t\tconstructor(callback) {\n\t\t\tthis.db = null;\n\t\t\tthis.initializeLokiCatalog(callback);\n\t\t}\n\t\n\t\tinitializeLokiCatalog(callback) {\n\t\t\tvar openRequest = indexedDB.open(\"LokiCatalog\", 1);\n\t\t\tvar cat = this;\n\t\n\t\t\t// If database doesn't exist yet or its version is lower than our version specified above (2nd param in line above)\n\t\t\topenRequest.onupgradeneeded = function (e) {\n\t\t\t\tvar thisDB = e.target.result;\n\t\t\t\tif (thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\t\tthisDB.deleteObjectStore(\"LokiAKV\");\n\t\t\t\t}\n\t\n\t\t\t\tif (!thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\t\tvar objectStore = thisDB.createObjectStore(\"LokiAKV\", {\n\t\t\t\t\t\tkeyPath: \"id\",\n\t\t\t\t\t\tautoIncrement: true\n\t\t\t\t\t});\n\t\t\t\t\tobjectStore.createIndex(\"app\", \"app\", {\n\t\t\t\t\t\tunique: false\n\t\t\t\t\t});\n\t\t\t\t\tobjectStore.createIndex(\"key\", \"key\", {\n\t\t\t\t\t\tunique: false\n\t\t\t\t\t});\n\t\t\t\t\t// hack to simulate composite key since overhead is low (main size should be in val field)\n\t\t\t\t\t// user (me) required to duplicate the app and key into comma delimited appkey field off object\n\t\t\t\t\t// This will allow retrieving single record with that composite key as well as\n\t\t\t\t\t// still supporting opening cursors on app or key alone\n\t\t\t\t\tobjectStore.createIndex(\"appkey\", \"appkey\", {\n\t\t\t\t\t\tunique: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t};\n\t\n\t\t\topenRequest.onsuccess = function (e) {\n\t\t\t\tcat.db = e.target.result;\n\t\n\t\t\t\tif (typeof callback === \"function\") callback(cat);\n\t\t\t};\n\t\n\t\t\topenRequest.onerror = function (e) {\n\t\t\t\tthrow e;\n\t\t\t};\n\t\t}\n\t\n\t\tgetAppKey(app, key, callback) {\n\t\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\t\tvar index = store.index(\"appkey\");\n\t\t\tvar appkey = app + \",\" + key;\n\t\t\tvar request = index.get(appkey);\n\t\n\t\t\trequest.onsuccess = function (usercallback) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tvar lres = e.target.result;\n\t\n\t\t\t\t\tif (lres === null || typeof lres === \"undefined\") {\n\t\t\t\t\t\tlres = {\n\t\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (typeof usercallback === \"function\") {\n\t\t\t\t\t\tusercallback(lres);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(lres);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}(callback);\n\t\n\t\t\trequest.onerror = function (usercallback) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tif (typeof usercallback === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}(callback);\n\t\t}\n\t\n\t\tgetAppKeyById(id, callback, data) {\n\t\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\t\tvar request = store.get(id);\n\t\n\t\t\trequest.onsuccess = function (data, usercallback) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tif (typeof usercallback === \"function\") {\n\t\t\t\t\t\tusercallback(e.target.result, data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(e.target.result);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}(data, callback);\n\t\t}\n\t\n\t\tsetAppKey(app, key, val, callback) {\n\t\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\t\tvar index = store.index(\"appkey\");\n\t\t\tvar appkey = app + \",\" + key;\n\t\t\tvar request = index.get(appkey);\n\t\n\t\t\t// first try to retrieve an existing object by that key\n\t\t\t// need to do this because to update an object you need to have id in object, otherwise it will append id with new autocounter and clash the unique index appkey\n\t\t\trequest.onsuccess = function (e) {\n\t\t\t\tvar res = e.target.result;\n\t\n\t\t\t\tif (res === null || res === undefined) {\n\t\t\t\t\tres = {\n\t\t\t\t\t\tapp: app,\n\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\tappkey: app + \",\" + key,\n\t\t\t\t\t\tval: val\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tres.val = val;\n\t\t\t\t}\n\t\n\t\t\t\tvar requestPut = store.put(res);\n\t\n\t\t\t\trequestPut.onerror = function (usercallback) {\n\t\t\t\t\treturn function (e) {\n\t\t\t\t\t\tif (typeof usercallback === \"function\") {\n\t\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (set) onerror\");\n\t\t\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}(callback);\n\t\n\t\t\t\trequestPut.onsuccess = function (usercallback) {\n\t\t\t\t\treturn function (e) {\n\t\t\t\t\t\tif (typeof usercallback === \"function\") {\n\t\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\t\tsuccess: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}(callback);\n\t\t\t};\n\t\n\t\t\trequest.onerror = function (usercallback) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tif (typeof usercallback === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (get) onerror\");\n\t\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}(callback);\n\t\t}\n\t\n\t\tdeleteAppKey(id, callback) {\n\t\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\t\tvar request = store.delete(id);\n\t\n\t\t\trequest.onsuccess = function (usercallback) {\n\t\t\t\treturn function (evt) {\n\t\t\t\t\tif (typeof usercallback === \"function\") usercallback({\n\t\t\t\t\t\tsuccess: true\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t}(callback);\n\t\n\t\t\trequest.onerror = function (usercallback) {\n\t\t\t\treturn function (evt) {\n\t\t\t\t\tif (typeof usercallback === \"function\") {\n\t\t\t\t\t\tusercallback(false);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"LokiCatalog.deleteAppKey raised onerror\");\n\t\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}(callback);\n\t\t}\n\t\n\t\tgetAppKeys(app, callback) {\n\t\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\t\tvar index = store.index(\"app\");\n\t\n\t\t\t// We want cursor to all values matching our (single) app param\n\t\t\tvar singleKeyRange = IDBKeyRange.only(app);\n\t\n\t\t\t// To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n\t\t\tvar cursor = index.openCursor(singleKeyRange);\n\t\n\t\t\t// cursor internally, pushing results into this.data[] and return\n\t\t\t// this.data[] when done (similar to service)\n\t\t\tvar localdata = [];\n\t\n\t\t\tcursor.onsuccess = function (data, callback) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tvar cursor = e.target.result;\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\tvar currObject = cursor.value;\n\t\n\t\t\t\t\t\tdata.push(currObject);\n\t\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}(localdata, callback);\n\t\n\t\t\tcursor.onerror = function (usercallback) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tif (typeof usercallback === \"function\") {\n\t\t\t\t\t\tusercallback(null);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"LokiCatalog.getAppKeys raised onerror\");\n\t\t\t\t\t\tconsole.error(e);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}(callback);\n\t\t}\n\t\n\t\t// Hide \"cursoring\" and return array of { id: id, key: key }\n\t\tgetAllKeys(callback) {\n\t\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\t\tvar cursor = store.openCursor();\n\t\n\t\t\tvar localdata = [];\n\t\n\t\t\tcursor.onsuccess = function (data, callback) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tvar cursor = e.target.result;\n\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\tvar currObject = cursor.value;\n\t\n\t\t\t\t\t\tdata.push(currObject);\n\t\n\t\t\t\t\t\tcursor.continue();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (typeof callback === \"function\") {\n\t\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}(localdata, callback);\n\t\n\t\t\tcursor.onerror = function (usercallback) {\n\t\t\t\treturn function (e) {\n\t\t\t\t\tif (typeof usercallback === \"function\") usercallback(null);\n\t\t\t\t};\n\t\t\t}(callback);\n\t\t}\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lokijs.core.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap da7d1153d4acd55453c4","import {Loki} from './lokicore'\n\nmodule.exports = Loki;\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/index.js","\nimport {LokiEventEmitter} from './event_emitter'\n\nimport {LokiFsAdapter} from './fs_adapter'\nimport {LokiLocalStorageAdapter} from './local_storage_adapter'\nimport {Collection} from './collection'\nimport {Utils} from './utils'\n\n/*\n'LokiFsAdapter' is not defined                 no-undef\tx\n'LokiLocalStorageAdapter' is not defined       no-undef\tx\n'Collection' is not defined                    no-undef\tx\n'delim' is not defined                         no-undef\tx\n'Utils' is not defined                         no-undef\tx\n */\n\n/**\n * Loki: The main database class\n * @constructor Loki\n * @implements LokiEventEmitter\n * @param {string} filename - name of the file to be saved to\n * @param {object=} options - (Optional) config options object\n * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n * @param {boolean} options.verbose - enable console output (default is 'false')\n */\nexport class Loki extends LokiEventEmitter {\n\n\tconstructor(filename, options) {\n\t\tsuper();\n\t\tthis.filename = filename || 'loki.db';\n\t\tthis.collections = [];\n\n\t\t// persist version of code which created the database to the database.\n\t\t// could use for upgrade scenarios\n\t\tthis.databaseVersion = 1.1;\n\t\tthis.engineVersion = 1.1;\n\n\t\t// autosave support (disabled by default)\n\t\t// pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n\t\tthis.autosave = false;\n\t\tthis.autosaveInterval = 5000;\n\t\tthis.autosaveHandle = null;\n\n\t\tthis.options = {\n\t\t\tserializationMethod: options && options.hasOwnProperty('serializationMethod') ? options.serializationMethod : 'normal',\n\t\t\tdestructureDelimiter: options && options.hasOwnProperty('destructureDelimiter') ? options.destructureDelimiter : '$<\\n'\n\t\t};\n\n\t\t// currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n\t\t// will not or cannot be deserialized.  You are required to configure persistence every time\n\t\t// you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\n\t\t// persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n\t\t// this is optional option param, otherwise environment detection will be used\n\t\t// if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n\t\tthis.persistenceMethod = null;\n\n\t\t// retain reference to optional (non-serializable) persistenceAdapter 'instance'\n\t\tthis.persistenceAdapter = null;\n\n\t\t// enable console output if verbose flag is set (disabled by default)\n\t\tthis.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;\n\n\t\tthis.events = {\n\t\t\t'init': [],\n\t\t\t'loaded': [],\n\t\t\t'flushChanges': [],\n\t\t\t'close': [],\n\t\t\t'changes': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\tvar getENV = function() {\n\t\t\tif (typeof window === 'undefined') {\n\t\t\t\treturn 'NODEJS';\n\t\t\t}\n\n\t\t\tif (typeof global !== 'undefined' && global.window) {\n\t\t\t\treturn 'NODEJS'; //node-webkit\n\t\t\t}\n\n\t\t\tif (typeof document !== 'undefined') {\n\t\t\t\tif (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n\t\t\t\t\treturn 'CORDOVA';\n\t\t\t\t}\n\t\t\t\treturn 'BROWSER';\n\t\t\t}\n\t\t\treturn 'CORDOVA';\n\t\t};\n\n\t\t// refactored environment detection due to invalid detection for browser environments.\n\t\t// if they do not specify an options.env we want to detect env rather than default to nodejs.\n\t\t// currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n\t\t//   might want to review whether we can consolidate.\n\t\tif (options && options.hasOwnProperty('env')) {\n\t\t\tthis.ENV = options.env;\n\t\t} else {\n\t\t\tthis.ENV = getENV();\n\t\t}\n\n\t\tthis.on('init', this.clearChanges);\n\t}\n\n\t// experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n\t// Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n\tgetIndexedAdapter() {\n\t\tvar adapter;\n\n\t\tif (typeof require === 'function') {\n\t\t\tadapter = require(\"./loki-indexed-adapter.js\");\n\t\t}\n\n\t\treturn adapter;\n\t};\n\n\n\t/**\n\t * configures options related to database persistence.\n\t *\n\t * @param {object} options - configuration options to apply to loki db object\n\t * @param {adapter} options.adapter - an instance of a loki persistence adapter\n\t * @param {boolean} options.autosave - enables autosave\n\t * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n\t * @param {boolean} options.autoload - enables autoload on loki instantiation\n\t * @param {object} options.inflate - options that are passed to loadDatabase if autoload enabled\n\t * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']\n\t * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n\t * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n\t * @memberof Loki\n\t */\n\tinitializePersistence(options) {\n\t\tvar self = this;\n\t\tvar defaultPersistence = {\n\t\t\t\t'NODEJS': 'fs',\n\t\t\t\t'BROWSER': 'localStorage',\n\t\t\t\t'CORDOVA': 'localStorage'\n\t\t\t},\n\t\t\tpersistenceMethods = {\n\t\t\t\t'fs': LokiFsAdapter,\n\t\t\t\t'localStorage': LokiLocalStorageAdapter\n\t\t\t};\n\n\t\tthis.options = options || {};\n\n\t\tthis.persistenceMethod = null;\n\t\t// retain reference to optional persistence adapter 'instance'\n\t\t// currently keeping outside options because it can't be serialized\n\t\tthis.persistenceAdapter = null;\n\n\t\t// process the options\n\t\tif (this.options.hasOwnProperty('persistenceMethod')) {\n\t\t\t// check if the specified persistence method is known\n\t\t\tif (typeof(persistenceMethods[this.options.persistenceMethod]) === 'function') {\n\t\t\t\tthis.persistenceMethod = this.options.persistenceMethod;\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.options.persistenceMethod]();\n\t\t\t}\n\t\t\t// should be throw an error here, or just fall back to defaults ??\n\t\t}\n\n\t\t// ensure defaults exists for options which were not set\n\t\tif (!this.options.hasOwnProperty('serializationMethod')) {\n\t\t\tthis.options.serializationMethod = 'normal';\n\t\t}\n\n\t\t// ensure passed or default option exists\n\t\tif (!this.options.hasOwnProperty('destructureDelimiter')) {\n\t\t\tthis.options.destructureDelimiter = '$<\\n';\n\t\t}\n\n\t\t// if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n\t\tif (this.persistenceAdapter === null) {\n\t\t\tthis.persistenceMethod = defaultPersistence[this.ENV];\n\t\t\tif (this.persistenceMethod) {\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n\t\t\t}\n\t\t}\n\n\t\t// if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n\t\tif (this.options.hasOwnProperty('adapter')) {\n\t\t\tthis.persistenceMethod = 'adapter';\n\t\t\tthis.persistenceAdapter = this.options.adapter;\n\t\t}\n\n\t\tif (this.options.hasOwnProperty('autosaveInterval')) {\n\t\t\tthis.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n\t\t}\n\n\t\tthis.autosaveDisable();\n\n\t\tvar loaded;\n\n\t\t// if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n\t\tif (this.options.autoload) {\n\t\t\tloaded = this.loadDatabase(this.options.inflate);\n\t\t} else {\n\t\t\tloaded = Promise.resolve();\n\t\t}\n\n\t\treturn loaded.then(function() {\n\t\t\tif (self.options.autosave) {\n\t\t\t\tself.autosaveEnable();\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n\t *\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n\t * @memberof Loki\n\t */\n\tcopy(options) {\n\t\tvar databaseCopy = new Loki(this.filename);\n\t\tvar clen, idx;\n\n\t\toptions = options || {};\n\n\t\t// currently inverting and letting loadJSONObject do most of the work\n\t\tdatabaseCopy.loadJSONObject(this, {\n\t\t\tretainDirtyFlags: true\n\t\t});\n\n\t\t// since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic\n\t\tif (options.hasOwnProperty(\"removeNonSerializable\") && options.removeNonSerializable === true) {\n\t\t\tdatabaseCopy.autosaveHandle = null;\n\t\t\tdatabaseCopy.persistenceAdapter = null;\n\n\t\t\tclen = databaseCopy.collections.length;\n\t\t\tfor (idx = 0; idx < clen; idx++) {\n\t\t\t\tdatabaseCopy.collections[idx].constraints = null;\n\t\t\t\tdatabaseCopy.collections[idx].ttl = null;\n\t\t\t}\n\t\t}\n\n\t\treturn databaseCopy;\n\t};\n\n\t/**\n\t * Shorthand method for quickly creating and populating an anonymous collection.\n\t *    This collection is not referenced internally so upon losing scope it will be garbage collected.\n\t *\n\t * @example\n\t * var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });\n\t *\n\t * @param {Array} docs - document array to initialize the anonymous collection with\n\t * @param {object} options - configuration object, see {@link Loki#addCollection} options\n\t * @returns {Collection} New collection which you can query or chain\n\t * @memberof Loki\n\t */\n\tanonym(docs, options) {\n\t\tvar collection = new Collection('anonym', options);\n\t\tcollection.insert(docs);\n\n\t\tif (this.verbose)\n\t\t\tcollection.console = console;\n\n\t\treturn collection;\n\t};\n\n\t/**\n\t * Adds a collection to the database.\n\t * @param {string} name - name of collection to add\n\t * @param {object=} options - (optional) options to configure collection with.\n\t * @param {array} options.unique - array of property names to define unique constraints for\n\t * @param {array} options.exact - array of property names to define exact constraints for\n\t * @param {array} options.indices - array property names to define binary indexes for\n\t * @param {boolean} options.asyncListeners - default is false\n\t * @param {boolean} options.disableChangesApi - default is true\n\t * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n\t * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n\t * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n\t * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n\t * @returns {Collection} a reference to the collection which was just added\n\t * @memberof Loki\n\t */\n\taddCollection(name, options) {\n\t\tvar collection = new Collection(name, options);\n\t\tthis.collections.push(collection);\n\n\t\tif (this.verbose)\n\t\t\tcollection.console = console;\n\n\t\treturn collection;\n\t};\n\n\tloadCollection(collection) {\n\t\tif (!collection.name) {\n\t\t\tthrow new Error('Collection must have a name property to be loaded');\n\t\t}\n\t\tthis.collections.push(collection);\n\t};\n\n\t/**\n\t * Retrieves reference to a collection by name.\n\t * @param {string} collectionName - name of collection to look up\n\t * @returns {Collection} Reference to collection in database by that name, or null if not found\n\t * @memberof Loki\n\t */\n\tgetCollection(collectionName) {\n\t\tvar i,\n\t\t\tlen = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\treturn this.collections[i];\n\t\t\t}\n\t\t}\n\n\t\t// no such collection\n\t\tthis.emit('warning', 'collection ' + collectionName + ' not found');\n\t\treturn null;\n\t};\n\n\tlistCollections() {\n\n\t\tvar i = this.collections.length,\n\t\t\tcolls = [];\n\n\t\twhile (i--) {\n\t\t\tcolls.push({\n\t\t\t\tname: this.collections[i].name,\n\t\t\t\ttype: this.collections[i].objType,\n\t\t\t\tcount: this.collections[i].data.length\n\t\t\t});\n\t\t}\n\t\treturn colls;\n\t};\n\n\t/**\n\t * Removes a collection from the database.\n\t * @param {string} collectionName - name of collection to remove\n\t * @memberof Loki\n\t */\n\tremoveCollection(collectionName) {\n\t\tvar i,\n\t\t\tlen = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\tvar tmpcol = new Collection(collectionName, {});\n\t\t\t\tvar curcol = this.collections[i];\n\t\t\t\tfor (var prop in curcol) {\n\t\t\t\t\tif (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n\t\t\t\t\t\tcurcol[prop] = tmpcol[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.collections.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t};\n\n\tgetName() {\n\t\treturn this.name;\n\t};\n\n\t/**\n\t * serializeReplacer - used to prevent certain properties from being serialized\n\t *\n\t */\n\tserializeReplacer(key, value) {\n\t\tswitch (key) {\n\t\t\tcase 'autosaveHandle':\n\t\t\tcase 'persistenceAdapter':\n\t\t\tcase 'constraints':\n\t\t\tcase 'ttl':\n\t\t\t\treturn null;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t};\n\n\t/**\n\t * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n\t *\n\t * @returns {string} Stringified representation of the loki database.\n\t * @memberof Loki\n\t */\n\tserialize(options) {\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"serializationMethod\")) {\n\t\t\toptions.serializationMethod = this.options.serializationMethod;\n\t\t}\n\n\t\tswitch (options.serializationMethod) {\n\t\t\tcase \"normal\":\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t\tcase \"pretty\":\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer, 2);\n\t\t\tcase \"destructured\":\n\t\t\t\treturn this.serializeDestructured(); // use default options\n\t\t\tdefault:\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t}\n\t};\n\n\t// alias of serialize\n\ttoJson() {\n\t\treturn this.serialize;\n\t}\n\n\t/**\n\t * Destructured JSON serialization routine to allow alternate serialization methods.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {object=} options - output format options for use externally to loki\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {string|array} A custom, restructured aggregation of independent serializations.\n\t * @memberof Loki\n\t */\n\tserializeDestructured(options) {\n\t\tvar idx, sidx, result, resultlen;\n\t\tvar reconstruct = [];\n\t\tvar dbcopy;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n\t\tif (options.partitioned === true && options.hasOwnProperty(\"partition\") && options.partition >= 0) {\n\t\t\treturn this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: options.partition\n\t\t\t});\n\t\t}\n\n\t\t// not just an individual collection, so we will need to serialize db container via shallow copy\n\t\tdbcopy = new Loki(this.filename);\n\t\tdbcopy.loadJSONObject(this);\n\n\t\tfor (idx = 0; idx < dbcopy.collections.length; idx++) {\n\t\t\tdbcopy.collections[idx].data = [];\n\t\t}\n\n\t\t// if we -only- wanted the db container portion, return it now\n\t\tif (options.partitioned === true && options.partition === -1) {\n\t\t\t// since we are deconstructing, override serializationMethod to normal for here\n\t\t\treturn dbcopy.serialize({\n\t\t\t\tserializationMethod: \"normal\"\n\t\t\t});\n\t\t}\n\n\t\t// at this point we must be deconstructing the entire database\n\t\t// start by pushing db serialization into first array element\n\t\treconstruct.push(dbcopy.serialize({\n\t\t\tserializationMethod: \"normal\"\n\t\t}));\n\n\t\tdbcopy = null;\n\n\t\t// push collection data into subsequent elements\n\t\tfor (idx = 0; idx < this.collections.length; idx++) {\n\t\t\tresult = this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: idx\n\t\t\t});\n\n\t\t\t// NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n\t\t\tif (options.partitioned === false && options.delimited === false) {\n\t\t\t\tif (!Array.isArray(result)) {\n\t\t\t\t\tthrow new Error(\"a nondelimited, non partitioned collection serialization did not return an expected array\");\n\t\t\t\t}\n\n\t\t\t\t// Array.concat would probably duplicate memory overhead for copying strings.\n\t\t\t\t// Instead copy each individually, and clear old value after each copy.\n\t\t\t\t// Hopefully this will allow g.c. to reduce memory pressure, if needed.\n\t\t\t\tresultlen = result.length;\n\n\t\t\t\tfor (sidx = 0; sidx < resultlen; sidx++) {\n\t\t\t\t\treconstruct.push(result[sidx]);\n\t\t\t\t\tresult[sidx] = null;\n\t\t\t\t}\n\n\t\t\t\treconstruct.push(\"\");\n\t\t\t} else {\n\t\t\t\treconstruct.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n\t\tif (options.partitioned) {\n\t\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t\t// useful for simple future adaptations of existing persistence adapters to save collections separately\n\t\t\tif (options.delimited) {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t\t// This format might be the most versatile for 'rolling your own' partitioned sync or save.\n\t\t\t// Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n\t\t\telse {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t} else {\n\t\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t\t// This is the method Loki will use internally if 'destructured'.\n\t\t\t// Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n\t\t\tif (options.delimited) {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct.join(options.delimiter);\n\t\t\t}\n\t\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\t\t\t// This format might be best candidate for custom synchronous syncs or saves\n\t\t\telse {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t}\n\n\t\treconstruct.push(\"\");\n\n\t\treturn reconstruct.join(delim);\n\t};\n\n\t/**\n\t * Utility method to serialize a collection in a 'destructured' format\n\t *\n\t * @param {object} options - used to determine output of method\n\t * @param {int=} options.delimited - whether to return single delimited string or an array\n\t * @param {string=} options.delimiter - (optional) if delimited, this is delimiter to use\n\t * @param {int} options.collectionIndex -  specify which collection to serialize data for\n\t *\n\t * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n\t * @memberof Loki\n\t */\n\tserializeCollection(options) {\n\t\tvar doccount,\n\t\t\tdocidx,\n\t\t\tresultlines = [];\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"collectionIndex\")) {\n\t\t\tthrow new Error(\"serializeCollection called without 'collectionIndex' option\");\n\t\t}\n\n\t\tdoccount = this.collections[options.collectionIndex].data.length;\n\n\t\tresultlines = [];\n\n\t\tfor (docidx = 0; docidx < doccount; docidx++) {\n\t\t\tresultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));\n\t\t}\n\n\t\t// D and DA\n\t\tif (options.delimited) {\n\t\t\t// indicate no more documents in collection (via empty delimited string)\n\t\t\tresultlines.push(\"\");\n\n\t\t\treturn resultlines.join(options.delimiter);\n\t\t} else {\n\t\t\t// NDAA and NDA\n\t\t\treturn resultlines;\n\t\t}\n\t};\n\n\t/**\n\t * Destructured JSON deserialization routine to minimize memory overhead.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {string|array} destructuredSource - destructured json or array to deserialize from\n\t * @param {object=} options - source format options\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to deserialize only a single partition\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n\t * @memberof Loki\n\t */\n\tdeserializeDestructured(destructuredSource, options) {\n\t\tvar workarray = [];\n\t\tvar len, cdb;\n\t\tvar idx, collIndex = 0,\n\t\t\tcollCount, lineIndex = 1,\n\t\t\tdone = false;\n\t\tvar currLine, currObject;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// Partitioned\n\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t// -or- single partition\n\t\tif (options.partitioned) {\n\t\t\t// handle single partition\n\t\t\tif (options.hasOwnProperty('partition')) {\n\t\t\t\t// db only\n\t\t\t\tif (options.partition === -1) {\n\t\t\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\n\t\t\t\t\treturn cdb;\n\t\t\t\t}\n\n\t\t\t\t// single collection, return doc array\n\t\t\t\treturn this.deserializeCollection(destructuredSource[options.partition + 1], options);\n\t\t\t}\n\n\t\t\t// Otherwise we are restoring an entire partitioned db\n\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\t\t\tcollCount = cdb.collections.length;\n\t\t\tfor (collIndex = 0; collIndex < collCount; collIndex++) {\n\t\t\t\t// attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n\t\t\t\tcdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n\t\t\t}\n\n\t\t\treturn cdb;\n\t\t}\n\n\t\t// Non-Partitioned\n\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\n\t\t// D\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tdestructuredSource = null; // lower memory pressure\n\t\t\tlen = workarray.length;\n\n\t\t\tif (len === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// NDA\n\t\telse {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\t// first line is database and collection shells\n\t\tcdb = JSON.parse(workarray[0]);\n\t\tcollCount = cdb.collections.length;\n\t\tworkarray[0] = null;\n\n\t\twhile (!done) {\n\t\t\tcurrLine = workarray[lineIndex];\n\n\t\t\t// empty string indicates either end of collection or end of file\n\t\t\tif (workarray[lineIndex] === \"\") {\n\t\t\t\t// if no more collections to load into, we are done\n\t\t\t\tif (++collIndex > collCount) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrObject = JSON.parse(workarray[lineIndex]);\n\t\t\t\tcdb.collections[collIndex].data.push(currObject);\n\t\t\t}\n\n\t\t\t// lower memory pressure and advance iterator\n\t\t\tworkarray[lineIndex++] = null;\n\t\t}\n\n\t\treturn cdb;\n\t};\n\n\t/**\n\t * Deserializes a destructured collection.\n\t *\n\t * @param {string|array} destructuredSource - destructured representation of collection to inflate\n\t * @param {object} options - used to describe format of destructuredSource input\n\t * @param {int} options.delimited - whether source is delimited string or an array\n\t * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n\t *\n\t * @returns {array} an array of documents to attach to collection.data.\n\t * @memberof Loki\n\t */\n\tdeserializeCollection(destructuredSource, options) {\n\t\tvar workarray = [];\n\t\tvar idx, len;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tworkarray.pop();\n\t\t} else {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\tlen = workarray.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tworkarray[idx] = JSON.parse(workarray[idx]);\n\t\t}\n\n\t\treturn workarray;\n\t};\n\n\t/**\n\t * Inflates a loki database from a serialized JSON string\n\t *\n\t * @param {string} serializedDb - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t * @memberof Loki\n\t */\n\tloadJSON(serializedDb, options) {\n\t\tvar dbObject;\n\t\tif (serializedDb.length === 0) {\n\t\t\tdbObject = {};\n\t\t} else {\n\t\t\t// using option defined in instantiated db not what was in serialized db\n\t\t\tswitch (this.options.serializationMethod) {\n\t\t\t\tcase \"normal\":\n\t\t\t\tcase \"pretty\":\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"destructured\":\n\t\t\t\t\tdbObject = this.deserializeDestructured(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.loadJSONObject(dbObject, options);\n\t};\n\n\t/**\n\t * Inflates a loki database from a JS object\n\t *\n\t * @param {object} dbObject - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool?} options.retainDirtyFlags - whether collection dirty flags will be preserved\n\t * @memberof Loki\n\t */\n\tloadJSONObject(dbObject, options) {\n\t\tvar i = 0,\n\t\t\tlen = dbObject.collections ? dbObject.collections.length : 0,\n\t\t\tcoll,\n\t\t\tcopyColl,\n\t\t\tclen,\n\t\t\tj,\n\t\t\tloader,\n\t\t\tcollObj;\n\n\t\tthis.name = dbObject.name;\n\n\t\t// restore database version\n\t\tthis.databaseVersion = 1.0;\n\t\tif (dbObject.hasOwnProperty('databaseVersion')) {\n\t\t\tthis.databaseVersion = dbObject.databaseVersion;\n\t\t}\n\n\t\tthis.collections = [];\n\n\t\tfunction makeLoader(coll) {\n\t\t\tvar collOptions = options[coll.name];\n\t\t\tvar inflater;\n\n\t\t\tif (collOptions.proto) {\n\t\t\t\tinflater = collOptions.inflate || Utils.copyProperties;\n\n\t\t\t\treturn function(data) {\n\t\t\t\t\tvar collObj = new(collOptions.proto)();\n\t\t\t\t\tinflater(data, collObj);\n\t\t\t\t\treturn collObj;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn collOptions.inflate;\n\t\t}\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tcoll = dbObject.collections[i];\n\t\t\tcopyColl = this.addCollection(coll.name);\n\n\t\t\tcopyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? (coll.adaptiveBinaryIndices === true) : false;\n\t\t\tcopyColl.transactional = coll.transactional;\n\t\t\tcopyColl.asyncListeners = coll.asyncListeners;\n\t\t\tcopyColl.disableChangesApi = coll.disableChangesApi;\n\t\t\tcopyColl.cloneObjects = coll.cloneObjects;\n\t\t\tcopyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n\t\t\tcopyColl.autoupdate = coll.autoupdate;\n\t\t\tcopyColl.changes = coll.changes;\n\n\t\t\tif (options && options.retainDirtyFlags === true) {\n\t\t\t\tcopyColl.dirty = coll.dirty;\n\t\t\t} else {\n\t\t\t\tcopyColl.dirty = false;\n\t\t\t}\n\n\t\t\t// load each element individually\n\t\t\tclen = coll.data.length;\n\t\t\tj = 0;\n\t\t\tif (options && options.hasOwnProperty(coll.name)) {\n\t\t\t\tloader = makeLoader(coll);\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcollObj = loader(coll.data[j]);\n\t\t\t\t\tcopyColl.data[j] = collObj;\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(collObj);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcopyColl.data[j] = coll.data[j];\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(copyColl.data[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcopyColl.maxId = (coll.data.length === 0) ? 0 : coll.maxId;\n\t\t\tcopyColl.idIndex = coll.idIndex;\n\t\t\tif (typeof(coll.binaryIndices) !== 'undefined') {\n\t\t\t\tcopyColl.binaryIndices = coll.binaryIndices;\n\t\t\t}\n\t\t\tif (typeof coll.transforms !== 'undefined') {\n\t\t\t\tcopyColl.transforms = coll.transforms;\n\t\t\t}\n\n\t\t\tcopyColl.ensureId();\n\n\t\t\t// regenerate unique indexes\n\t\t\tcopyColl.uniqueNames = [];\n\t\t\tif (coll.hasOwnProperty(\"uniqueNames\")) {\n\t\t\t\tcopyColl.uniqueNames = coll.uniqueNames;\n\t\t\t\tfor (j = 0; j < copyColl.uniqueNames.length; j++) {\n\t\t\t\t\tcopyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case they are loading a database created before we added dynamic views, handle undefined\n\t\t\tif (typeof(coll.DynamicViews) === 'undefined') continue;\n\n\t\t\t// reinflate DynamicViews and attached Resultsets\n\t\t\tfor (var idx = 0; idx < coll.DynamicViews.length; idx++) {\n\t\t\t\tvar colldv = coll.DynamicViews[idx];\n\n\t\t\t\tvar dv = copyColl.addDynamicView(colldv.name, colldv.options);\n\t\t\t\tdv.resultdata = colldv.resultdata;\n\t\t\t\tdv.resultsdirty = colldv.resultsdirty;\n\t\t\t\tdv.filterPipeline = colldv.filterPipeline;\n\n\t\t\t\tdv.sortCriteria = colldv.sortCriteria;\n\t\t\t\tdv.sortFunction = null;\n\n\t\t\t\tdv.sortDirty = colldv.sortDirty;\n\t\t\t\tdv.resultset.filteredrows = colldv.resultset.filteredrows;\n\t\t\t\tdv.resultset.searchIsChained = colldv.resultset.searchIsChained;\n\t\t\t\tdv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\n\t\t\t\tdv.rematerialize({\n\t\t\t\t\tremoveWhereFilters: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n\t * Does not actually destroy the db.\n\t *\n\t * @returns {Promise} a Promise that resolves after closing the database succeeded\n\t * @memberof Loki\n\t */\n\tclose() {\n\t\tvar self = this;\n\t\tvar saved;\n\n\t\t// for autosave scenarios, we will let close perform final save (if dirty)\n\t\t// For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n\t\tif (this.autosave) {\n\t\t\tthis.autosaveDisable();\n\t\t\tif (this.autosaveDirty()) {\n\t\t\t\tsaved = this.saveDatabase();\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(function() {\n\t\t\tself.emit('close');\n\t\t});\n\t};\n\n\t/**-------------------------+\n\t | Changes API               |\n\t +--------------------------*/\n\n\t/**\n\t * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n\t * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n\t */\n\n\t/**\n\t * (Changes API) : takes all the changes stored in each\n\t * collection and creates a single array for the entire database. If an array of names\n\t * of collections is passed then only the included collections will be tracked.\n\t *\n\t * @param {array=} optional array of collection names. No arg means all collections are processed.\n\t * @returns {array} array of changes\n\t * @see private method createChange() in Collection\n\t * @memberof Loki\n\t */\n\tgenerateChangesNotification(arrayOfCollectionNames) {\n\t\tfunction getCollName(coll) {\n\t\t\treturn coll.name;\n\t\t}\n\t\tvar changes = [],\n\t\t\tselectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\n\t\tthis.collections.forEach(function(coll) {\n\t\t\tif (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n\t\t\t\tchanges = changes.concat(coll.getChanges());\n\t\t\t}\n\t\t});\n\t\treturn changes;\n\t};\n\n\t/**\n\t * (Changes API) - stringify changes for network transmission\n\t * @returns {string} string representation of the changes\n\t * @memberof Loki\n\t */\n\tserializeChanges(collectionNamesArray) {\n\t\treturn JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n\t};\n\n\t/**\n\t * (Changes API) : clears all the changes in all collections.\n\t * @memberof Loki\n\t */\n\tclearChanges() {\n\t\tthis.collections.forEach(function(coll) {\n\t\t\tif (coll.flushChanges) {\n\t\t\t\tcoll.flushChanges();\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n\t * Handles loading from file system, local storage, or adapter (indexeddb).\n\t *\n\t * @param {object} options - an object containing inflation options for each collection\n\t * @returns {Promise} a Promise that resolves after the database is loaded\n\t * @memberof Loki\n\t */\n\tloadDatabase(options) {\n\t\tvar self = this;\n\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.loadDatabase(this.filename))\n\t\t\t.then(function loadDatabaseCallback(dbString) {\n\t\t\t\tif (typeof(dbString) === 'string') {\n\t\t\t\t\tself.loadJSON(dbString, options || {});\n\t\t\t\t\tself.emit('load', self);\n\t\t\t\t} else {\n\t\t\t\t\t// if adapter has returned an js object (other than null or error) attempt to load from JSON object\n\t\t\t\t\tif (typeof(dbString) === \"object\" && dbString !== null && !(dbString instanceof Error)) {\n\t\t\t\t\t\tself.loadJSONObject(dbString, options || {});\n\t\t\t\t\t\tself.emit('load', self);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dbString instanceof Error)\n\t\t\t\t\t\t\tthrow dbString;\n\n\t\t\t\t\t\tthrow new TypeError('The persistence adapter did not load a serialized DB string or object.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t};\n\n\t/**\n\t * Handles saving to file system, local storage, or adapter (indexeddb)\n\t *\n\t * @memberof Loki\n\t * @returns {Promise} a Promise that resolves after the database is persisted\n\t */\n\tsaveDatabase() {\n\t\tvar self = this;\n\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\tvar saved;\n\n\t\t// check if the adapter is requesting (and supports) a 'reference' mode export\n\t\tif (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n\t\t\t// filename may seem redundant but loadDatabase will need to expect this same filename\n\t\t\tsaved = this.persistenceAdapter.exportDatabase(this.filename, this.copy({\n\t\t\t\tremoveNonSerializable: true\n\t\t\t}));\n\t\t}\n\t\t// otherwise just pass the serialized database to adapter\n\t\telse {\n\t\t\tsaved = this.persistenceAdapter.saveDatabase(this.filename, self.serialize());\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(function() {\n\t\t\tself.autosaveClearFlags();\n\t\t\tself.emit(\"save\");\n\t\t});\n\t};\n\n\t// alias\n\tsave() {\n\t\treturn this.saveDatabase();\n\t}\n\n\t/**\n\t * Handles deleting a database from file system, local storage, or adapter (indexeddb)\n\t *\n\t * @returns {Promise} a Promise that resolves after the database is deleted\n\t * @memberof Loki\n\t */\n\tdeleteDatabase() {\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.deleteDatabase(this.filename));\n\t};\n\n\t/**\n\t * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n\t *\n\t * @returns {boolean} - true if database has changed since last autosave, false if not.\n\t */\n\tautosaveDirty() {\n\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\tif (this.collections[idx].dirty) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t};\n\n\t/**\n\t * autosaveClearFlags - resets dirty flags on all collections.\n\t *    Called from saveDatabase() after db is saved.\n\t *\n\t */\n\tautosaveClearFlags() {\n\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\tthis.collections[idx].dirty = false;\n\t\t}\n\t};\n\n\t/**\n\t * autosaveEnable - begin a javascript interval to periodically save the database.\n\t *\n\t */\n\tautosaveEnable() {\n\t\tif (this.autosaveHandle) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this;\n\t\tvar running = true;\n\n\t\tthis.autosave = true;\n\t\tthis.autosaveHandle = function() {\n\t\t\trunning = false;\n\t\t\tself.autosaveHandle = undefined;\n\t\t};\n\n\t\t(function saveDatabase() {\n\t\t\tsetTimeout(function() {\n\t\t\t\tif (running) {\n\t\t\t\t\tself.saveDatabase().then(saveDatabase, saveDatabase);\n\t\t\t\t}\n\t\t\t}, self.autosaveInterval);\n\t\t})();\n\t};\n\n\t/**\n\t * autosaveDisable - stop the autosave interval timer.\n\t *\n\t */\n\tautosaveDisable() {\n\t\tthis.autosave = false;\n\n\t\tif (this.autosaveHandle) {\n\t\t\tthis.autosaveHandle();\n\t\t}\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/lokicore.js","\n/*\n 'listen' is not defined  no-undef\n */\n\n/**\n * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n * constructor that inherits EventEmitter to emit events and trigger\n * listeners that have been added to the event through the on(event, callback) method\n *\n * @constructor LokiEventEmitter\n */\nexport class LokiEventEmitter {\n\n\tconstructor() {\n\t\t/**\n\t\t * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.events = {};\n\n\t\t/**\n\t\t * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n\t\t * should happen in an async fashion or not\n\t\t * Default is false, which means events are synchronous\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.asyncListeners = false;\n\t}\n\n\t/**\n\t * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\ton(eventName, listener) {\n\t\tvar event;\n\t\tvar self = this;\n\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach(function(currentEventName) {\n\t\t\t\tself.on(currentEventName, listener);\n\t\t\t});\n\t\t\treturn listener;\n\t\t}\n\n\t\tevent = this.events[eventName];\n\t\tif (!event) {\n\t\t\tevent = this.events[eventName] = [];\n\t\t}\n\t\tevent.push(listener);\n\t\treturn listener;\n\t}\n\n\t/**\n\t * emit(eventName, data) - emits a particular event\n\t * with the option of passing optional parameters which are going to be processed by the callback\n\t * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n\t * @param {string} eventName - the name of the event\n\t * @param {object=} data - optional object passed with the event\n\t * @memberof LokiEventEmitter\n\t */\n\temit(eventName, data) {\n\t\tvar self = this;\n\t\tif (eventName && this.events[eventName]) {\n\t\t\tthis.events[eventName].forEach(function(listener) {\n\t\t\t\tif (self.asyncListeners) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tlistener(data);\n\t\t\t\t\t}, 1);\n\t\t\t\t} else {\n\t\t\t\t\tlistener(data);\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Alias of LokiEventEmitter.prototype.on\n\t * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\taddListener(eventName, listener) {\n\t\treturn this.on(eventName, listener);\n\t}\n\n\t/**\n\t * removeListener() - removes the listener at position 'index' from the event 'eventName'\n\t * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n\t * @param {function} listener - the listener callback function to remove from emitter\n\t * @memberof LokiEventEmitter\n\t */\n\tremoveListener(eventName, listener) {\n\t\tvar self = this;\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach(function(currentEventName) {\n\t\t\t\tself.removeListener(currentEventName, listen);\n\t\t\t});\n\t\t}\n\n\t\tif (this.events[eventName]) {\n\t\t\tvar listeners = this.events[eventName];\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t}\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/event_emitter.js","\n/**\n * A loki persistence adapter which persists using node fs module\n * @constructor LokiFsAdapter\n */\nexport class LokiFsAdapter {\n\n\tconstructor() {\n\t\tthis.fs = undefined //TODO require('fs');\n\t}\n\n\t/**\n\t * loadDatabase() - Load data from file, will throw an error if the file does not exist\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiFsAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tvar self = this;\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.stat(dbname, function(err, stats) {\n\t\t\t\tif (!err && stats.isFile()) {\n\t\t\t\t\tself.fs.readFile(dbname, {\n\t\t\t\t\t\tencoding: 'utf8'\n\t\t\t\t\t}, function readFileCallback(err, data) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n\t * saveDatabase() - save data to file, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiFsAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tvar self = this;\n\t\tvar tmpdbname = dbname + '~';\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.writeFile(tmpdbname, dbstring, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tself.fs.rename(tmpdbname, dbname, function(err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n\t * deleteDatabase() - delete the database file, will throw an error if the\n\t * file can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiFsAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tvar self = this;\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/fs_adapter.js","\nfunction localStorageAvailable() {\n\ttry {\n\t\treturn (window && window.localStorage !== undefined && window.localStorage !== null);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n/*\n 'localStorageAvailable' is not defined\n */\n\n/**\n * A loki persistence adapter which persists to web browser's local storage object\n * @constructor LokiLocalStorageAdapter\n */\nexport class LokiLocalStorageAdapter {\n\n\t/**\n\t * loadDatabase() - Load data from localstorage\n\t * @param {string} dbname - the name of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\treturn Promise.resolve(localStorage.getItem(dbname));\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t};\n\n\t/**\n\t * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was saved\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.setItem(dbname, dbstring);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t};\n\n\t/**\n\t * deleteDatabase() - delete the database from localstorage, will throw an error if it\n\t * can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.removeItem(dbname);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t};\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/local_storage_adapter.js","import {LokiEventEmitter} from './event_emitter';\nimport {UniqueIndex} from './unique_index'\nimport {ExactIndex} from './exact_index'\nimport {Resultset} from './resultset'\nimport {DynamicView} from './dynamic_view'\nimport {clone, cloneObjectArray} from './clone'\nimport {ltHelper, gtHelper} from './helper'\n\n/**\n * General utils, including statistical functions\n */\nfunction isDeepProperty(field) {\n\treturn field.indexOf('.') !== -1;\n}\n\nfunction parseBase10(num) {\n\treturn parseFloat(num, 10);\n}\n\nfunction add(a, b) {\n\treturn a + b;\n}\n\nfunction sub(a, b) {\n\treturn a - b;\n}\n\nfunction average(array) {\n\treturn (array.reduce(add, 0)) / array.length;\n}\n\nfunction standardDeviation(values) {\n\tvar avg = average(values);\n\tvar squareDiffs = values.map(function(value) {\n\t\tvar diff = value - avg;\n\t\tvar sqrDiff = diff * diff;\n\t\treturn sqrDiff;\n\t});\n\n\tvar avgSquareDiff = average(squareDiffs);\n\n\tvar stdDev = Math.sqrt(avgSquareDiff);\n\treturn stdDev;\n}\n\nfunction deepProperty(obj, property, isDeep) {\n\tif (isDeep === false) {\n\t\t// pass without processing\n\t\treturn obj[property];\n\t}\n\tvar pieces = property.split('.'),\n\t\troot = obj;\n\twhile (pieces.length > 0) {\n\t\troot = root[pieces.shift()];\n\t}\n\treturn root;\n}\n\n/*\n'UniqueIndex' is not defined                 no-undef\n'ExactIndex' is not defined                  no-undef\n'ltHelper' is not defined                    no-undef\n'gtHelper' is not defined                    no-undef\n'DynamicView' is not defined                 no-undef\n'clone' is not defined                       no-undef\n'Resultset' is not defined                   no-undef\n'cloneObjectArray' is not defined            no-undef\n\n'isDeepProperty' is not defined              no-undef\n'deepProperty' is not defined                no-undef\n'average' is not defined                     no-undef\n'standardDeviation' is not defined           no-undef\n'sub' is not defined                         no-undef\n */\n\n/**\n * Collection class that handles documents of same type\n * @constructor Collection\n * @implements LokiEventEmitter\n * @param {string} name - collection name\n * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n * @param {array} options.unique - array of property names to define unique constraints for\n * @param {array} options.exact - array of property names to define exact constraints for\n * @param {array} options.indices - array property names to define binary indexes for\n * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily (default: true)\n * @param {boolean} options.asyncListeners - default is false\n * @param {boolean} options.disableChangesApi - default is true\n * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n * @see {@link Loki#addCollection} for normal creation of collections\n */\nexport class Collection extends LokiEventEmitter {\n\n\tconstructor(name, options) {\n\t\tsuper();\n\t\t// the name of the collection\n\n\t\tthis.name = name;\n\t\t// the data held by the collection\n\t\tthis.data = [];\n\t\tthis.idIndex = []; // index of id\n\t\tthis.binaryIndices = {}; // user defined indexes\n\t\tthis.constraints = {\n\t\t\tunique: {},\n\t\t\texact: {}\n\t\t};\n\n\t\t// unique contraints contain duplicate object references, so they are not persisted.\n\t\t// we will keep track of properties which have unique contraint applied here, and regenerate on load\n\t\tthis.uniqueNames = [];\n\n\t\t// transforms will be used to store frequently used query chains as a series of steps\n\t\t// which itself can be stored along with the database.\n\t\tthis.transforms = {};\n\n\t\t// the object type of the collection\n\t\tthis.objType = name;\n\n\t\t// in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n\t\t// currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n\t\t// defaulting to true since this is called from addCollection and adding a collection should trigger save\n\t\tthis.dirty = true;\n\n\t\t// private holders for cached data\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\t\tvar self = this;\n\n\t\t/* OPTIONS */\n\t\toptions = options || {};\n\n\t\t// exact match and unique constraints\n\t\tif (options.hasOwnProperty('unique')) {\n\t\t\tif (!Array.isArray(options.unique)) {\n\t\t\t\toptions.unique = [options.unique];\n\t\t\t}\n\t\t\toptions.unique.forEach(function (prop) {\n\t\t\t\tself.uniqueNames.push(prop); // used to regenerate on subsequent database loads\n\t\t\t\tself.constraints.unique[prop] = new UniqueIndex(prop);\n\t\t\t});\n\t\t}\n\n\t\tif (options.hasOwnProperty('exact')) {\n\t\t\toptions.exact.forEach(function (prop) {\n\t\t\t\tself.constraints.exact[prop] = new ExactIndex(prop);\n\t\t\t});\n\t\t}\n\n\t\t// if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n\t\t// if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n\t\tthis.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;\n\n\t\t// is collection transactional\n\t\tthis.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;\n\n\t\t// options to clone objects when inserting them\n\t\tthis.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;\n\n\t\t// default clone method (if enabled) is parse-stringify\n\t\tthis.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : \"parse-stringify\";\n\n\t\t// option to make event listeners async, default is sync\n\t\tthis.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;\n\n\t\t// disable track changes\n\t\tthis.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;\n\n\t\t// option to observe objects and update them automatically, ignored if Object.observe is not supported\n\t\tthis.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;\n\n\t\t//option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n\t\tthis.ttl = {\n\t\t\tage: null,\n\t\t\tttlInterval: null,\n\t\t\tdaemon: null\n\t\t};\n\t\tthis.setTTL(options.ttl || -1, options.ttlInterval);\n\n\t\t// currentMaxId - change manually at your own peril!\n\t\tthis.maxId = 0;\n\n\t\tthis.DynamicViews = [];\n\n\t\t// events\n\t\tthis.events = {\n\t\t\t'insert': [],\n\t\t\t'update': [],\n\t\t\t'pre-insert': [],\n\t\t\t'pre-update': [],\n\t\t\t'close': [],\n\t\t\t'flushbuffer': [],\n\t\t\t'error': [],\n\t\t\t'delete': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\t// changes are tracked by collection and aggregated by the db\n\t\tthis.changes = [];\n\n\t\t// initialize the id index\n\t\tthis.ensureId();\n\t\tvar indices = [];\n\t\t// initialize optional user-supplied indices array ['age', 'lname', 'zip']\n\t\tif (options && options.indices) {\n\t\t\tif (Object.prototype.toString.call(options.indices) === '[object Array]') {\n\t\t\t\tindices = options.indices;\n\t\t\t} else if (typeof options.indices === 'string') {\n\t\t\t\tindices = [options.indices];\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Indices needs to be a string or an array of strings');\n\t\t\t}\n\t\t}\n\n\t\tfor (var idx = 0; idx < indices.length; idx++) {\n\t\t\tthis.ensureIndex(indices[idx]);\n\t\t}\n\n\t\tfunction observerCallback(changes) {\n\n\t\t\tvar changedObjects = typeof Set === 'function' ? new Set() : [];\n\n\t\t\tif (!changedObjects.add)\n\t\t\t\tchangedObjects.add = function (object) {\n\t\t\t\t\tif (this.indexOf(object) === -1)\n\t\t\t\t\t\tthis.push(object);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\n\t\t\tchanges.forEach(function (change) {\n\t\t\t\tchangedObjects.add(change.object);\n\t\t\t});\n\n\t\t\tchangedObjects.forEach(function (object) {\n\t\t\t\tif (!hasOwnProperty.call(object, '$loki'))\n\t\t\t\t\treturn self.removeAutoUpdateObserver(object);\n\t\t\t\ttry {\n\t\t\t\t\tself.update(object);\n\t\t\t\t} catch (err) {\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.observerCallback = observerCallback;\n\n\t\t/*\n\t\t * This method creates a clone of the current status of an object and associates operation and collection name,\n\t\t * so the parent db can aggregate and generate a changes object for the entire db\n\t\t */\n\t\tfunction createChange(name, op, obj) {\n\t\t\tself.changes.push({\n\t\t\t\tname: name,\n\t\t\t\toperation: op,\n\t\t\t\tobj: JSON.parse(JSON.stringify(obj))\n\t\t\t});\n\t\t}\n\n\t\t// clear all the changes\n\t\tfunction flushChanges() {\n\t\t\tself.changes = [];\n\t\t}\n\n\t\tthis.getChanges = function () {\n\t\t\treturn self.changes;\n\t\t};\n\n\t\tthis.flushChanges = flushChanges;\n\n\t\t/**\n\t\t * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled\n\t\t */\n\t\tfunction insertMeta(obj) {\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!obj.meta) {\n\t\t\t\tobj.meta = {};\n\t\t\t}\n\n\t\t\tobj.meta.created = (new Date()).getTime();\n\t\t\tobj.meta.revision = 0;\n\t\t}\n\n\t\tfunction updateMeta(obj) {\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tobj.meta.updated = (new Date()).getTime();\n\t\t\tobj.meta.revision += 1;\n\t\t}\n\n\t\tfunction createInsertChange(obj) {\n\t\t\tcreateChange(self.name, 'I', obj);\n\t\t}\n\n\t\tfunction createUpdateChange(obj) {\n\t\t\tcreateChange(self.name, 'U', obj);\n\t\t}\n\n\t\tfunction insertMetaWithChange(obj) {\n\t\t\tinsertMeta(obj);\n\t\t\tcreateInsertChange(obj);\n\t\t}\n\n\t\tfunction updateMetaWithChange(obj) {\n\t\t\tupdateMeta(obj);\n\t\t\tcreateUpdateChange(obj);\n\t\t}\n\n\n\t\t/* assign correct handler based on ChangesAPI flag */\n\t\tvar insertHandler, updateHandler;\n\n\t\tfunction setHandlers() {\n\t\t\tinsertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;\n\t\t\tupdateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;\n\t\t}\n\n\t\tsetHandlers();\n\n\t\tthis.setChangesApi = function (enabled) {\n\t\t\tself.disableChangesApi = !enabled;\n\t\t\tsetHandlers();\n\t\t};\n\t\t/**\n\t\t * built-in events\n\t\t */\n\t\tthis.on('insert', function insertCallback(obj) {\n\t\t\tinsertHandler(obj);\n\t\t});\n\n\t\tthis.on('update', function updateCallback(obj) {\n\t\t\tupdateHandler(obj);\n\t\t});\n\n\t\tthis.on('delete', function deleteCallback(obj) {\n\t\t\tif (!self.disableChangesApi) {\n\t\t\t\tcreateChange(self.name, 'R', obj);\n\t\t\t}\n\t\t});\n\n\t\tthis.on('warning', function (warning) {\n\t\t\tself.console.warn(warning);\n\t\t});\n\t\t// for de-serialization purposes\n\t\tflushChanges();\n\n\t\tthis.console = {\n\t\t\tlog: function () {\n\t\t\t},\n\t\t\twarn: function () {\n\t\t\t},\n\t\t\terror: function () {\n\t\t\t},\n\t\t};\n\n\t\t/* ------ STAGING API -------- */\n\t\t/**\n\t\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t\t * manipulated without affecting the data in the original collection\n\t\t */\n\t\tthis.stages = {};\n\t\tthis.commitLog = [];\n\t}\n\n\taddAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n\t}\n\n\tremoveAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.unobserve(object, this.observerCallback);\n\t}\n\n\t/**\n\t * Adds a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {array} transform - an array of transformation 'step' objects to save into the collection\n\t * @memberof Collection\n\t */\n\taddTransform(name, transform) {\n\t\tif (this.transforms.hasOwnProperty(name)) {\n\t\t\tthrow new Error(\"a transform by that name already exists\");\n\t\t}\n\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Updates a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {object} transform - a transformation object to save into collection\n\t * @memberof Collection\n\t */\n\tsetTransform(name, transform) {\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Removes a named collection transform from the collection\n\t * @param {string} name - name of collection transform to remove\n\t * @memberof Collection\n\t */\n\tremoveTransform(name) {\n\t\tdelete this.transforms[name];\n\t}\n\n\tbyExample(template) {\n\t\tvar k, obj, query;\n\t\tquery = [];\n\t\tfor (k in template) {\n\t\t\tif (!template.hasOwnProperty(k)) continue;\n\t\t\tquery.push((\n\t\t\t\tobj = {},\n\t\t\t\t\tobj[k] = template[k],\n\t\t\t\t\tobj\n\t\t\t));\n\t\t}\n\t\treturn {\n\t\t\t'$and': query\n\t\t};\n\t}\n\n\tfindObject(template) {\n\t\treturn this.findOne(this.byExample(template));\n\t}\n\n\tfindObjects(template) {\n\t\treturn this.find(this.byExample(template));\n\t}\n\n\t/*----------------------------+\n\t | TTL daemon                  |\n\t +----------------------------*/\n\tttlDaemonFuncGen() {\n\t\tvar collection = this;\n\t\tvar age = this.ttl.age;\n\t\treturn function ttlDaemon() {\n\t\t\tvar now = Date.now();\n\t\t\tvar toRemove = collection.chain().where(function daemonFilter(member) {\n\t\t\t\tvar timestamp = member.meta.updated || member.meta.created;\n\t\t\t\tvar diff = now - timestamp;\n\t\t\t\treturn age < diff;\n\t\t\t});\n\t\t\ttoRemove.remove();\n\t\t};\n\t}\n\n\tsetTTL(age, interval) {\n\t\tif (age < 0) {\n\t\t\tclearInterval(this.ttl.daemon);\n\t\t} else {\n\t\t\tthis.ttl.age = age;\n\t\t\tthis.ttl.ttlInterval = interval;\n\t\t\tthis.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n\t\t}\n\t}\n\n\t/*----------------------------+\n\t | INDEXING                    |\n\t +----------------------------*/\n\n\t/**\n\t * create a row filter that covers all documents in the collection\n\t */\n\tprepareFullDocIndex() {\n\t\tvar len = this.data.length;\n\t\tvar indexes = new Array(len);\n\t\tfor (var i = 0; i < len; i += 1) {\n\t\t\tindexes[i] = i;\n\t\t}\n\t\treturn indexes;\n\t}\n\n\t/**\n\t * Will allow reconfiguring certain collection options.\n\t * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n\t * @memberof Collection\n\t */\n\tconfigureOptions(options) {\n\t\toptions = options || {};\n\n\t\tif (options.hasOwnProperty('adaptiveBinaryIndices')) {\n\t\t\tthis.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\n\t\t\t// if switching to adaptive binary indices, make sure none are 'dirty'\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\tthis.ensureAllIndexes();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ensure binary index on a certain field\n\t * @param {string} property - name of property to create binary index on\n\t * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n\t * @memberof Collection\n\t */\n\tensureIndex(property, force) {\n\t\t// optional parameter to force rebuild whether flagged as dirty or not\n\t\tif (typeof(force) === 'undefined') {\n\t\t\tforce = false;\n\t\t}\n\n\t\tif (property === null || property === undefined) {\n\t\t\tthrow new Error('Attempting to set index without an associated property');\n\t\t}\n\n\t\tif (this.binaryIndices[property] && !force) {\n\t\t\tif (!this.binaryIndices[property].dirty) return;\n\t\t}\n\n\t\t// if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n\t\tif (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar index = {\n\t\t\t'name': property,\n\t\t\t'dirty': true,\n\t\t\t'values': this.prepareFullDocIndex()\n\t\t};\n\t\tthis.binaryIndices[property] = index;\n\n\t\tvar wrappedComparer =\n\t\t\t(function (p, data) {\n\t\t\t\treturn function (a, b) {\n\t\t\t\t\tvar objAp = data[a][p],\n\t\t\t\t\t\tobjBp = data[b][p];\n\t\t\t\t\tif (objAp !== objBp) {\n\t\t\t\t\t\tif (ltHelper(objAp, objBp, false)) return -1;\n\t\t\t\t\t\tif (gtHelper(objAp, objBp, false)) return 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\t})(property, this.data);\n\n\t\tindex.values.sort(wrappedComparer);\n\t\tindex.dirty = false;\n\n\t\tthis.dirty = true; // for autosave scenarios\n\t}\n\n\tgetSequencedIndexValues(property) {\n\t\tvar idx, idxvals = this.binaryIndices[property].values;\n\t\tvar result = \"\";\n\n\t\tfor (idx = 0; idx < idxvals.length; idx++) {\n\t\t\tresult += \" [\" + idx + \"] \" + this.data[idxvals[idx]][property];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tensureUniqueIndex(field) {\n\t\tvar index = this.constraints.unique[field];\n\t\tif (!index) {\n\t\t\t// keep track of new unique index for regenerate after database (re)load.\n\t\t\tif (this.uniqueNames.indexOf(field) == -1) {\n\t\t\t\tthis.uniqueNames.push(field);\n\t\t\t}\n\t\t}\n\n\t\t// if index already existed, (re)loading it will likely cause collisions, rebuild always\n\t\tthis.constraints.unique[field] = index = new UniqueIndex(field);\n\t\tthis.data.forEach(function (obj) {\n\t\t\tindex.set(obj);\n\t\t});\n\t\treturn index;\n\t}\n\n\t/**\n\t * Ensure all binary indices\n\t */\n\tensureAllIndexes(force) {\n\t\tvar key, bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\tthis.ensureIndex(key, force);\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexesDirty() {\n\t\tvar key, bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\tbIndices[key].dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexDirty(index) {\n\t\tif (this.binaryIndices[index])\n\t\t\tthis.binaryIndices[index].dirty = true;\n\t}\n\n\t/**\n\t * Quickly determine number of documents in collection (or query)\n\t * @param {object=} query - (optional) query object to count results of\n\t * @returns {number} number of documents in the collection\n\t * @memberof Collection\n\t */\n\tcount(query) {\n\t\tif (!query) {\n\t\t\treturn this.data.length;\n\t\t}\n\n\t\treturn this.chain().find(query).filteredrows.length;\n\t}\n\n\t/**\n\t * Rebuild idIndex\n\t */\n\tensureId() {\n\t\tvar len = this.data.length,\n\t\t\ti = 0;\n\n\t\tthis.idIndex = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tthis.idIndex.push(this.data[i].$loki);\n\t\t}\n\t}\n\n\t/**\n\t * Add a dynamic view to the collection\n\t * @param {string} name - name of dynamic view to add\n\t * @param {object=} options - (optional) options to configure dynamic view with\n\t * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t * @returns {DynamicView} reference to the dynamic view added\n\t * @memberof Collection\n\t **/\n\n\taddDynamicView(name, options) {\n\t\tvar dv = new DynamicView(this, name, options);\n\t\tthis.DynamicViews.push(dv);\n\n\t\treturn dv;\n\t}\n\n\t/**\n\t * Remove a dynamic view from the collection\n\t * @param {string} name - name of dynamic view to remove\n\t * @memberof Collection\n\t **/\n\tremoveDynamicView(name) {\n\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\tthis.DynamicViews.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Look up dynamic view reference from within the collection\n\t * @param {string} name - name of dynamic view to retrieve reference of\n\t * @returns {DynamicView} A reference to the dynamic view with that name\n\t * @memberof Collection\n\t **/\n\tgetDynamicView(name) {\n\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\treturn this.DynamicViews[idx];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object and passes all results to an update function.\n\t * For filter function querying you should migrate to [updateWhere()]{@link Collection#updateWhere}.\n\t *\n\t * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tfindAndUpdate(filterObject, updateFunction) {\n\t\tif (typeof(filterObject) === \"function\") {\n\t\t\tthis.updateWhere(filterObject, updateFunction);\n\t\t} else {\n\t\t\tthis.chain().find(filterObject).update(updateFunction);\n\t\t}\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object removes all documents which match that filter.\n\t *\n\t * @param {object} filterObject - 'mongo-like' query object\n\t * @memberof Collection\n\t */\n\tfindAndRemove(filterObject) {\n\t\tthis.chain().find(filterObject).remove();\n\t}\n\n\t/**\n\t * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n\t * @param {(object|array)} doc - the document (or array of documents) to be inserted\n\t * @returns {(object|array)} document or documents inserted\n\t * @memberof Collection\n\t */\n\tinsert(doc) {\n\t\tif (!Array.isArray(doc)) {\n\t\t\treturn this.insertOne(doc);\n\t\t}\n\n\t\t// holder to the clone of the object inserted if collections is set to clone objects\n\t\tvar obj;\n\t\tvar results = [];\n\n\t\tthis.emit('pre-insert', doc);\n\t\tfor (var i = 0, len = doc.length; i < len; i++) {\n\t\t\tobj = this.insertOne(doc[i], true);\n\t\t\tif (!obj) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tresults.push(obj);\n\t\t}\n\t\tthis.emit('insert', doc);\n\t\treturn results.length === 1 ? results[0] : results;\n\t}\n\n\t/**\n\t * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n\t * @param {object} doc - the document to be inserted\n\t * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n\t * @returns {object} document or 'undefined' if there was a problem inserting it\n\t * @memberof Collection\n\t */\n\tinsertOne(doc, bulkInsert) {\n\t\tvar err = null;\n\t\tvar returnObj;\n\n\t\tif (typeof doc !== 'object') {\n\t\t\terr = new TypeError('Document needs to be an object');\n\t\t} else if (doc === null) {\n\t\t\terr = new TypeError('Object cannot be null');\n\t\t}\n\n\t\tif (err !== null) {\n\t\t\tthis.emit('error', err);\n\t\t\tthrow err;\n\t\t}\n\n\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\tvar obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n\t\tif (typeof obj.meta === 'undefined') {\n\t\t\tobj.meta = {\n\t\t\t\trevision: 0,\n\t\t\t\tcreated: 0\n\t\t\t};\n\t\t}\n\n\t\t// allow pre-insert to modify actual collection reference even if cloning\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('pre-insert', obj);\n\t\t}\n\t\tif (!this.add(obj)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// if cloning, give user back clone of 'cloned' object with $loki and meta\n\t\treturnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\n\t\tthis.addAutoUpdateObserver(returnObj);\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('insert', returnObj);\n\t\t}\n\t\treturn returnObj;\n\t}\n\n\t/**\n\t * Empties the collection.\n\t * @param {object=} options - configure clear behavior\n\t * @param {bool=} options.removeIndices - (default: false)\n\t * @memberof Collection\n\t */\n\tclear(options) {\n\t\tvar self = this;\n\n\t\toptions = options || {};\n\n\t\tthis.data = [];\n\t\tthis.idIndex = [];\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\t\tthis.maxId = 0;\n\t\tthis.DynamicViews = [];\n\t\tthis.dirty = true;\n\n\t\t// if removing indices entirely\n\t\tif (options.removeIndices === true) {\n\t\t\tthis.binaryIndices = {};\n\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\t\t\tthis.uniqueNames = [];\n\t\t}\n\t\t// clear indices but leave definitions in place\n\t\telse {\n\t\t\t// clear binary indices\n\t\t\tvar keys = Object.keys(this.binaryIndices);\n\t\t\tkeys.forEach(function (biname) {\n\t\t\t\tself.binaryIndices[biname].dirty = false;\n\t\t\t\tself.binaryIndices[biname].values = [];\n\t\t\t});\n\n\t\t\t// clear entire unique indices definition\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\n\t\t\t// add definitions back\n\t\t\tthis.uniqueNames.forEach(function (uiname) {\n\t\t\t\tself.ensureUniqueIndex(uiname);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Updates an object and notifies collection that the document has changed.\n\t * @param {object} doc - document to update within the collection\n\t * @memberof Collection\n\t */\n\tupdate(doc) {\n\t\tif (Array.isArray(doc)) {\n\t\t\tvar k = 0,\n\t\t\t\tlen = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.update(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify object is a properly formed document\n\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\tthrow new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n\t\t}\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tvar arr = this.get(doc.$loki, true),\n\t\t\t\toldInternal, // ref to existing obj\n\t\t\t\tnewInternal, // ref to new internal obj\n\t\t\t\tposition,\n\t\t\t\tself = this;\n\n\t\t\tif (!arr) {\n\t\t\t\tthrow new Error('Trying to update a document not in collection.');\n\t\t\t}\n\n\t\t\toldInternal = arr[0]; // -internal- obj ref\n\t\t\tposition = arr[1]; // position in data array\n\n\t\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\t\tnewInternal = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n\t\t\tthis.emit('pre-update', doc);\n\n\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\tself.constraints.unique[key].update(oldInternal, newInternal);\n\t\t\t});\n\n\t\t\t// operate the update\n\t\t\tthis.data[position] = newInternal;\n\n\t\t\tif (newInternal !== doc) {\n\t\t\t\tthis.addAutoUpdateObserver(doc);\n\t\t\t}\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].evaluateDocument(position, false);\n\t\t\t}\n\n\t\t\tvar key;\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexUpdate(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.idIndex[position] = newInternal.$loki;\n\t\t\t//this.flagBinaryIndexesDirty();\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\tthis.emit('update', doc, this.cloneObjects ? clone(oldInternal, this.cloneMethod) : null);\n\t\t\treturn doc;\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Add object to collection\n\t */\n\tadd(obj) {\n\t\t// if parameter isn't object exit with throw\n\t\tif ('object' !== typeof obj) {\n\t\t\tthrow new TypeError('Object being added needs to be an object');\n\t\t}\n\t\t// if object you are adding already has id column it is either already in the collection\n\t\t// or the object is carrying its own 'id' property.  If it also has a meta property,\n\t\t// then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n\t\tif (typeof(obj.$loki) !== 'undefined') {\n\t\t\tthrow new Error('Document is already in collection, please use update()');\n\t\t}\n\n\t\t/*\n\t\t * try adding object to collection\n\t\t */\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tthis.maxId++;\n\n\t\t\tif (isNaN(this.maxId)) {\n\t\t\t\tthis.maxId = (this.data[this.data.length - 1].$loki + 1);\n\t\t\t}\n\n\t\t\tobj.$loki = this.maxId;\n\t\t\tobj.meta.version = 0;\n\n\t\t\tvar key, constrUnique = this.constraints.unique;\n\t\t\tfor (key in constrUnique) {\n\t\t\t\tif (hasOwnProperty.call(constrUnique, key)) {\n\t\t\t\t\tconstrUnique[key].set(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add new obj id to idIndex\n\t\t\tthis.idIndex.push(obj.$loki);\n\n\t\t\t// add the object\n\t\t\tthis.data.push(obj);\n\n\t\t\tvar addedPos = this.data.length - 1;\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tvar dvlen = this.DynamicViews.length;\n\t\t\tfor (var i = 0; i < dvlen; i++) {\n\t\t\t\tthis.DynamicViews[i].evaluateDocument(addedPos, true);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexInsert(addedPos, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\treturn (this.cloneObjects) ? (clone(obj, this.cloneMethod)) : (obj);\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Applies a filter function and passes all results to an update function.\n\t *\n\t * @param {function} filterFunction - filter function whose results will execute update\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tupdateWhere(filterFunction, updateFunction) {\n\t\tvar results = this.where(filterFunction),\n\t\t\ti = 0,\n\t\t\tobj;\n\t\ttry {\n\t\t\tfor (i; i < results.length; i++) {\n\t\t\t\tobj = updateFunction(results[i]);\n\t\t\t\tthis.update(obj);\n\t\t\t}\n\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t}\n\t}\n\n\t/**\n\t * Remove all documents matching supplied filter function.\n\t * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n\t * @param {function|object} query - query object to filter on\n\t * @memberof Collection\n\t */\n\tremoveWhere(query) {\n\t\tvar list;\n\t\tif (typeof query === 'function') {\n\t\t\tlist = this.data.filter(query);\n\t\t\tthis.remove(list);\n\t\t} else {\n\t\t\tthis.chain().find(query).remove();\n\t\t}\n\t}\n\n\tremoveDataOnly() {\n\t\tthis.remove(this.data.slice());\n\t}\n\n\t/**\n\t * Remove a document from the collection\n\t * @param {object} doc - document to remove from collection\n\t * @memberof Collection\n\t */\n\tremove(doc) {\n\t\tif (typeof doc === 'number') {\n\t\t\tdoc = this.get(doc);\n\t\t}\n\n\t\tif ('object' !== typeof doc) {\n\t\t\tthrow new Error('Parameter is not an object');\n\t\t}\n\t\tif (Array.isArray(doc)) {\n\t\t\tvar k = 0,\n\t\t\t\tlen = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.remove(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\tthrow new Error('Object is not a document stored in the collection');\n\t\t}\n\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tvar arr = this.get(doc.$loki, true),\n\t\t\t\t// obj = arr[0],\n\t\t\t\tposition = arr[1];\n\t\t\tvar self = this;\n\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\tif (doc[key] !== null && typeof doc[key] !== 'undefined') {\n\t\t\t\t\tself.constraints.unique[key].remove(doc[key]);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to remove\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].removeDocument(position);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar key, bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexRemove(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.data.splice(position, 1);\n\t\t\tthis.removeAutoUpdateObserver(doc);\n\n\t\t\t// remove id from idIndex\n\t\t\tthis.idIndex.splice(position, 1);\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\t\t\tthis.emit('delete', arr[0]);\n\t\t\tdelete doc.$loki;\n\t\t\tdelete doc.meta;\n\t\t\treturn doc;\n\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/*---------------------+\n\t | Finding methods     |\n\t +----------------------*/\n\n\t/**\n\t * Get by Id - faster than other methods because of the searching algorithm\n\t * @param {int} id - $loki id of document you want to retrieve\n\t * @param {boolean} returnPosition - if 'true' we will return [object, position]\n\t * @returns {(object|array|null)} Object reference if document was found, null if not,\n\t *     or an array if 'returnPosition' was passed.\n\t * @memberof Collection\n\t */\n\tget(id, returnPosition) {\n\t\tvar retpos = returnPosition || false,\n\t\t\tdata = this.idIndex,\n\t\t\tmax = data.length - 1,\n\t\t\tmin = 0,\n\t\t\tmid = (min + max) >> 1;\n\n\t\tid = typeof id === 'number' ? id : parseInt(id, 10);\n\n\t\tif (isNaN(id)) {\n\t\t\tthrow new TypeError('Passed id is not an integer');\n\t\t}\n\n\t\twhile (data[min] < data[max]) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (data[mid] < id) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tif (max === min && data[min] === id) {\n\t\t\tif (retpos) {\n\t\t\t\treturn [this.data[min], min];\n\t\t\t}\n\t\t\treturn this.data[min];\n\t\t}\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n\t *    Since multiple documents may contain the same value (which the index is sorted on),\n\t *    we hone in on range and then linear scan range to find exact index array position.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tgetBinaryIndexPosition(dataPosition, binaryIndexName) {\n\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\n\t\t// i think calculateRange can probably be moved to collection\n\t\t// as it doesn't seem to need resultset.  need to verify\n\t\t//var rs = new Resultset(this, null, null);\n\t\tvar range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n\t\tif (range[0] === 0 && range[1] === -1) {\n\t\t\t// uhoh didn't find range\n\t\t\treturn null;\n\t\t}\n\n\t\tvar min = range[0];\n\t\tvar max = range[1];\n\n\t\t// narrow down the sub-segment of index values\n\t\t// where the indexed property value exactly matches our\n\t\t// value and then linear scan to find exact -index- position\n\t\tfor (var idx = min; idx <= max; idx++) {\n\t\t\tif (index[idx] === dataPosition) return idx;\n\t\t}\n\n\t\t// uhoh\n\t\treturn null;\n\t}\n\n\t/**\n\t * Adaptively insert a selected item to the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexInsert(dataPosition, binaryIndexName) {\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\t//var rs = new Resultset(this, null, null);\n\t\tvar idxPos = this.calculateRangeStart(binaryIndexName, val);\n\n\t\t// insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n\t\t// doing this after adjusting dataPositions so no clash with previous item at that position.\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n\t}\n\n\t/**\n\t * Adaptively update a selected item within an index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexUpdate(dataPosition, binaryIndexName) {\n\t\t// linear scan needed to find old position within index unless we optimize for clone scenarios later\n\t\t// within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n\t\tvar idxPos,\n\t\t\tindex = this.binaryIndices[binaryIndexName].values,\n\t\t\tlen = index.length;\n\n\t\tfor (idxPos = 0; idxPos < len; idxPos++) {\n\t\t\tif (index[idxPos] === dataPosition) break;\n\t\t}\n\n\t\t//var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t//this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n\t\tthis.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n\t}\n\n\t/**\n\t * Adaptively remove a selected item from the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexRemove(dataPosition, binaryIndexName, removedFromIndexOnly) {\n\t\tvar idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\tvar len,\n\t\t\tidx;\n\n\t\tif (idxPos === null) {\n\t\t\t// throw new Error('unable to determine binary index position');\n\t\t\treturn null;\n\t\t}\n\n\t\t// remove document from index\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t// if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n\t\t// in which case data positions stay the same.\n\t\tif (removedFromIndexOnly === true) {\n\t\t\treturn;\n\t\t}\n\n\t\t// since index stores data array positions, if we remove a document\n\t\t// we need to adjust array positions -1 for all document positions greater than removed position\n\t\tlen = index.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tif (index[idx] > dataPosition) {\n\t\t\t\tindex[idx]--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method used for index maintenance.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the proper location where it can be added.\n\t */\n\tcalculateRangeStart(prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(rcd[index[mid]][prop], val, false)) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tvar lbound = min;\n\n\t\tif (ltHelper(rcd[index[lbound]][prop], val, false)) {\n\t\t\treturn lbound + 1;\n\t\t} else {\n\t\t\treturn lbound;\n\t\t}\n\t}\n\n\t/**\n\t * Internal method used for indexed $between.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the final position of that upper range value.\n\t */\n\tcalculateRangeEnd(prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(val, rcd[index[mid]][prop], false)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tvar ubound = max;\n\n\t\tif (gtHelper(rcd[index[ubound]][prop], val, false)) {\n\t\t\treturn ubound - 1;\n\t\t} else {\n\t\t\treturn ubound;\n\t\t}\n\t}\n\n\t/**\n\t * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n\t *    this is used for collection.find() and first find filter of resultset/dynview\n\t *    slightly different than get() binary search in that get() hones in on 1 value,\n\t *    but we have to hone in on many (range)\n\t * @param {string} op - operation, such as $eq\n\t * @param {string} prop - name of property to calculate range for\n\t * @param {object} val - value to use for range calculation.\n\t * @returns {array} [start, end] index array positions\n\t */\n\tcalculateRange(op, prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\t// when no documents are in collection, return empty range condition\n\t\tif (rcd.length === 0) {\n\t\t\treturn [0, -1];\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// if value falls outside of our range return [0, -1] to designate no results\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\tcase '$aeq':\n\t\t\t\tif (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$dteq':\n\t\t\t\tif (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gt':\n\t\t\t\tif (gtHelper(val, maxVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gte':\n\t\t\t\tif (gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lt':\n\t\t\t\tif (ltHelper(val, minVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (ltHelper(maxVal, val, false)) {\n\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lte':\n\t\t\t\tif (ltHelper(val, minVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (ltHelper(maxVal, val, true)) {\n\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$between':\n\t\t\t\treturn ([this.calculateRangeStart(prop, val[0]), this.calculateRangeEnd(prop, val[1])]);\n\t\t\tcase '$in':\n\t\t\t\tvar idxset = [],\n\t\t\t\t\tsegResult = [];\n\t\t\t\t// query each value '$eq' operator and merge the seqment results.\n\t\t\t\tfor (var j = 0, len = val.length; j < len; j++) {\n\t\t\t\t\tvar seg = this.calculateRange('$eq', prop, val[j]);\n\n\t\t\t\t\tfor (var i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\tif (idxset[i] === undefined) {\n\t\t\t\t\t\t\tidxset[i] = true;\n\t\t\t\t\t\t\tsegResult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn segResult;\n\t\t}\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(rcd[index[mid]][prop], val, false)) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tvar lbound = min;\n\n\t\t// do not reset min, as the upper bound cannot be prior to the found low bound\n\t\tmax = index.length - 1;\n\n\t\t// hone in on end position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(val, rcd[index[mid]][prop], false)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tvar ubound = max;\n\n\t\tvar lval = rcd[index[lbound]][prop];\n\t\tvar uval = rcd[index[ubound]][prop];\n\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\t\tif (lval !== val) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (uval !== val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, ubound];\n\t\t\tcase '$dteq':\n\t\t\t\tif (lval > val || lval < val) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (uval > val || uval < val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, ubound];\n\n\n\t\t\tcase '$gt':\n\t\t\t\tif (ltHelper(uval, val, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\treturn [ubound, rcd.length - 1];\n\n\t\t\tcase '$gte':\n\t\t\t\tif (ltHelper(lval, val, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, rcd.length - 1];\n\n\t\t\tcase '$lt':\n\t\t\t\tif (lbound === 0 && ltHelper(lval, val, false)) {\n\t\t\t\t\treturn [0, 0];\n\t\t\t\t}\n\t\t\t\treturn [0, lbound - 1];\n\n\t\t\tcase '$lte':\n\t\t\t\tif (uval !== val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\tif (ubound === 0 && ltHelper(uval, val, false)) {\n\t\t\t\t\treturn [0, 0];\n\t\t\t\t}\n\t\t\t\treturn [0, ubound];\n\n\t\t\tdefault:\n\t\t\t\treturn [0, rcd.length - 1];\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve doc by Unique index\n\t * @param {string} field - name of uniquely indexed property to use when doing lookup\n\t * @param {value} value - unique value to search for\n\t * @returns {object} document matching the value passed\n\t * @memberof Collection\n\t */\n\tby(field, value) {\n\t\tvar self;\n\t\tif (value === undefined) {\n\t\t\tself = this;\n\t\t\treturn function (value) {\n\t\t\t\treturn self.by(field, value);\n\t\t\t};\n\t\t}\n\n\t\tvar result = this.constraints.unique[field].get(value);\n\t\tif (!this.cloneObjects) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn clone(result, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Find one object by index property, by property equal to value\n\t * @param {object} query - query object used to perform search with\n\t * @returns {(object|null)} First matching document, or null if none\n\t * @memberof Collection\n\t */\n\tfindOne(query) {\n\t\tquery = query || {};\n\n\t\t// Instantiate Resultset and exec find op passing firstOnly = true param\n\t\tvar result = new Resultset(this, {\n\t\t\tqueryObj: query,\n\t\t\tfirstOnly: true\n\t\t});\n\n\t\tif (Array.isArray(result) && result.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif (!this.cloneObjects) {\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn clone(result, this.cloneMethod);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Chain method, used for beginning a series of chained find() and/or view() operations\n\t * on a collection.\n\t *\n\t * @param {array} transform - Ordered array of transform step objects similar to chain\n\t * @param {object} parameters - Object containing properties representing parameters to substitute\n\t * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n\t * @memberof Collection\n\t */\n\tchain(transform, parameters) {\n\t\tvar rs = new Resultset(this);\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t}\n\n\t/**\n\t * Find method, api is similar to mongodb.\n\t * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n\t * @example {@tutorial Query Examples}\n\t * @param {object} query - 'mongo-like' query object\n\t * @returns {array} Array of matching documents\n\t * @memberof Collection\n\t */\n\tfind(query) {\n\t\tif (typeof(query) === 'undefined') {\n\t\t\tquery = 'getAll';\n\t\t}\n\n\t\tvar results = new Resultset(this, {\n\t\t\tqueryObj: query\n\t\t});\n\t\tif (!this.cloneObjects) {\n\t\t\treturn results;\n\t\t} else {\n\t\t\treturn cloneObjectArray(results, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Find object by unindexed field by property equal to value,\n\t * simply iterates and returns the first element matching the query\n\t */\n\tfindOneUnindexed(prop, value) {\n\t\tvar i = this.data.length,\n\t\t\tdoc;\n\t\twhile (i--) {\n\t\t\tif (this.data[i][prop] === value) {\n\t\t\t\tdoc = this.data[i];\n\t\t\t\treturn doc;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Transaction methods\n\t */\n\n\t/** start the transation */\n\tstartTransaction() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = clone(this.data, this.cloneMethod);\n\t\t\tthis.cachedIndex = this.idIndex;\n\t\t\tthis.cachedBinaryIndex = this.binaryIndices;\n\n\t\t\t// propagate startTransaction to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].startTransaction();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** commit the transation */\n\tcommit() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = null;\n\t\t\tthis.cachedIndex = null;\n\t\t\tthis.cachedBinaryIndex = null;\n\n\t\t\t// propagate commit to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].commit();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** roll back the transation */\n\trollback() {\n\t\tif (this.transactional) {\n\t\t\tif (this.cachedData !== null && this.cachedIndex !== null) {\n\t\t\t\tthis.data = this.cachedData;\n\t\t\t\tthis.idIndex = this.cachedIndex;\n\t\t\t\tthis.binaryIndices = this.cachedBinaryIndex;\n\t\t\t}\n\n\t\t\t// propagate rollback to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].rollback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query the collection by supplying a javascript filter function.\n\t * @example\n\t * var results = coll.where(function(obj) {\n\t *   return obj.legs === 8;\n\t * });\n\t *\n\t * @param {function} fun - filter function to run against all collection docs\n\t * @returns {array} all documents which pass your filter function\n\t * @memberof Collection\n\t */\n\twhere(fun) {\n\t\tvar results = new Resultset(this, {\n\t\t\tqueryFunc: fun\n\t\t});\n\t\tif (!this.cloneObjects) {\n\t\t\treturn results;\n\t\t} else {\n\t\t\treturn cloneObjectArray(results, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Map Reduce operation\n\t *\n\t * @param {function} mapFunction - function to use as map function\n\t * @param {function} reduceFunction - function to use as reduce function\n\t * @returns {data} The result of your mapReduce operation\n\t * @memberof Collection\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data.map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Join two collections on specified properties\n\t *\n\t * @param {array} joinData - array of documents to 'join' to this collection\n\t * @param {string} leftJoinProp - property name in collection\n\t * @param {string} rightJoinProp - property name in joinData\n\t * @param {function=} mapFun - (Optional) map function to use\n\t * @returns {Resultset} Result of the mapping operation\n\t * @memberof Collection\n\t */\n\teqJoin(joinData, leftJoinProp, rightJoinProp, mapFun) {\n\t\t// logic in Resultset class\n\t\treturn new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);\n\t}\n\n\t/* ------ STAGING API -------- */\n\t/**\n\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t * manipulated without affecting the data in the original collection\n\t */\n\n\n\t/**\n\t * (Staging API) create a stage and/or retrieve it\n\t * @memberof Collection\n\t */\n\tgetStage(name) {\n\t\tif (!this.stages[name]) {\n\t\t\tthis.stages[name] = {};\n\t\t}\n\t\treturn this.stages[name];\n\t}\n\n\t/**\n\t * a collection of objects recording the changes applied through a commmitStage\n\t */\n\n\t/**\n\t * (Staging API) create a copy of an object and insert it into a stage\n\t * @memberof Collection\n\t */\n\tstage(stageName, obj) {\n\t\tvar copy = JSON.parse(JSON.stringify(obj));\n\t\tthis.getStage(stageName)[obj.$loki] = copy;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n\t * then create a message to be inserted in the commitlog\n\t * @param {string} stageName - name of stage\n\t * @param {string} message\n\t * @memberof Collection\n\t */\n\tcommitStage(stageName, message) {\n\t\tvar stage = this.getStage(stageName),\n\t\t\tprop,\n\t\t\ttimestamp = new Date().getTime();\n\n\t\tfor (prop in stage) {\n\n\t\t\tthis.update(stage[prop]);\n\t\t\tthis.commitLog.push({\n\t\t\t\ttimestamp: timestamp,\n\t\t\t\tmessage: message,\n\t\t\t\tdata: JSON.parse(JSON.stringify(stage[prop]))\n\t\t\t});\n\t\t}\n\t\tthis.stages[stageName] = {};\n\t}\n\n\tno_op() {\n\t\treturn;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textract(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tisDotNotation = isDeepProperty(field),\n\t\t\tresult = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tresult.push(deepProperty(this.data[i], field, isDotNotation));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmax(field) {\n\t\treturn Math.max.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmin(field) {\n\t\treturn Math.min.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmaxRecord(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tdeep = isDeepProperty(field),\n\t\t\tresult = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\tmax;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (max !== undefined) {\n\t\t\t\tif (max < deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = max;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tminRecord(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tdeep = isDeepProperty(field),\n\t\t\tresult = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\tmin;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (min !== undefined) {\n\t\t\t\tif (min > deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = min;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textractNumerical(field) {\n\t\treturn this.extract(field).map(parseBase10).filter(Number).filter(function (n) {\n\t\t\treturn !(isNaN(n));\n\t\t});\n\t}\n\n\t/**\n\t * Calculates the average numerical value of a property\n\t *\n\t * @param {string} field - name of property in docs to average\n\t * @returns {number} average of property in all docs in the collection\n\t * @memberof Collection\n\t */\n\tavg(field) {\n\t\treturn average(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * Calculate standard deviation of a field\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tstdDev(field) {\n\t\treturn standardDeviation(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tmode(field) {\n\t\tvar dict = {},\n\t\t\tdata = this.extract(field);\n\t\tdata.forEach(function (obj) {\n\t\t\tif (dict[obj]) {\n\t\t\t\tdict[obj] += 1;\n\t\t\t} else {\n\t\t\t\tdict[obj] = 1;\n\t\t\t}\n\t\t});\n\t\tvar max,\n\t\t\tprop, mode;\n\t\tfor (prop in dict) {\n\t\t\tif (max) {\n\t\t\t\tif (max < dict[prop]) {\n\t\t\t\t\tmode = prop;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmode = prop;\n\t\t\t\tmax = dict[prop];\n\t\t\t}\n\t\t}\n\t\treturn mode;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field - property name\n\t */\n\tmedian(field) {\n\t\tvar values = this.extractNumerical(field);\n\t\tvalues.sort(sub);\n\n\t\tvar half = Math.floor(values.length / 2);\n\n\t\tif (values.length % 2) {\n\t\t\treturn values[half];\n\t\t} else {\n\t\t\treturn (values[half - 1] + values[half]) / 2.0;\n\t\t}\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/collection.js","export class UniqueIndex {\n\n\tconstructor(uniqueField) {\n\t\tthis.field = uniqueField;\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t}\n\n\tset(obj) {\n\t\tvar fieldValue = obj[this.field];\n\t\tif (fieldValue !== null && typeof(fieldValue) !== 'undefined') {\n\t\t\tif (this.keyMap[fieldValue]) {\n\t\t\t\tthrow new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n\t\t\t} else {\n\t\t\t\tthis.keyMap[fieldValue] = obj;\n\t\t\t\tthis.lokiMap[obj.$loki] = fieldValue;\n\t\t\t}\n\t\t}\n\t};\n\n\tget(key) {\n\t\tconsole.log(key);\n\t\treturn this.keyMap[key];\n\t};\n\n\tbyId(id) {\n\t\tconsole.log(\"byId\", key);\n\t\treturn this.keyMap[this.lokiMap[id]];\n\t};\n\n\t/**\n\t * Updates a document's unique index given an updated object.\n\t * @param  {Object} obj Original document object\n\t * @param  {Object} doc New document object (likely the same as obj)\n\t */\n\tupdate(obj, doc) {\n\t\tif (this.lokiMap[obj.$loki] !== doc[this.field]) {\n\t\t\tvar old = this.lokiMap[obj.$loki];\n\t\t\tthis.set(doc);\n\t\t\t// make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n\t\t\tthis.keyMap[old] = undefined;\n\t\t} else {\n\t\t\tthis.keyMap[obj[this.field]] = doc;\n\t\t}\n\t};\n\tremove(key) {\n\t\tvar obj = this.keyMap[key];\n\t\tif (obj !== null && typeof obj !== 'undefined') {\n\t\t\tthis.keyMap[key] = undefined;\n\t\t\tthis.lokiMap[obj.$loki] = undefined;\n\t\t} else {\n\t\t\tthrow new Error('Key is not in unique index: ' + this.field);\n\t\t}\n\t};\n\tclear() {\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/unique_index.js","export class ExactIndex {\n\n\tconstructor(exactField) {\n\t\tthis.index = {};\n\t\tthis.field = exactField;\n\t}\n\n\t// add the value you want returned to the key in the index\n\tset(key, val) {\n\t\tif (this.index[key]) {\n\t\t\tthis.index[key].push(val);\n\t\t} else {\n\t\t\tthis.index[key] = [val];\n\t\t}\n\t\tconsole.log(\"?\")\n\t}\n\n\t// remove the value from the index, if the value was the last one, remove the key\n\tremove(key, val) {\n\t\tvar idxSet = this.index[key];\n\t\tfor (var i in idxSet) {\n\t\t\tif (idxSet[i] == val) {\n\t\t\t\tidxSet.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\tif (idxSet.length < 1) {\n\t\t\tthis.index[key] = undefined;\n\t\t}\n\t}\n\n\t// get the values related to the key, could be more than one\n\tget(key) {\n\t\tconsole.log(\"!\")\n\t\treturn this.index[key];\n\t}\n\n\t// clear will zap the index\n\tclear(key) {\n\t\tthis.index = {};\n\t}\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/exact_index.js","import {LokiEventEmitter} from './event_emitter';\nimport {clone} from './clone'\nimport {Collection} from './collection'\nimport {Utils} from './utils'\nimport {ltHelper, gtHelper} from './helper'\n\nfunction containsCheckFn(a) {\n\tif (typeof a === 'string' || Array.isArray(a)) {\n\t\treturn function(b) {\n\t\t\treturn a.indexOf(b) !== -1;\n\t\t};\n\t} else if (typeof a === 'object' && a !== null) {\n\t\treturn function(b) {\n\t\t\treturn hasOwnProperty.call(a, b);\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction doQueryOp(val, op) {\n\tfor (var p in op) {\n\t\tif (hasOwnProperty.call(op, p)) {\n\t\t\treturn LokiOps[p](val, op[p]);\n\t\t}\n\t}\n\treturn false;\n}\n\n\nexport var LokiOps = {\n\t// comparison operators\n\t// a is the value in the collection\n\t// b is the query value\n\t$eq: function(a, b) {\n\t\treturn a === b;\n\t},\n\n\t// abstract/loose equality\n\t$aeq: function(a, b) {\n\t\treturn a == b;\n\t},\n\n\t$ne: function(a, b) {\n\t\t// ecma 5 safe test for NaN\n\t\tif (b !== b) {\n\t\t\t// ecma 5 test value is not NaN\n\t\t\treturn (a === a);\n\t\t}\n\n\t\treturn a !== b;\n\t},\n\n\t$dteq: function(a, b) {\n\t\tif (ltHelper(a, b, false)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !gtHelper(a, b, false);\n\t},\n\n\t$gt: function(a, b) {\n\t\treturn gtHelper(a, b, false);\n\t},\n\n\t$gte: function(a, b) {\n\t\treturn gtHelper(a, b, true);\n\t},\n\n\t$lt: function(a, b) {\n\t\treturn ltHelper(a, b, false);\n\t},\n\n\t$lte: function(a, b) {\n\t\treturn ltHelper(a, b, true);\n\t},\n\n\t// ex : coll.find({'orderCount': {$between: [10, 50]}});\n\t$between: function(a, vals) {\n\t\tif (a === undefined || a === null) return false;\n\t\treturn (gtHelper(a, vals[0], true) && ltHelper(a, vals[1], true));\n\t},\n\n\t$in: function(a, b) {\n\t\treturn b.indexOf(a) !== -1;\n\t},\n\n\t$nin: function(a, b) {\n\t\treturn b.indexOf(a) === -1;\n\t},\n\n\t$keyin: function(a, b) {\n\t\treturn a in b;\n\t},\n\n\t$nkeyin: function(a, b) {\n\t\treturn !(a in b);\n\t},\n\n\t$definedin: function(a, b) {\n\t\treturn b[a] !== undefined;\n\t},\n\n\t$undefinedin: function(a, b) {\n\t\treturn b[a] === undefined;\n\t},\n\n\t$regex: function(a, b) {\n\t\treturn b.test(a);\n\t},\n\n\t$containsString: function(a, b) {\n\t\treturn (typeof a === 'string') && (a.indexOf(b) !== -1);\n\t},\n\n\t$containsNone: function(a, b) {\n\t\treturn !LokiOps.$containsAny(a, b);\n\t},\n\n\t$containsAny: function(a, b) {\n\t\tvar checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$contains: function(a, b) {\n\t\tvar checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$type: function(a, b) {\n\t\tvar type = typeof a;\n\t\tif (type === 'object') {\n\t\t\tif (Array.isArray(a)) {\n\t\t\t\ttype = 'array';\n\t\t\t} else if (a instanceof Date) {\n\t\t\t\ttype = 'date';\n\t\t\t}\n\t\t}\n\t\treturn (typeof b !== 'object') ? (type === b) : doQueryOp(type, b);\n\t},\n\n\t$size: function(a, b) {\n\t\tif (Array.isArray(a)) {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$len: function(a, b) {\n\t\tif (typeof a === 'string') {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$where: function(a, b) {\n\t\treturn b(a) === true;\n\t},\n\n\t// field-level logical operators\n\t// a is the value in the collection\n\t// b is the nested query operation (for '$not')\n\t//   or an array of nested query operations (for '$and' and '$or')\n\t$not: function(a, b) {\n\t\treturn !doQueryOp(a, b);\n\t},\n\n\t$and: function(a, b) {\n\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (!doQueryOp(a, b[idx])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t$or: function(a, b) {\n\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (doQueryOp(a, b[idx])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\n// making indexing opt-in... our range function knows how to deal with these ops :\nvar indexedOpsList = ['$eq', '$aeq', '$dteq', '$gt', '$gte', '$lt', '$lte', '$in', '$between'];\n\n\nfunction sortHelper(prop1, prop2, desc) {\n\tif (prop1 === prop2) {\n\t\treturn 0;\n\t}\n\n\tif (ltHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (1) : (-1);\n\t}\n\n\tif (gtHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (-1) : (1);\n\t}\n\n\t// not lt, not gt so implied equality-- date compatible\n\treturn 0;\n}\n\n/**\n * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n *\n * @param {array} properties - array of property names, in order, by which to evaluate sort order\n * @param {object} obj1 - first object to compare\n * @param {object} obj2 - second object to compare\n * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n */\nfunction compoundeval(properties, obj1, obj2) {\n\tvar res = 0;\n\tvar prop, field;\n\tfor (var i = 0, len = properties.length; i < len; i++) {\n\t\tprop = properties[i];\n\t\tfield = prop[0];\n\t\tres = sortHelper(obj1[field], obj2[field], prop[1]);\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n/**\n * dotSubScan - helper function used for dot notation queries.\n *\n * @param {object} root - object to traverse\n * @param {array} paths - array of properties to drill into\n * @param {function} fun - evaluation function to test with\n * @param {any} value - comparative value to also pass to (compare) fun\n * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n */\nfunction dotSubScan(root, paths, fun, value, poffset) {\n\tvar pathOffset = poffset || 0;\n\tvar path = paths[pathOffset];\n\tif (root === undefined || root === null || !hasOwnProperty.call(root, path)) {\n\t\treturn false;\n\t}\n\n\tvar valueFound = false;\n\tvar element = root[path];\n\tif (pathOffset + 1 >= paths.length) {\n\t\t// if we have already expanded out the dot notation,\n\t\t// then just evaluate the test function and value on the element\n\t\tvalueFound = fun(element, value);\n\t} else if (Array.isArray(element)) {\n\t\tfor (var index = 0, len = element.length; index < len; index += 1) {\n\t\t\tvalueFound = dotSubScan(element[index], paths, fun, value, pathOffset + 1);\n\t\t\tif (valueFound === true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvalueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);\n\t}\n\n\treturn valueFound;\n}\n\n/*\n'Utils' is not defined                 no-undef\tx\n'sortHelper' is not defined            no-undef\n'compoundeval' is not defined          no-undef\n'indexedOpsList' is not defined        no-undef\n'LokiOps' is not defined               no-undef\n'dotSubScan' is not defined            no-undef\n'clone' is not defined                 no-undef\n */\n\n/**\n * Resultset class allowing chainable queries.  Intended to be instanced internally.\n *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n *\n * @example\n *    mycollection.chain()\n *      .find({ 'doors' : 4 })\n *      .where(function(obj) { return obj.name === 'Toyota' })\n *      .data();\n *\n * @constructor Resultset\n * @param {Collection} collection - The collection which this Resultset will query against.\n * @param {Object=} options - Object containing one or more options.\n * @param {string} options.queryObj - Optional mongo-style query object to initialize resultset with.\n * @param {function} options.queryFunc - Optional javascript filter function to initialize resultset with.\n * @param {bool} options.firstOnly - Optional boolean used by collection.findOne().\n */\nexport class Resultset {\n\n\tconstructor(collection, options) {\n\t\toptions = options || {};\n\n\t\toptions.queryObj = options.queryObj || null;\n\t\toptions.queryFunc = options.queryFunc || null;\n\t\toptions.firstOnly = options.firstOnly || false;\n\n\t\t// retain reference to collection we are querying against\n\t\tthis.collection = collection;\n\n\t\t// if chain() instantiates with null queryObj and queryFunc, so we will keep flag for later\n\t\tthis.searchIsChained = (!options.queryObj && !options.queryFunc);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\t// if user supplied initial queryObj or queryFunc, apply it\n\t\tif (typeof(options.queryObj) !== \"undefined\" && options.queryObj !== null) {\n\t\t\treturn this.find(options.queryObj, options.firstOnly);\n\t\t}\n\t\tif (typeof(options.queryFunc) !== \"undefined\" && options.queryFunc !== null) {\n\t\t\treturn this.where(options.queryFunc);\n\t\t}\n\n\t\t// otherwise return unfiltered Resultset for future filtering\n\t\treturn this;\n\t}\n\n\t/**\n\t * reset() - Reset the resultset to its initial state.\n\t *\n\t * @returns {Resultset} Reference to this resultset, for future chain operations.\n\t */\n\treset() {\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tthis.filteredrows = [];\n\t\t}\n\t\tthis.filterInitialized = false;\n\t\treturn this;\n\t};\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tvar copy = this.copy();\n\t\tcopy.collection = null;\n\t\treturn copy;\n\t};\n\n\t/**\n\t * Allows you to limit the number of documents passed to next chain operation.\n\t *    A resultset copy() is made to avoid altering original resultset.\n\t *\n\t * @param {int} qty - The number of documents to return.\n\t * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\tlimit(qty) {\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar rscopy = new Resultset(this.collection);\n\t\trscopy.filteredrows = this.filteredrows.slice(0, qty);\n\t\trscopy.filterInitialized = true;\n\t\treturn rscopy;\n\t};\n\n\t/**\n\t * Used for skipping 'pos' number of documents in the resultset.\n\t *\n\t * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n\t * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\toffset(pos) {\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar rscopy = new Resultset(this.collection);\n\t\trscopy.filteredrows = this.filteredrows.slice(pos);\n\t\trscopy.filterInitialized = true;\n\t\treturn rscopy;\n\t};\n\n\t/**\n\t * copy() - To support reuse of resultset in branched query situations.\n\t *\n\t * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n\t * @memberof Resultset\n\t */\n\tcopy() {\n\t\tvar result = new Resultset(this.collection);\n\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tresult.filteredrows = this.filteredrows.slice();\n\t\t}\n\t\tresult.filterInitialized = this.filterInitialized;\n\n\t\treturn result;\n\t};\n\n\t/**\n\t * Alias of copy()\n\t * @memberof Resultset\n\t */\n\tbranch() {\n\t\treturn this.copy();\n\t}\n\n\t/**\n\t * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n\t *\n\t * @param transform {(string|array)} - name of collection transform or raw transform array\n\t * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n\t * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n\t * @memberof Resultset\n\t */\n\ttransform(transform, parameters) {\n\t\tvar idx,\n\t\t\tstep,\n\t\t\trs = this;\n\n\t\t// if transform is name, then do lookup first\n\t\tif (typeof transform === 'string') {\n\t\t\tif (this.collection.transforms.hasOwnProperty(transform)) {\n\t\t\t\ttransform = this.collection.transforms[transform];\n\t\t\t}\n\t\t}\n\n\t\t// either they passed in raw transform array or we looked it up, so process\n\t\tif (typeof transform !== 'object' || !Array.isArray(transform)) {\n\t\t\tthrow new Error(\"Invalid transform\");\n\t\t}\n\n\t\tif (typeof parameters !== 'undefined') {\n\t\t\ttransform = Utils.resolveTransformParams(transform, parameters);\n\t\t}\n\n\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\tstep = transform[idx];\n\n\t\t\tswitch (step.type) {\n\t\t\t\tcase \"find\":\n\t\t\t\t\trs.find(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"where\":\n\t\t\t\t\trs.where(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"simplesort\":\n\t\t\t\t\trs.simplesort(step.property, step.desc);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"compoundsort\":\n\t\t\t\t\trs.compoundsort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sort\":\n\t\t\t\t\trs.sort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"limit\":\n\t\t\t\t\trs = rs.limit(step.value);\n\t\t\t\t\tbreak; // limit makes copy so update reference\n\t\t\t\tcase \"offset\":\n\t\t\t\t\trs = rs.offset(step.value);\n\t\t\t\t\tbreak; // offset makes copy so update reference\n\t\t\t\tcase \"map\":\n\t\t\t\t\trs = rs.map(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"eqJoin\":\n\t\t\t\t\trs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases break chain by returning array data so make any of these last in transform steps\n\t\t\t\tcase \"mapReduce\":\n\t\t\t\t\trs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases update documents in current filtered resultset (use carefully)\n\t\t\t\tcase \"update\":\n\t\t\t\t\trs.update(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\trs.remove();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn rs;\n\t};\n\n\t/**\n\t * Instances a new anonymous collection with the documents contained in the current resultset.\n\t *\n\t * @param {object} collectionOptions - Options to pass to new anonymous collection construction.\n\t * @returns {Collection} A reference to an anonymous collection initialized with resultset data().\n\t * @memberof Resultset\n\t */\n\tinstance(collectionOptions) {\n\t\tvar docs = this.data();\n\t\tvar idx,\n\t\t\tdoc;\n\n\t\tcollectionOptions = collectionOptions || {};\n\n\t\tvar instanceCollection = new Collection(collectionOptions);\n\n\t\tfor (idx = 0; idx < docs.length; idx++) {\n\t\t\tif (this.collection.cloneObjects) {\n\t\t\t\tdoc = docs[idx];\n\t\t\t} else {\n\t\t\t\tdoc = clone(docs[idx], this.collection.cloneMethod);\n\t\t\t}\n\n\t\t\tdelete doc.$loki;\n\t\t\tdelete doc.meta;\n\n\t\t\tinstanceCollection.insert(doc);\n\t\t}\n\n\t\treturn instanceCollection;\n\t};\n\n\t/**\n\t * User supplied compare function is provided two documents to compare. (chainable)\n\t * @example\n\t *    rslt.sort(function(obj1, obj2) {\n\t *      if (obj1.name === obj2.name) return 0;\n\t *      if (obj1.name > obj2.name) return 1;\n\t *      if (obj1.name < obj2.name) return -1;\n\t *    });\n\t *\n\t * @param {function} comparefun - A javascript compare function used for sorting.\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsort(comparefun) {\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(userComparer, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn userComparer(data[a], data[b]);\n\t\t\t\t};\n\t\t\t})(comparefun, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n\t *    Sorting based on the same lt/gt helper functions used for binary indices.\n\t *\n\t * @param {string} propname - name of property to sort by.\n\t * @param {bool=} isdesc - (Optional) If true, the property will be sorted in descending order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsimplesort(propname, isdesc) {\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t// if we have a binary index and no other filters applied, we can use that instead of sorting (again)\n\t\t\tif (this.collection.binaryIndices.hasOwnProperty(propname)) {\n\t\t\t\t// make sure index is up-to-date\n\t\t\t\tthis.collection.ensureIndex(propname);\n\t\t\t\t// copy index values into filteredrows\n\t\t\t\tthis.filteredrows = this.collection.binaryIndices[propname].values.slice(0);\n\t\t\t\t// we are done, return this (resultset) for further chain ops\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t// otherwise initialize array for sort below\n\t\t\telse {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(isdesc) === 'undefined') {\n\t\t\tisdesc = false;\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(prop, desc, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn sortHelper(data[a][prop], data[b][prop], desc);\n\t\t\t\t};\n\t\t\t})(propname, isdesc, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * rs.compoundsort(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * rs.compoundsort(['age', ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tcompoundsort(properties) {\n\t\tif (properties.length === 0) {\n\t\t\tthrow new Error(\"Invalid call to compoundsort, need at least one property\");\n\t\t}\n\n\t\tvar prop;\n\t\tif (properties.length === 1) {\n\t\t\tprop = properties[0];\n\t\t\tif (Array.isArray(prop)) {\n\t\t\t\treturn this.simplesort(prop[0], prop[1]);\n\t\t\t}\n\t\t\treturn this.simplesort(prop, false);\n\t\t}\n\n\t\t// unify the structure of 'properties' to avoid checking it repeatedly while sorting\n\t\tfor (var i = 0, len = properties.length; i < len; i += 1) {\n\t\t\tprop = properties[i];\n\t\t\tif (!Array.isArray(prop)) {\n\t\t\t\tproperties[i] = [prop, false];\n\t\t\t}\n\t\t}\n\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(props, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn compoundeval(props, data[a], data[b]);\n\t\t\t\t};\n\t\t\t})(properties, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * findOr() - oversee the operation of OR'ed query expressions.\n\t *    OR'ed expression evaluation runs each expression individually against the full collection,\n\t *    and finally does a set OR on each expression's results.\n\t *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindOr(expressionArray) {\n\t\tvar fr = null,\n\t\t\tfri = 0,\n\t\t\tfrlen = 0,\n\t\t\tdocset = [],\n\t\t\tidxset = [],\n\t\t\tidx = 0,\n\t\t\torigCount = this.count();\n\n\t\t// If filter is already initialized, then we query against only those items already in filter.\n\t\t// This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n\t\tfor (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n\t\t\t// we need to branch existing query to run each filter separately and combine results\n\t\t\tfr = this.branch().find(expressionArray[ei]).filteredrows;\n\t\t\tfrlen = fr.length;\n\t\t\t// if the find operation did not reduce the initial set, then the initial set is the actual result\n\t\t\tif (frlen === origCount) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// add any document 'hits'\n\t\t\tfor (fri = 0; fri < frlen; fri++) {\n\t\t\t\tidx = fr[fri];\n\t\t\t\tif (idxset[idx] === undefined) {\n\t\t\t\t\tidxset[idx] = true;\n\t\t\t\t\tdocset.push(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.filteredrows = docset;\n\t\tthis.filterInitialized = true;\n\n\t\treturn this;\n\t};\n\t$or() {\n\t\treturn this.findOr(...arguments);\n\t}\n\n\t/**\n\t * findAnd() - oversee the operation of AND'ed query expressions.\n\t *    AND'ed expression evaluation runs each expression progressively against the full collection,\n\t *    internally utilizing existing chained resultset functionality.\n\t *    Only the first filter can utilize a binary index.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindAnd(expressionArray) {\n\t\t// we have already implementing method chaining in this (our Resultset class)\n\t\t// so lets just progressively apply user supplied and filters\n\t\tfor (var i = 0, len = expressionArray.length; i < len; i++) {\n\t\t\tif (this.count() === 0) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis.find(expressionArray[i]);\n\t\t}\n\t\treturn this;\n\t};\n\n\t$and() {\n\t\treturn this.findAnd(...arguments);\n\t}\n\n\t/**\n\t * Used for querying via a mongo-style query object.\n\t *\n\t * @param {object} query - A mongo-style query object used for filtering current results.\n\t * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tfind(query, firstOnly) {\n\t\tif (this.collection.data.length === 0) {\n\t\t\tif (this.searchIsChained) {\n\t\t\t\tthis.filteredrows = [];\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tvar queryObject = query || 'getAll',\n\t\t\tp,\n\t\t\tproperty,\n\t\t\tqueryObjectOp,\n\t\t\toperator,\n\t\t\tvalue,\n\t\t\tkey,\n\t\t\tsearchByIndex = false,\n\t\t\tresult = [],\n\t\t\tindex = null;\n\n\t\t// if this was note invoked via findOne()\n\t\tfirstOnly = firstOnly || false;\n\n\t\tif (typeof queryObject === 'object') {\n\t\t\tfor (p in queryObject) {\n\t\t\t\tif (hasOwnProperty.call(queryObject, p)) {\n\t\t\t\t\tproperty = p;\n\t\t\t\t\tqueryObjectOp = queryObject[p];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// apply no filters if they want all\n\t\tif (!property || queryObject === 'getAll') {\n\t\t\t// coll.find(), coll.findOne(), coll.chain().find().data() all path here\n\n\t\t\tif (firstOnly) {\n\t\t\t\treturn (this.collection.data.length > 0) ? this.collection.data[0] : null;\n\t\t\t}\n\n\t\t\treturn (this.searchIsChained) ? (this) : (this.collection.data.slice());\n\t\t}\n\n\t\t// injecting $and and $or expression tree evaluation here.\n\t\tif (property === '$and' || property === '$or') {\n\t\t\tif (this.searchIsChained) {\n\t\t\t\tthis[property](queryObjectOp);\n\n\t\t\t\t// for chained find with firstonly,\n\t\t\t\tif (firstOnly && this.filteredrows.length > 1) {\n\t\t\t\t\tthis.filteredrows = this.filteredrows.slice(0, 1);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\t// our $and operation internally chains filters\n\t\t\t\tresult = this.collection.chain()[property](queryObjectOp).data();\n\n\t\t\t\t// if this was coll.findOne() return first object or empty array if null\n\t\t\t\t// since this is invoked from a constructor we can't return null, so we will\n\t\t\t\t// make null in coll.findOne();\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\treturn (result.length === 0) ? ([]) : (result[0]);\n\t\t\t\t}\n\n\t\t\t\t// not first only return all results\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// see if query object is in shorthand mode (assuming eq operator)\n\t\tif (queryObjectOp === null || (typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date)) {\n\t\t\toperator = '$eq';\n\t\t\tvalue = queryObjectOp;\n\t\t} else if (typeof queryObjectOp === 'object') {\n\t\t\tfor (key in queryObjectOp) {\n\t\t\t\tif (hasOwnProperty.call(queryObjectOp, key)) {\n\t\t\t\t\toperator = key;\n\t\t\t\t\tvalue = queryObjectOp[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Do not know what you want to do.');\n\t\t}\n\n\t\t// for regex ops, precompile\n\t\tif (operator === '$regex') {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue = new RegExp(value[0], value[1]);\n\t\t\t} else if (!(value instanceof RegExp)) {\n\t\t\t\tvalue = new RegExp(value);\n\t\t\t}\n\t\t}\n\n\t\t// if user is deep querying the object such as find('name.first': 'odin')\n\t\tvar usingDotNotation = (property.indexOf('.') !== -1);\n\n\t\t// if an index exists for the property being queried against, use it\n\t\t// for now only enabling for non-chained query (who's set of docs matches index)\n\t\t// or chained queries where it is the first filter applied and prop is indexed\n\t\tvar doIndexCheck = !usingDotNotation &&\n\t\t\t(!this.searchIsChained || !this.filterInitialized);\n\n\t\tif (doIndexCheck && this.collection.binaryIndices[property] &&\n\t\t\tindexedOpsList.indexOf(operator) !== -1) {\n\t\t\t// this is where our lazy index rebuilding will take place\n\t\t\t// basically we will leave all indexes dirty until we need them\n\t\t\t// so here we will rebuild only the index tied to this property\n\t\t\t// ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n\t\t\tif (this.collection.adaptiveBinaryIndices !== true) {\n\t\t\t\tthis.collection.ensureIndex(property);\n\t\t\t}\n\n\t\t\tsearchByIndex = true;\n\t\t\tindex = this.collection.binaryIndices[property];\n\t\t}\n\n\t\t// the comparison function\n\t\tvar fun = LokiOps[operator];\n\n\t\t// \"shortcut\" for collection data\n\t\tvar t = this.collection.data;\n\t\t// filter data length\n\t\tvar i = 0,\n\t\t\tlen = 0;\n\n\t\t// Query executed differently depending on :\n\t\t//    - whether it is chained or not\n\t\t//    - whether the property being queried has an index defined\n\t\t//    - if chained, we handle first pass differently for initial filteredrows[] population\n\t\t//\n\t\t// For performance reasons, each case has its own if block to minimize in-loop calculations\n\n\t\t// If not a chained query, bypass filteredrows and work directly against data\n\t\tif (!this.searchIsChained) {\n\t\t\tif (!searchByIndex) {\n\t\t\t\ti = t.length;\n\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\t\treturn (t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\t\treturn (t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\t// if using dot notation then treat property as keypath such as 'name.first'.\n\t\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// searching by binary index via calculateRange() utility method\n\t\t\t\tvar seg = this.collection.calculateRange(operator, property, value);\n\n\t\t\t\t// not chained so this 'find' was designated in Resultset constructor\n\t\t\t\t// so return object itself\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\tif (seg[1] !== -1) {\n\t\t\t\t\t\treturn t[index.values[seg[0]]];\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\tfor (i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\tresult.push(t[index.values[i]]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, len = seg.length; i < len; i++) {\n\t\t\t\t\t\tresult.push(t[index.values[seg[i]]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// not a chained query so return result as data[]\n\t\t\treturn result;\n\t\t}\n\n\n\t\t// Otherwise this is a chained query\n\t\t// Chained queries now preserve results ordering at expense on slightly reduced unindexed performance\n\n\t\tvar filter, rowIdx = 0;\n\n\t\t// If the filteredrows[] is already initialized, use it\n\t\tif (this.filterInitialized) {\n\t\t\tfilter = this.filteredrows;\n\t\t\tlen = filter.length;\n\n\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\tif (usingDotNotation) {\n\t\t\t\tproperty = property.split('.');\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (dotSubScan(t[rowIdx], property, fun, value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (fun(t[rowIdx][property], value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// first chained query so work against data[] but put results in filteredrows\n\t\telse {\n\t\t\t// if not searching by index\n\t\t\tif (!searchByIndex) {\n\t\t\t\tlen = t.length;\n\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// search by index\n\t\t\t\tvar segm = this.collection.calculateRange(operator, property, value);\n\n\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\tfor (i = segm[0]; i <= segm[1]; i++) {\n\t\t\t\t\t\tresult.push(index.values[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, len = segm.length; i < len; i++) {\n\t\t\t\t\t\tresult.push(index.values[segm[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.filterInitialized = true; // next time work against filteredrows[]\n\t\t}\n\n\t\tthis.filteredrows = result;\n\t\treturn this;\n\t};\n\n\n\t/**\n\t * where() - Used for filtering via a javascript filter function.\n\t *\n\t * @param {function} fun - A javascript function used for filtering current results by.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\twhere(fun) {\n\t\tvar viewFunction,\n\t\t\tresult = [];\n\n\t\tif ('function' === typeof fun) {\n\t\t\tviewFunction = fun;\n\t\t} else {\n\t\t\tthrow new TypeError('Argument is not a stored view or a function');\n\t\t}\n\t\ttry {\n\t\t\t// if not a chained query then run directly against data[] and return object []\n\t\t\tif (!this.searchIsChained) {\n\t\t\t\tvar i = this.collection.data.length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (viewFunction(this.collection.data[i]) === true) {\n\t\t\t\t\t\tresult.push(this.collection.data[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// not a chained query so returning result as data[]\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t// else chained query, so run against filteredrows\n\t\t\telse {\n\t\t\t\t// If the filteredrows[] is already initialized, use it\n\t\t\t\tif (this.filterInitialized) {\n\t\t\t\t\tvar j = this.filteredrows.length;\n\n\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\tif (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n\t\t\t\t\t\t\tresult.push(this.filteredrows[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filteredrows = result;\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\t// otherwise this is initial chained op, work against data, push into filteredrows[]\n\t\t\t\telse {\n\t\t\t\t\tvar k = this.collection.data.length;\n\n\t\t\t\t\twhile (k--) {\n\t\t\t\t\t\tif (viewFunction(this.collection.data[k]) === true) {\n\t\t\t\t\t\t\tresult.push(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\tthis.filterInitialized = true;\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\t/**\n\t * count() - returns the number of documents in the resultset.\n\t *\n\t * @returns {number} The number of documents in the resultset.\n\t * @memberof Resultset\n\t */\n\tcount() {\n\t\tif (this.searchIsChained && this.filterInitialized) {\n\t\t\treturn this.filteredrows.length;\n\t\t}\n\t\treturn this.collection.count();\n\t};\n\n\t/**\n\t * Terminates the chain and returns array of filtered documents\n\t *\n\t * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n\t * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n\t *        the collection is not configured for clone object.\n\t * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n\t *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'\n\t *\n\t * @returns {array} Array of documents in the resultset\n\t * @memberof Resultset\n\t */\n\tdata(options) {\n\t\tvar result = [],\n\t\t\tdata = this.collection.data,\n\t\t\tlen,\n\t\t\ti,\n\t\t\tmethod;\n\n\t\toptions = options || {};\n\n\t\t// if this is chained resultset with no filters applied, just return collection.data\n\t\tif (this.searchIsChained && !this.filterInitialized) {\n\t\t\tif (this.filteredrows.length === 0) {\n\t\t\t\t// determine whether we need to clone objects or not\n\t\t\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\t\t\tlen = data.length;\n\t\t\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tresult.push(clone(data[i], method));\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t// otherwise we are not cloning so return sliced array with same object references\n\t\t\t\telse {\n\t\t\t\t\treturn data.slice();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// filteredrows must have been set manually, so use it\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t}\n\t\t}\n\n\t\tvar fr = this.filteredrows;\n\t\tlen = fr.length;\n\n\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tresult.push(clone(data[fr[i]], method));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tresult.push(data[fr[i]]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t};\n\n\t/**\n\t * Used to run an update operation on all documents currently in the resultset.\n\t *\n\t * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tupdate(updateFunction) {\n\n\t\tif (typeof(updateFunction) !== \"function\") {\n\t\t\tthrow new TypeError('Argument is not a function');\n\t\t}\n\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar len = this.filteredrows.length,\n\t\t\trcd = this.collection.data;\n\n\t\tfor (var idx = 0; idx < len; idx++) {\n\t\t\t// pass in each document object currently in resultset to user supplied updateFunction\n\t\t\tupdateFunction(rcd[this.filteredrows[idx]]);\n\n\t\t\t// notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate\n\t\t\tthis.collection.update(rcd[this.filteredrows[idx]]);\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Removes all document objects which are currently in resultset from collection (as well as resultset)\n\t *\n\t * @returns {Resultset} this (empty) resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tremove() {\n\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tthis.collection.remove(this.data());\n\n\t\tthis.filteredrows = [];\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns {value} The output of your reduceFunction\n\t * @memberof Resultset\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t};\n\n\t/**\n\t * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n\t * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n\t * @param {Array} joinData - Data array to join to.\n\t * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n\t * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n\t * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n\t * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n\t * @memberof Resultset\n\t */\n\teqJoin(joinData, leftJoinKey, rightJoinKey, mapFun) {\n\n\t\tvar leftData = [],\n\t\t\tleftDataLength,\n\t\t\trightData = [],\n\t\t\trightDataLength,\n\t\t\tkey,\n\t\t\tresult = [],\n\t\t\tleftKeyisFunction = typeof leftJoinKey === 'function',\n\t\t\trightKeyisFunction = typeof rightJoinKey === 'function',\n\t\t\tjoinMap = {};\n\n\t\t//get the left data\n\t\tleftData = this.data();\n\t\tleftDataLength = leftData.length;\n\n\t\t//get the right data\n\t\tif (joinData instanceof Resultset) {\n\t\t\trightData = joinData.data();\n\t\t} else if (Array.isArray(joinData)) {\n\t\t\trightData = joinData;\n\t\t} else {\n\t\t\tthrow new TypeError('joinData needs to be an array or result set');\n\t\t}\n\t\trightDataLength = rightData.length;\n\n\t\t//construct a lookup table\n\n\t\tfor (var i = 0; i < rightDataLength; i++) {\n\t\t\tkey = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n\t\t\tjoinMap[key] = rightData[i];\n\t\t}\n\n\t\tif (!mapFun) {\n\t\t\tmapFun = function(left, right) {\n\t\t\t\treturn {\n\t\t\t\t\tleft: left,\n\t\t\t\t\tright: right\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\t//Run map function over each object in the resultset\n\t\tfor (var j = 0; j < leftDataLength; j++) {\n\t\t\tkey = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n\t\t\tresult.push(mapFun(leftData[j], joinMap[key] || {}));\n\t\t}\n\n\t\t//return return a new resultset with no filters\n\t\tthis.collection = new Collection('joinData');\n\t\tthis.collection.insert(result);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t};\n\n\tmap(mapFun) {\n\t\tvar data = this.data().map(mapFun);\n\t\t//return return a new resultset with no filters\n\t\tthis.collection = new Collection('mappedData');\n\t\tthis.collection.insert(data);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t};\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/resultset.js","export function clone(data, method) {\n\tif (data === null || data === undefined) {\n\t\treturn null;\n\t}\n\n\tvar cloneMethod = method || 'parse-stringify',\n\t\tcloned;\n\n\tswitch (cloneMethod) {\n\t\tcase \"parse-stringify\":\n\t\t\tcloned = JSON.parse(JSON.stringify(data));\n\t\t\tbreak;\n\t\tcase \"jquery-extend-deep\":\n\t\t\tcloned = jQuery.extend(true, {}, data);\n\t\t\tbreak;\n\t\tcase \"shallow\":\n\t\t\tcloned = Object.create(data.prototype || null);\n\t\t\tObject.keys(data).map(function(i) {\n\t\t\t\tcloned[i] = data[i];\n\t\t\t});\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn cloned;\n}\n\nexport function cloneObjectArray(objarray, method) {\n\tvar i,\n\t\tresult = [];\n\n\tif (method == \"parse-stringify\") {\n\t\treturn clone(objarray, method);\n\t}\n\n\ti = objarray.length - 1;\n\n\tfor (; i <= 0; i--) {\n\t\tresult.push(clone(objarray[i], method));\n\t}\n\n\treturn result;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/clone.js","/**\n * Created by toni on 1/27/17.\n */\n\n\nexport var Utils = {\n\tcopyProperties: function(src, dest) {\n\t\tvar prop;\n\t\tfor (prop in src) {\n\t\t\tdest[prop] = src[prop];\n\t\t}\n\t},\n\t// used to recursively scan hierarchical transform step object for param substitution\n\tresolveTransformObject: function(subObj, params, depth) {\n\t\tvar prop,\n\t\t\tpname;\n\n\t\tif (typeof depth !== 'number') {\n\t\t\tdepth = 0;\n\t\t}\n\n\t\tif (++depth >= 10) return subObj;\n\n\t\tfor (prop in subObj) {\n\t\t\tif (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n\t\t\t\tpname = subObj[prop].substring(8);\n\t\t\t\tif (params.hasOwnProperty(pname)) {\n\t\t\t\t\tsubObj[prop] = params[pname];\n\t\t\t\t}\n\t\t\t} else if (typeof subObj[prop] === \"object\") {\n\t\t\t\tsubObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n\t\t\t}\n\t\t}\n\n\t\treturn subObj;\n\t},\n\t// top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\n\tresolveTransformParams: function(transform, params) {\n\t\tvar idx,\n\t\t\tclonedStep,\n\t\t\tresolvedTransform = [];\n\n\t\tif (typeof params === 'undefined') return transform;\n\n\t\t// iterate all steps in the transform array\n\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\t// clone transform so our scan and replace can operate directly on cloned transform\n\t\t\tclonedStep = JSON.parse(JSON.stringify(transform[idx]));\n\t\t\tresolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));\n\t\t}\n\n\t\treturn resolvedTransform;\n\t}\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/utils.js","/**\n * Created by toni on 1/27/17.\n */\n\n\n/** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n */\nexport function ltHelper(prop1, prop2, equal) {\n\tvar cv1, cv2;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\tif (equal) {\n\t\t\t\treturn prop1 === prop2;\n\t\t\t} else {\n\t\t\t\tif (prop1) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn prop2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\treturn equal;\n\t\t}\n\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (prop1 === prop2) {\n\t\treturn equal;\n\t}\n\n\tif (prop1 < prop2) {\n\t\treturn true;\n\t}\n\n\tif (prop1 > prop2) {\n\t\treturn false;\n\t}\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\tif (cv1 < cv2) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nexport function gtHelper(prop1, prop2, equal) {\n\tvar cv1, cv2;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\tif (equal) {\n\t\t\t\treturn prop1 === prop2;\n\t\t\t} else {\n\t\t\t\tif (prop1) {\n\t\t\t\t\treturn !prop2;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\treturn equal;\n\t\t}\n\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (prop1 === prop2) {\n\t\treturn equal;\n\t}\n\n\tif (prop1 > prop2) {\n\t\treturn true;\n\t}\n\n\tif (prop1 < prop2) {\n\t\treturn false;\n\t}\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\tif (cv1 > cv2) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/helper.js","import {LokiEventEmitter} from './event_emitter';\nimport {Resultset} from './resultset'\n\n/*\n'LokiEventEmitter' is not defined        no-undef\n'Resultset' is not defined               no-undef\n */\n\n/**\n * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n *\n * @example\n * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n * mydv.applyFind({ 'doors' : 4 });\n * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n * var results = mydv.data();\n *\n * @constructor DynamicView\n * @implements LokiEventEmitter\n * @param {Collection} collection - A reference to the collection to work against\n * @param {string} name - The name of this dynamic view\n * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n */\nexport class DynamicView extends LokiEventEmitter {\n\n\tconstructor(collection, name, options) {\n\t\tsuper();\n\t\tthis.collection = collection;\n\t\tthis.name = name;\n\t\tthis.rebuildPending = false;\n\t\tthis.options = options || {};\n\n\t\tif (!this.options.hasOwnProperty('persistent')) {\n\t\t\tthis.options.persistent = false;\n\t\t}\n\n\t\t// 'persistentSortPriority':\n\t\t// 'passive' will defer the sort phase until they call data(). (most efficient overall)\n\t\t// 'active' will sort async whenever next idle. (prioritizes read speeds)\n\t\tif (!this.options.hasOwnProperty('sortPriority')) {\n\t\t\tthis.options.sortPriority = 'passive';\n\t\t}\n\n\t\tif (!this.options.hasOwnProperty('minRebuildInterval')) {\n\t\t\tthis.options.minRebuildInterval = 1;\n\t\t}\n\n\t\tthis.resultset = new Resultset(collection);\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = false;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\t// for now just have 1 event for when we finally rebuilt lazy view\n\t\t// once we refactor transactions, i will tie in certain transactional events\n\n\t\tthis.events = {\n\t\t\t'rebuild': []\n\t\t};\n\t}\n\n\t/**\n\t * rematerialize() - intended for use immediately after deserialization (loading)\n\t *    This will clear out and reapply filterPipeline ops, recreating the view.\n\t *    Since where filters do not persist correctly, this method allows\n\t *    restoring the view to state where user can re-apply those where filters.\n\t *\n\t * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n\t * @returns {DynamicView} This dynamic view for further chained ops.\n\t * @memberof DynamicView\n\t * @fires DynamicView.rebuild\n\t */\n\trematerialize(options) {\n\t\tvar fpl,\n\t\t\tfpi,\n\t\t\tidx;\n\n\t\toptions = options || {};\n\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\t\tthis.resultset = new Resultset(this.collection);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.sortDirty = true;\n\t\t}\n\n\t\tif (options.hasOwnProperty('removeWhereFilters')) {\n\t\t\t// for each view see if it had any where filters applied... since they don't\n\t\t\t// serialize those functions lets remove those invalid filters\n\t\t\tfpl = this.filterPipeline.length;\n\t\t\tfpi = fpl;\n\t\t\twhile (fpi--) {\n\t\t\t\tif (this.filterPipeline[fpi].type === 'where') {\n\t\t\t\t\tif (fpi !== this.filterPipeline.length - 1) {\n\t\t\t\t\t\tthis.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filterPipeline.length--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n\t\tvar ofp = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\t// now re-apply 'find' filterPipeline ops\n\t\tfpl = ofp.length;\n\t\tfor (idx = 0; idx < fpl; idx++) {\n\t\t\tthis.applyFind(ofp[idx].val);\n\t\t}\n\n\t\t// during creation of unit tests, i will remove this forced refresh and leave lazy\n\t\tthis.data();\n\n\t\t// emit rebuild event in case user wants to be notified\n\t\tthis.emit('rebuild', this);\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * branchResultset() - Makes a copy of the internal resultset for branched queries.\n\t *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n\t *    so your branched query should be immediately resolved and not held for future evaluation.\n\t *\n\t * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n\t * @param {object=} parameters - optional parameters (if optional transform requires them)\n\t * @returns {Resultset} A copy of the internal resultset for branched queries.\n\t * @memberof DynamicView\n\t */\n\tbranchResultset(transform, parameters) {\n\t\tvar rs = this.resultset.branch();\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t};\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tvar copy = new DynamicView(this.collection, this.name, this.options);\n\n\t\tcopy.resultset = this.resultset;\n\t\tcopy.resultdata = []; // let's not save data (copy) to minimize size\n\t\tcopy.resultsdirty = true;\n\t\tcopy.filterPipeline = this.filterPipeline;\n\t\tcopy.sortFunction = this.sortFunction;\n\t\tcopy.sortCriteria = this.sortCriteria;\n\t\tcopy.sortDirty = this.sortDirty;\n\n\t\t// avoid circular reference, reapply in db.loadJSON()\n\t\tcopy.collection = null;\n\n\t\treturn copy;\n\t};\n\n\t/**\n\t * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n\t *     Existing options should be retained.\n\t * @param {object=} options - configure removeFilter behavior\n\t * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n\t * @memberof DynamicView\n\t */\n\tremoveFilters(options) {\n\t\toptions = options || {};\n\n\t\tthis.rebuildPending = false;\n\t\tthis.resultset.reset();\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\tif (options.queueSortPhase === true) {\n\t\t\tthis.queueSortPhase();\n\t\t}\n\t};\n\n\t/**\n\t * applySort() - Used to apply a sort to the dynamic view\n\t * @example\n\t * dv.applySort(function(obj1, obj2) {\n\t *   if (obj1.name === obj2.name) return 0;\n\t *   if (obj1.name > obj2.name) return 1;\n\t *   if (obj1.name < obj2.name) return -1;\n\t * });\n\t *\n\t * @param {function} comparefun - a javascript compare function used for sorting\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySort(comparefun) {\n\t\tthis.sortFunction = comparefun;\n\t\tthis.sortCriteria = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * applySimpleSort() - Used to specify a property used for view translation.\n\t * @example\n\t * dv.applySimpleSort(\"name\");\n\t *\n\t * @param {string} propname - Name of property by which to sort.\n\t * @param {boolean=} isdesc - (Optional) If true, the sort will be in descending order.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySimpleSort(propname, isdesc) {\n\t\tthis.sortCriteria = [\n\t\t\t[propname, isdesc || false]\n\t\t];\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * dv.applySortCriteria(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * dv.applySortCriteria(['age', ['name', true]);\n\t * // to sort by age (descending) and then by name (descending)\n\t * dv.applySortCriteria(['age', true], ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n\t * @memberof DynamicView\n\t */\n\tapplySortCriteria(criteria) {\n\t\tthis.sortCriteria = criteria;\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * startTransaction() - marks the beginning of a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tstartTransaction() {\n\t\tthis.cachedresultset = this.resultset.copy();\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * commit() - commits a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tcommit() {\n\t\tthis.cachedresultset = null;\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * rollback() - rolls back a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\trollback() {\n\t\tthis.resultset = this.cachedresultset;\n\n\t\tif (this.options.persistent) {\n\t\t\t// for now just rebuild the persistent dynamic view data in this worst case scenario\n\t\t\t// (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n\t\t\tthis.resultdata = this.resultset.data();\n\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\n\t\treturn this;\n\t};\n\n\n\t/**\n\t * Implementation detail.\n\t * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter.\n\t * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n\t */\n\t_indexOfFilterWithId(uid) {\n\t\tif (typeof uid === 'string' || typeof uid === 'number') {\n\t\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n\t\t\t\tif (uid === this.filterPipeline[idx].uid) {\n\t\t\t\t\treturn idx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\t/**\n\t * Implementation detail.\n\t * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n\t *\n\t * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n\t */\n\t_addFilter(filter) {\n\t\tthis.filterPipeline.push(filter);\n\t\tthis.resultset[filter.type](filter.val);\n\t};\n\n\t/**\n\t * reapplyFilters() - Reapply all the filters in the current pipeline.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\treapplyFilters() {\n\t\tthis.resultset.reset();\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tvar filters = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\tfor (var idx = 0, len = filters.length; idx < len; idx += 1) {\n\t\t\tthis._addFilter(filters[idx]);\n\t\t}\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n\t *\n\t * @param {object} filter - A filter object to add to the pipeline.\n\t *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFilter(filter) {\n\t\tvar idx = this._indexOfFilterWithId(filter.uid);\n\t\tif (idx >= 0) {\n\t\t\tthis.filterPipeline[idx] = filter;\n\t\t\treturn this.reapplyFilters();\n\t\t}\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tthis._addFilter(filter);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n\t *\n\t * @param {object} query - A mongo-style query object to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFind(query, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'find',\n\t\t\tval: query,\n\t\t\tuid: uid\n\t\t});\n\t\treturn this;\n\t};\n\n\t/**\n\t * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n\t *\n\t * @param {function} fun - A javascript filter function to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyWhere(fun, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'where',\n\t\t\tval: fun,\n\t\t\tuid: uid\n\t\t});\n\t\treturn this;\n\t};\n\n\t/**\n\t * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter to be removed.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tremoveFilter(uid) {\n\t\tvar idx = this._indexOfFilterWithId(uid);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n\t\t}\n\n\t\tthis.filterPipeline.splice(idx, 1);\n\t\tthis.reapplyFilters();\n\t\treturn this;\n\t};\n\n\t/**\n\t * count() - returns the number of documents representing the current DynamicView contents.\n\t *\n\t * @returns {number} The number of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tcount() {\n\t\t// in order to be accurate we will pay the minimum cost (and not alter dv state management)\n\t\t// recurring resultset data resolutions should know internally its already up to date.\n\t\t// for persistent data this will not update resultdata nor fire rebuild event.\n\t\tif (this.resultsdirty) {\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t}\n\n\t\treturn this.resultset.count();\n\t};\n\n\t/**\n\t * data() - resolves and pending filtering and sorting, then returns document array as result.\n\t *\n\t * @returns {array} An array of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tdata() {\n\t\t// using final sort phase as 'catch all' for a few use cases which require full rebuild\n\t\tif (this.sortDirty || this.resultsdirty) {\n\t\t\tthis.performSortPhase({\n\t\t\t\tsuppressRebuildEvent: true\n\t\t\t});\n\t\t}\n\t\treturn (this.options.persistent) ? (this.resultdata) : (this.resultset.data());\n\t};\n\n\t/**\n\t * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n\t *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n\t */\n\tqueueRebuildEvent() {\n\t\tif (this.rebuildPending) {\n\t\t\treturn;\n\t\t}\n\t\tthis.rebuildPending = true;\n\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tif (self.rebuildPending) {\n\t\t\t\tself.rebuildPending = false;\n\t\t\t\tself.emit('rebuild', self);\n\t\t\t}\n\t\t}, this.options.minRebuildInterval);\n\t};\n\n\t/**\n\t * queueSortPhase : If the view is sorted we will throttle sorting to either :\n\t *    (1) passive - when the user calls data(), or\n\t *    (2) active - once they stop updating and yield js thread control\n\t */\n\tqueueSortPhase() {\n\t\t// already queued? exit without queuing again\n\t\tif (this.sortDirty) {\n\t\t\treturn;\n\t\t}\n\t\tthis.sortDirty = true;\n\n\t\tvar self = this;\n\t\tif (this.options.sortPriority === \"active\") {\n\t\t\t// active sorting... once they are done and yield js thread, run async performSortPhase()\n\t\t\tsetTimeout(function() {\n\t\t\t\tself.performSortPhase();\n\t\t\t}, this.options.minRebuildInterval);\n\t\t} else {\n\t\t\t// must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n\t\t\t// potentially notify user that data has changed.\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\t};\n\n\t/**\n\t * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n\t *\n\t */\n\tperformSortPhase(options) {\n\t\t// async call to this may have been pre-empted by synchronous call to data before async could fire\n\t\tif (!this.sortDirty && !this.resultsdirty) {\n\t\t\treturn;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tif (this.sortDirty) {\n\t\t\tif (this.sortFunction) {\n\t\t\t\tthis.resultset.sort(this.sortFunction);\n\t\t\t} else if (this.sortCriteria) {\n\t\t\t\tthis.resultset.compoundsort(this.sortCriteria);\n\t\t\t}\n\n\t\t\tthis.sortDirty = false;\n\t\t}\n\n\t\tif (this.options.persistent) {\n\t\t\t// persistent view, rebuild local resultdata array\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t\tthis.resultsdirty = false;\n\t\t}\n\n\t\tif (!options.suppressRebuildEvent) {\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\t};\n\n\t/**\n\t * evaluateDocument() - internal method for (re)evaluating document inclusion.\n\t *    Called by : collection.insert() and collection.update().\n\t *\n\t * @param {int} objIndex - index of document to (re)run through filter pipeline.\n\t * @param {bool} isNew - true if the document was just added to the collection.\n\t */\n\tevaluateDocument(objIndex, isNew) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar ofr = this.resultset.filteredrows;\n\t\tvar oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));\n\t\tvar oldlen = ofr.length;\n\n\t\t// creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n\t\t// mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n\t\tvar evalResultset = new Resultset(this.collection);\n\t\tevalResultset.filteredrows = [objIndex];\n\t\tevalResultset.filterInitialized = true;\n\t\tvar filter;\n\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n\t\t\tfilter = this.filterPipeline[idx];\n\t\t\tevalResultset[filter.type](filter.val);\n\t\t}\n\n\t\t// not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n\t\tvar newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;\n\n\t\t// wasn't in old, shouldn't be now... do nothing\n\t\tif (oldPos === -1 && newPos === -1) return;\n\n\t\t// wasn't in resultset, should be now... add\n\t\tif (oldPos === -1 && newPos !== -1) {\n\t\t\tofr.push(objIndex);\n\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata.push(this.collection.data[objIndex]);\n\t\t\t}\n\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, shouldn't be now... delete\n\t\tif (oldPos !== -1 && newPos === -1) {\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr.splice(oldPos, 1);\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.splice(oldPos, 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, should still be now... (update persistent only?)\n\t\tif (oldPos !== -1 && newPos !== -1) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\t// in case document changed, replace persistent view data with the latest collection.data document\n\t\t\t\tthis.resultdata[oldPos] = this.collection.data[objIndex];\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t};\n\n\t/**\n\t * removeDocument() - internal function called on collection.delete()\n\t */\n\tremoveDocument(objIndex) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar ofr = this.resultset.filteredrows;\n\t\tvar oldPos = ofr.indexOf(+objIndex);\n\t\tvar oldlen = ofr.length;\n\t\tvar idx;\n\n\t\tif (oldPos !== -1) {\n\t\t\t// if not last row in resultdata, swap last to hole and truncate last row\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr[oldPos] = ofr[oldlen - 1];\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata[oldPos] = this.resultdata[oldlen - 1];\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// last row, so just truncate last row\n\t\t\telse {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t}\n\n\t\t// since we are using filteredrows to store data array positions\n\t\t// if they remove a document (whether in our view or not),\n\t\t// we need to adjust array positions -1 for all document array references after that position\n\t\toldlen = ofr.length;\n\t\tfor (idx = 0; idx < oldlen; idx++) {\n\t\t\tif (ofr[idx] > objIndex) {\n\t\t\t\tofr[idx]--;\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * mapReduce() - data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns The output of your reduceFunction\n\t * @memberof DynamicView\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t};\n\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/dynamic_view.js","/*\nLoki IndexedDb Adapter (need to include this script to use it)\n\nConsole Usage can be used for management/diagnostic, here are a few examples :\nadapter.getDatabaseList(); // with no callback passed, this method will log results to console\nadapter.saveDatabase(\"UserDatabase\", JSON.stringify(myDb));\nadapter.loadDatabase(\"UserDatabase\"); // will log the serialized db to console\nadapter.deleteDatabase(\"UserDatabase\");\n*/\n\n/**\n * Loki persistence adapter class for indexedDb.\n *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n *     Utilizes the included LokiCatalog app/key/value database for actual database persistence.\n *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n *     allow separate contexts for separate apps within a domain.\n *\n * @example\n * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n *\n * @constructor LokiIndexedAdapter\n *\n * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, \"loki\" by default\n */\nexport class LokiIndexedAdapter {\n\n\tconstructor(appname) {\n\t\tthis.app = \"loki\";\n\n\t\tif (typeof(appname) !== \"undefined\") {\n\t\t\tthis.app = appname;\n\t\t}\n\n\t\t// keep reference to catalog class for base AKV operations\n\t\tthis.catalog = null;\n\n\t\tif (!this.checkAvailability()) {\n\t\t\tthrow new Error(\"indexedDB does not seem to be supported for your environment\");\n\t\t}\n\t}\n\n\t/**\n\t * Used to check if adapter is available\n\t *\n\t * @returns {boolean} true if indexeddb is available, false if not.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tcheckAvailability() {\n\t\tif (typeof indexedDB !== \"undefined\" && indexedDB) return true;\n\n\t\treturn false;\n\t};\n\n\t/**\n\t * Retrieves a serialized db string from the catalog.\n\t *\n\t * @example\n\t * // LOAD\n\t * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t * var db = new loki(\"test\", { adapter: idbAdapter });\n\t *   db.loadDatabase(function(result) {\n\t *   console.log(\"done\");\n\t * });\n\t *\n\t * @param {string} dbname - the name of the database to retrieve.\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiIndexedAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tadapter.catalog = new LokiCatalog(function(cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t\tresolve(adapter.loadDatabase(dbname));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// lookup up db string in AKV db\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.catalog.getAppKey(appName, dbname, function(result) {\n\t\t\t\tif (result.id === 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(result.val);\n\t\t\t});\n\t\t});\n\t};\n\n\t// alias\n\tloadKey(dbname) {\n\t\treturn this.loadDatabase(dbname);\n\t}\n\n\t/**\n\t * Saves a serialized db to the catalog.\n\t *\n\t * @example\n\t * // SAVE : will save App/Key/Val as \"finance\"/\"test\"/{serializedDb}\n\t * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t * var db = new loki(\"test\", { adapter: idbAdapter });\n\t * var coll = db.addCollection(\"testColl\");\n\t * coll.insert({test: \"val\"});\n\t * db.saveDatabase();  // could pass callback if needed for async complete\n\t *\n\t * @param {string} dbname - the name to give the serialized database within the catalog.\n\t * @param {string} dbstring - the serialized db string to save.\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiIndexedAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\tvar resolve, reject;\n\t\tvar result = new Promise(function(res, rej) {\n\t\t\tresolve = res;\n\t\t\treject = rej;\n\t\t});\n\n\t\tfunction saveCallback(result) {\n\t\t\tif (result && result.success === true) {\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\treject(new Error(\"Error saving database\"));\n\t\t\t}\n\t\t}\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t// now that catalog has been initialized, set (add/update) the AKV entry\n\t\t\t\tcat.setAppKey(appName, dbname, dbstring, saveCallback);\n\t\t\t});\n\n\t\t\treturn result;\n\t\t}\n\n\t\t// set (add/update) entry to AKV database\n\t\tthis.catalog.setAppKey(appName, dbname, dbstring, saveCallback);\n\n\t\treturn result;\n\t};\n\n\t// alias\n\tsaveKey(dbname, dbstring) {\n\t\treturn this.saveDatabase(dbname, dbstring);\n\t}\n\n\t/**\n\t * Deletes a serialized db from the catalog.\n\t *\n\t * @example\n\t * // DELETE DATABASE\n\t * // delete \"finance\"/\"test\" value from catalog\n\t * idbAdapter.deleteDatabase(\"test\", function {\n\t *   // database deleted\n\t * });\n\t *\n\t * @param {string} dbname - the name of the database to delete from the catalog.\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiIndexedAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference and pass callback ahead\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tadapter.catalog = new LokiCatalog(function(cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t\tresolve(adapter.deleteDatabase(dbname));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// catalog was already initialized, so just lookup object and delete by id\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.catalog.getAppKey(appName, dbname, function(result) {\n\t\t\t\tvar id = result.id;\n\n\t\t\t\tif (id !== 0) {\n\t\t\t\t\tadapter.catalog.deleteAppKey(id);\n\t\t\t\t}\n\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t};\n\n\t// alias\n\tdeleteKey(dbname) {\n\t\treturn this.deleteDatabase(dbname);\n\t}\n\n\t/**\n\t * Removes all database partitions and pages with the base filename passed in.\n\t * This utility method does not (yet) guarantee async deletions will be completed before returning\n\t *\n\t * @param {string} dbname - the base filename which container, partitions, or pages are derived\n\t * @memberof LokiIndexedAdapter\n\t */\n\tdeleteDatabasePartitions(dbname) {\n\t\tvar self = this;\n\t\tthis.getDatabaseList(function(result) {\n\t\t\tresult.forEach(function(str) {\n\t\t\t\tif (str.startsWith(dbname)) {\n\t\t\t\t\tself.deleteDatabase(str);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t};\n\n\t/**\n\t * Retrieves object array of catalog entries for current app.\n\t *\n\t * @example\n\t * idbAdapter.getDatabaseList(function(result) {\n\t *   // result is array of string names for that appcontext (\"finance\")\n\t *   result.forEach(function(str) {\n\t *     console.log(str);\n\t *   });\n\t * });\n\t *\n\t * @param {function} callback - should accept array of database names in the catalog for current app.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tgetDatabaseList(callback) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\tadapter.getDatabaseList(callback);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// catalog already initialized\n\t\t// get all keys for current appName, and transpose results so just string array\n\t\tthis.catalog.getAppKeys(appName, function(results) {\n\t\t\tvar names = [];\n\n\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\tnames.push(results[idx].key);\n\t\t\t}\n\n\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\tcallback(names);\n\t\t\t} else {\n\t\t\t\tnames.forEach(function(obj) {\n\t\t\t\t\tconsole.log(obj);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n\n\t// alias\n\tgetKeyList(callback) {\n\t\treturn this.getDatabaseList(callback);\n\t}\n\n\t/**\n\t * Allows retrieval of list of all keys in catalog along with size\n\t *\n\t * @param {function} callback - (Optional) callback to accept result array.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tgetCatalogSummary(callback) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\tadapter.getCatalogSummary(callback);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// catalog already initialized\n\t\t// get all keys for current appName, and transpose results so just string array\n\t\tthis.catalog.getAllKeys(function(results) {\n\t\t\tvar entries = [];\n\t\t\tvar obj,\n\t\t\t\tsize,\n\t\t\t\toapp,\n\t\t\t\tokey,\n\t\t\t\toval;\n\n\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\tobj = results[idx];\n\t\t\t\toapp = obj.app || '';\n\t\t\t\tokey = obj.key || '';\n\t\t\t\toval = obj.val || '';\n\n\t\t\t\t// app and key are composited into an appkey column so we will mult by 2\n\t\t\t\tsize = oapp.length * 2 + okey.length * 2 + oval.length + 1;\n\n\t\t\t\tentries.push({\n\t\t\t\t\t\"app\": obj.app,\n\t\t\t\t\t\"key\": obj.key,\n\t\t\t\t\t\"size\": size\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\tcallback(entries);\n\t\t\t} else {\n\t\t\t\tentries.forEach(function(obj) {\n\t\t\t\t\tconsole.log(obj);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t};\n}\n\n/**\n * LokiCatalog - underlying App/Key/Value catalog persistence\n *    This non-interface class implements the actual persistence.\n *    Used by the IndexedAdapter class.\n */\nclass LokiCatalog {\n\tconstructor(callback) {\n\t\tthis.db = null;\n\t\tthis.initializeLokiCatalog(callback);\n\t}\n\n\tinitializeLokiCatalog(callback) {\n\t\tvar openRequest = indexedDB.open(\"LokiCatalog\", 1);\n\t\tvar cat = this;\n\n\t\t// If database doesn't exist yet or its version is lower than our version specified above (2nd param in line above)\n\t\topenRequest.onupgradeneeded = function(e) {\n\t\t\tvar thisDB = e.target.result;\n\t\t\tif (thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\tthisDB.deleteObjectStore(\"LokiAKV\");\n\t\t\t}\n\n\t\t\tif (!thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\tvar objectStore = thisDB.createObjectStore(\"LokiAKV\", {\n\t\t\t\t\tkeyPath: \"id\",\n\t\t\t\t\tautoIncrement: true\n\t\t\t\t});\n\t\t\t\tobjectStore.createIndex(\"app\", \"app\", {\n\t\t\t\t\tunique: false\n\t\t\t\t});\n\t\t\t\tobjectStore.createIndex(\"key\", \"key\", {\n\t\t\t\t\tunique: false\n\t\t\t\t});\n\t\t\t\t// hack to simulate composite key since overhead is low (main size should be in val field)\n\t\t\t\t// user (me) required to duplicate the app and key into comma delimited appkey field off object\n\t\t\t\t// This will allow retrieving single record with that composite key as well as\n\t\t\t\t// still supporting opening cursors on app or key alone\n\t\t\t\tobjectStore.createIndex(\"appkey\", \"appkey\", {\n\t\t\t\t\tunique: true\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\topenRequest.onsuccess = function(e) {\n\t\t\tcat.db = e.target.result;\n\n\t\t\tif (typeof(callback) === \"function\") callback(cat);\n\t\t};\n\n\t\topenRequest.onerror = function(e) {\n\t\t\tthrow e;\n\t\t};\n\t};\n\n\tgetAppKey(app, key, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"appkey\");\n\t\tvar appkey = app + \",\" + key;\n\t\tvar request = index.get(appkey);\n\n\t\trequest.onsuccess = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar lres = e.target.result;\n\n\t\t\t\tif (lres === null || typeof(lres) === \"undefined\") {\n\t\t\t\t\tlres = {\n\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(lres);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(lres);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback({\n\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t};\n\n\tgetAppKeyById(id, callback, data) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar request = store.get(id);\n\n\t\trequest.onsuccess = (function(data, usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(e.target.result, data);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(e.target.result);\n\t\t\t\t}\n\t\t\t};\n\t\t})(data, callback);\n\t};\n\n\tsetAppKey(app, key, val, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"appkey\");\n\t\tvar appkey = app + \",\" + key;\n\t\tvar request = index.get(appkey);\n\n\t\t// first try to retrieve an existing object by that key\n\t\t// need to do this because to update an object you need to have id in object, otherwise it will append id with new autocounter and clash the unique index appkey\n\t\trequest.onsuccess = function(e) {\n\t\t\tvar res = e.target.result;\n\n\t\t\tif (res === null || res === undefined) {\n\t\t\t\tres = {\n\t\t\t\t\tapp: app,\n\t\t\t\t\tkey: key,\n\t\t\t\t\tappkey: app + \",\" + key,\n\t\t\t\t\tval: val\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres.val = val;\n\t\t\t}\n\n\t\t\tvar requestPut = store.put(res);\n\n\t\t\trequestPut.onerror = (function(usercallback) {\n\t\t\t\treturn function(e) {\n\t\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (set) onerror\");\n\t\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t})(callback);\n\n\t\t\trequestPut.onsuccess = (function(usercallback) {\n\t\t\t\treturn function(e) {\n\t\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tsuccess: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t})(callback);\n\t\t};\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback({\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (get) onerror\");\n\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t};\n\n\tdeleteAppKey(id, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar request = store.delete(id);\n\n\t\trequest.onsuccess = (function(usercallback) {\n\t\t\treturn function(evt) {\n\t\t\t\tif (typeof(usercallback) === \"function\") usercallback({\n\t\t\t\t\tsuccess: true\n\t\t\t\t});\n\t\t\t};\n\t\t})(callback);\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(evt) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(false);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.deleteAppKey raised onerror\");\n\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t};\n\n\tgetAppKeys(app, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"app\");\n\n\t\t// We want cursor to all values matching our (single) app param\n\t\tvar singleKeyRange = IDBKeyRange.only(app);\n\n\t\t// To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n\t\tvar cursor = index.openCursor(singleKeyRange);\n\n\t\t// cursor internally, pushing results into this.data[] and return\n\t\t// this.data[] when done (similar to service)\n\t\tvar localdata = [];\n\n\t\tcursor.onsuccess = (function(data, callback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar cursor = e.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tvar currObject = cursor.value;\n\n\t\t\t\t\tdata.push(currObject);\n\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})(localdata, callback);\n\n\t\tcursor.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(null);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.getAppKeys raised onerror\");\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\n\t};\n\n\t// Hide \"cursoring\" and return array of { id: id, key: key }\n\tgetAllKeys(callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar cursor = store.openCursor();\n\n\t\tvar localdata = [];\n\n\t\tcursor.onsuccess = (function(data, callback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar cursor = e.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tvar currObject = cursor.value;\n\n\t\t\t\t\tdata.push(currObject);\n\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})(localdata, callback);\n\n\t\tcursor.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") usercallback(null);\n\t\t\t};\n\t\t})(callback);\n\t};\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/loki-indexed-adapter.js"],"sourceRoot":""}