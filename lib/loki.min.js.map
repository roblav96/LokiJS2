{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///loki.min.js","webpack:///webpack/bootstrap 55f15f730af5566e2a15","webpack:///./src/core/event_emitter.js","webpack:///./src/core/collection.js","webpack:///./src/core/utils.js","webpack:///./src/core/clone.js","webpack:///./src/core/helper.js","webpack:///./src/core/loki.js","webpack:///./src/core/resultset.js","webpack:///./src/core/fs_adapter.js","webpack:///./src/core/local_storage_adapter.js","webpack:///./src/core/loki-indexed-adapter.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/core/dynamic_view.js","webpack:///./src/core/exact_index.js","webpack:///./src/core/unique_index.js"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","LokiEventEmitter","[object Object]","events","asyncListeners","eventName","listener","event","self","Array","isArray","forEach","currentEventName","on","push","data","setTimeout","removeListener","listen","listeners","splice","indexOf","isDeepProperty","field","parseBase10","num","parseFloat","add","b","sub","average","array","reduce","length","standardDeviation","values","avg","squareDiffs","map","diff","avgSquareDiff","Math","sqrt","deepProperty","obj","isDeep","pieces","split","shift","__WEBPACK_IMPORTED_MODULE_0__event_emitter__","__WEBPACK_IMPORTED_MODULE_1__unique_index__","__WEBPACK_IMPORTED_MODULE_2__exact_index__","__WEBPACK_IMPORTED_MODULE_3__resultset__","__WEBPACK_IMPORTED_MODULE_4__dynamic_view__","__WEBPACK_IMPORTED_MODULE_5__clone__","__WEBPACK_IMPORTED_MODULE_6__helper__","__WEBPACK_IMPORTED_MODULE_7__loki__","Collection","options","observerCallback","changes","changedObjects","Set","change","removeAutoUpdateObserver","update","err","createChange","op","operation","JSON","parse","stringify","flushChanges","insertMeta","meta","created","Date","getTime","revision","updateMeta","updated","createInsertChange","createUpdateChange","insertMetaWithChange","updateMetaWithChange","setHandlers","insertHandler","disableChangesApi","updateHandler","super","idIndex","binaryIndices","constraints","unique","exact","uniqueNames","transforms","objType","dirty","cachedIndex","cachedBinaryIndex","cachedData","prop","_fullTextSearch","undefined","FullTextSearch","fullTextSearch","adaptiveBinaryIndices","transactional","cloneObjects","clone","cloneMethod","autoupdate","ttl","age","ttlInterval","daemon","setTTL","maxId","DynamicViews","insert","pre-insert","pre-update","close","flushbuffer","error","delete","warning","ensureId","indices","toString","TypeError","idx","ensureIndex","getChanges","setChangesApi","enabled","console","warn","log","stages","commitLog","observe","unobserve","transform","Error","template","k","query","$and","findOne","byExample","find","collection","now","chain","where","member","timestamp","remove","interval","clearInterval","setInterval","ttlDaemonFuncGen","len","indexes","ensureAllIndexes","force","index","prepareFullDocIndex","wrappedComparer","objAp","objBp","sort","idxvals","result","set","key","bIndices","filteredrows","$loki","dv","filterObject","updateFunction","updateWhere","doc","insertOne","results","emit","bulkInsert","returnObj","addDocument","addAutoUpdateObserver","removeIndices","keys","biname","uiname","ensureUniqueIndex","startTransaction","oldInternal","newInternal","position","arr","evaluateDocument","adaptiveBinaryIndexUpdate","flagBinaryIndexesDirty","updateDocument","commit","rollback","message","isNaN","version","constrUnique","addedPos","dvlen","adaptiveBinaryIndexInsert","filterFunction","list","filter","slice","removeDocument","adaptiveBinaryIndexRemove","id","returnPosition","retpos","max","min","mid","parseInt","dataPosition","binaryIndexName","val","range","calculateRange","idxPos","calculateRangeStart","removedFromIndexOnly","getBinaryIndexPosition","rcd","lbound","ubound","minVal","maxVal","calculateRangeEnd","idxset","segResult","j","seg","lval","uval","by","queryObj","firstOnly","parameters","rs","fun","queryFunc","mapFunction","reduceFunction","joinData","leftJoinProp","rightJoinProp","mapFun","eqJoin","stageName","copy","getStage","stage","isDotNotation","apply","extract","deep","Number","extractNumerical","dict","mode","half","floor","Utils","copyProperties","src","dest","resolveTransformObject","subObj","params","depth","pname","substring","resolveTransformParams","clonedStep","resolvedTransform","method","cloned","jQuery","extend","create","cloneObjectArray","objarray","ltHelper","prop1","prop2","equal","cv1","cv2","gtHelper","global","__WEBPACK_IMPORTED_MODULE_1__fs_adapter__","__WEBPACK_IMPORTED_MODULE_2__local_storage_adapter__","__WEBPACK_IMPORTED_MODULE_3__collection__","__WEBPACK_IMPORTED_MODULE_4__utils__","Loki","filename","collections","databaseVersion","engineVersion","autosave","autosaveInterval","autosaveHandle","serializationMethod","destructureDelimiter","persistenceMethod","persistenceAdapter","verbose","init","loaded","ENV","env","window","document","URL","clearChanges","defaultPersistence","NODEJS","BROWSER","CORDOVA","persistenceMethods","fs","localStorage","adapter","autosaveDisable","autoload","loadDatabase","inflate","Promise","resolve","then","autosaveEnable","clen","databaseCopy","loadJSONObject","retainDirtyFlags","removeNonSerializable","docs","collectionName","colls","type","count","tmpcol","curcol","serializeReplacer","serializeDestructured","serialize","sidx","resultlen","dbcopy","reconstruct","partitioned","delimited","delimiter","partition","serializeCollection","collectionIndex","join","doccount","docidx","resultlines","destructuredSource","cdb","collCount","currObject","workarray","collIndex","lineIndex","done","deserializeCollection","pop","serializedDb","dbObject","deserializeDestructured","coll","copyColl","loader","collObj","addCollection","inflater","collOptions","proto","colldv","addDynamicView","resultdata","resultsdirty","filterPipeline","sortCriteria","sortFunction","sortDirty","resultset","searchIsChained","filterInitialized","rematerialize","removeWhereFilters","saved","autosaveDirty","saveDatabase","arrayOfCollectionNames","getCollName","selectedCollections","concat","collectionNamesArray","generateChangesNotification","reject","dbString","loadJSON","exportDatabase","autosaveClearFlags","deleteDatabase","running","Plugins","containsCheckFn","doQueryOp","LokiOps","sortHelper","desc","__WEBPACK_IMPORTED_MODULE_3__helper__","compoundeval","properties","obj1","obj2","res","dotSubScan","paths","poffset","pathOffset","path","valueFound","element","__WEBPACK_IMPORTED_MODULE_0__clone__","__WEBPACK_IMPORTED_MODULE_1__collection__","__WEBPACK_IMPORTED_MODULE_2__utils__","$eq","$aeq","$ne","$dteq","$gt","$gte","$lt","$lte","$between","vals","$in","$nin","$keyin","$nkeyin","$definedin","$undefinedin","$regex","test","$containsString","$containsNone","$containsAny","checkFn","some","$contains","every","$type","$size","$len","$where","$not","$or","indexedOpsList","Resultset","qty","rscopy","pos","step","simplesort","compoundsort","limit","offset","leftJoinKey","rightJoinKey","mapReduce","collectionOptions","instanceCollection","comparefun","userComparer","propname","isdesc","props","expressionArray","fr","fri","frlen","docset","origCount","ei","elen","branch","findOr","arguments","findAnd","queryObjectOp","operator","queryObject","searchByIndex","RegExp","search","docIds","docId","usingDotNotation","t","rowIdx","segm","viewFunction","forceClones","forceCloneMethod","leftDataLength","rightDataLength","leftData","rightData","leftKeyisFunction","rightKeyisFunction","joinMap","left","right","LokiFsAdapter","dbname","stat","stats","isFile","readFile","encoding","dbstring","tmpdbname","writeFile","rename","unlink","localStorageAvailable","e","LokiLocalStorageAdapter","getItem","setItem","removeItem","LokiIndexedAdapter","appname","app","catalog","checkAvailability","indexedDB","appName","db","LokiCatalog","cat","getAppKey","saveCallback","success","rej","setAppKey","deleteAppKey","getDatabaseList","str","startsWith","callback","getAppKeys","names","getCatalogSummary","getAllKeys","size","oapp","okey","oval","entries","initializeLokiCatalog","openRequest","open","onupgradeneeded","thisDB","target","objectStoreNames","contains","deleteObjectStore","objectStore","createObjectStore","keyPath","autoIncrement","createIndex","onsuccess","onerror","transaction","store","appkey","request","usercallback","lres","requestPut","put","evt","singleKeyRange","IDBKeyRange","only","cursor","openCursor","localdata","continue","g","Function","eval","__WEBPACK_IMPORTED_MODULE_1__resultset__","DynamicView","rebuildPending","persistent","sortPriority","minRebuildInterval","cachedresultset","rebuild","fpl","fpi","ofp","applyFind","reset","queueSortPhase","criteria","uid","filters","_addFilter","queueRebuildEvent","_indexOfFilterWithId","reapplyFilters","applyFilter","performSortPhase","suppressRebuildEvent","objIndex","isNew","ofr","oldPos","oldlen","evalResultset","newPos","ExactIndex","exactField","idxSet","UniqueIndex","uniqueField","keyMap","lokiMap","fieldValue","old"],"mappings":"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","file":"loki.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/*\n 'listen' is not defined  no-undef\n */\n\n/**\n * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n * constructor that inherits EventEmitter to emit events and trigger\n * listeners that have been added to the event through the on(event, callback) method\n *\n * @constructor LokiEventEmitter\n */\nclass LokiEventEmitter {\n\n\tconstructor() {\n\t\t/**\n\t\t * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.events = {};\n\n\t\t/**\n\t\t * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n\t\t * should happen in an async fashion or not\n\t\t * Default is false, which means events are synchronous\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.asyncListeners = false;\n\t}\n\n\t/**\n\t * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\ton(eventName, listener) {\n\t\tvar event;\n\t\tvar self = this;\n\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach(function(currentEventName) {\n\t\t\t\tself.on(currentEventName, listener);\n\t\t\t});\n\t\t\treturn listener;\n\t\t}\n\n\t\tevent = this.events[eventName];\n\t\tif (!event) {\n\t\t\tevent = this.events[eventName] = [];\n\t\t}\n\t\tevent.push(listener);\n\t\treturn listener;\n\t}\n\n\t/**\n\t * emit(eventName, data) - emits a particular event\n\t * with the option of passing optional parameters which are going to be processed by the callback\n\t * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n\t * @param {string} eventName - the name of the event\n\t * @param {object=} data - optional object passed with the event\n\t * @memberof LokiEventEmitter\n\t */\n\temit(eventName, data) {\n\t\tvar self = this;\n\t\tif (eventName && this.events[eventName]) {\n\t\t\tthis.events[eventName].forEach(function(listener) {\n\t\t\t\tif (self.asyncListeners) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tlistener(data);\n\t\t\t\t\t}, 1);\n\t\t\t\t} else {\n\t\t\t\t\tlistener(data);\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Alias of LokiEventEmitter.prototype.on\n\t * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\taddListener(eventName, listener) {\n\t\treturn this.on(eventName, listener);\n\t}\n\n\t/**\n\t * removeListener() - removes the listener at position 'index' from the event 'eventName'\n\t * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n\t * @param {function} listener - the listener callback function to remove from emitter\n\t * @memberof LokiEventEmitter\n\t */\n\tremoveListener(eventName, listener) {\n\t\tvar self = this;\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach(function(currentEventName) {\n\t\t\t\tself.removeListener(currentEventName, listen);\n\t\t\t});\n\t\t}\n\n\t\tif (this.events[eventName]) {\n\t\t\tvar listeners = this.events[eventName];\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t}\n\t}\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = LokiEventEmitter;\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__event_emitter__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__unique_index__ = __webpack_require__(13);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__exact_index__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__resultset__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__dynamic_view__ = __webpack_require__(11);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__clone__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__helper__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__loki__ = __webpack_require__(5);\n\n\n\n\n\n\n\n\n\n/*\n 'isDeepProperty' is not defined              no-undef\n 'deepProperty' is not defined                no-undef\n 'average' is not defined                     no-undef\n 'standardDeviation' is not defined           no-undef\n 'sub' is not defined                         no-undef\n\n byExample?\n indexing -> own class?\n remove data only?\n */\n\n/**\n * General utils, including statistical functions\n */\nfunction isDeepProperty(field) {\n\treturn field.indexOf('.') !== -1;\n}\n\nfunction parseBase10(num) {\n\treturn parseFloat(num, 10);\n}\n\nfunction add(a, b) {\n\treturn a + b;\n}\n\nfunction sub(a, b) {\n\treturn a - b;\n}\n\nfunction average(array) {\n\treturn (array.reduce(add, 0)) / array.length;\n}\n\nfunction standardDeviation(values) {\n\tvar avg = average(values);\n\tvar squareDiffs = values.map(function(value) {\n\t\tvar diff = value - avg;\n\t\tvar sqrDiff = diff * diff;\n\t\treturn sqrDiff;\n\t});\n\n\tvar avgSquareDiff = average(squareDiffs);\n\n\tvar stdDev = Math.sqrt(avgSquareDiff);\n\treturn stdDev;\n}\n\nfunction deepProperty(obj, property, isDeep) {\n\tif (isDeep === false) {\n\t\t// pass without processing\n\t\treturn obj[property];\n\t}\n\tvar pieces = property.split('.'),\n\t\troot = obj;\n\twhile (pieces.length > 0) {\n\t\troot = root[pieces.shift()];\n\t}\n\treturn root;\n}\n\n/**\n * Collection class that handles documents of same type\n * @constructor Collection\n * @implements LokiEventEmitter\n * @param {string} name - collection name\n * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n * @param {array} options.unique - array of property names to define unique constraints for\n * @param {array} options.exact - array of property names to define exact constraints for\n * @param {array} options.indices - array property names to define binary indexes for\n * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily (default: true)\n * @param {boolean} options.asyncListeners - default is false\n * @param {boolean} options.disableChangesApi - default is true\n * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n * @see {@link Loki#addCollection} for normal creation of collections\n */\nclass Collection extends __WEBPACK_IMPORTED_MODULE_0__event_emitter__[\"a\" /* LokiEventEmitter */] {\n\n\tconstructor(name, options) {\n\t\tsuper();\n\t\t// the name of the collection\n\n\t\tthis.name = name;\n\t\t// the data held by the collection\n\t\tthis.data = [];\n\t\tthis.idIndex = []; // index of id\n\t\tthis.binaryIndices = {}; // user defined indexes\n\t\tthis.constraints = {\n\t\t\tunique: {},\n\t\t\texact: {}\n\t\t};\n\n\t\t// unique contraints contain duplicate object references, so they are not persisted.\n\t\t// we will keep track of properties which have unique contraint applied here, and regenerate on load\n\t\tthis.uniqueNames = [];\n\n\t\t// transforms will be used to store frequently used query chains as a series of steps\n\t\t// which itself can be stored along with the database.\n\t\tthis.transforms = {};\n\n\t\t// the object type of the collection\n\t\tthis.objType = name;\n\n\t\t// in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n\t\t// currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n\t\t// defaulting to true since this is called from addCollection and adding a collection should trigger save\n\t\tthis.dirty = true;\n\n\t\t// private holders for cached data\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\t\tvar self = this;\n\n\t\t/* OPTIONS */\n\t\toptions = options || {};\n\n\t\t// exact match and unique constraints\n\t\tif (options.hasOwnProperty('unique')) {\n\t\t\tif (!Array.isArray(options.unique)) {\n\t\t\t\toptions.unique = [options.unique];\n\t\t\t}\n\t\t\toptions.unique.forEach(function (prop) {\n\t\t\t\tself.uniqueNames.push(prop); // used to regenerate on subsequent database loads\n\t\t\t\tself.constraints.unique[prop] = new __WEBPACK_IMPORTED_MODULE_1__unique_index__[\"a\" /* UniqueIndex */](prop);\n\t\t\t});\n\t\t}\n\n\t\tif (options.hasOwnProperty('exact')) {\n\t\t\toptions.exact.forEach(function (prop) {\n\t\t\t\tself.constraints.exact[prop] = new __WEBPACK_IMPORTED_MODULE_2__exact_index__[\"a\" /* ExactIndex */](prop);\n\t\t\t});\n\t\t}\n\n\t\t// Inverted index\n\t\tthis._fullTextSearch = null;\n\t\tif (__WEBPACK_IMPORTED_MODULE_7__loki__[\"Loki\"].FullTextSearch !== undefined) {\n\t\t\tthis._fullTextSearch = options.hasOwnProperty('fullTextSearch')\n\t\t\t\t? new (__WEBPACK_IMPORTED_MODULE_7__loki__[\"Loki\"].FullTextSearch.FullTextSearch)(options.fullTextSearch) : null;\n\t\t}\n\n\t\t// if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n\t\t// if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n\t\tthis.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;\n\n\t\t// is collection transactional\n\t\tthis.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;\n\n\t\t// options to clone objects when inserting them\n\t\tthis.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;\n\n\t\t// default clone method (if enabled) is parse-stringify\n\t\tthis.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : \"parse-stringify\";\n\n\t\t// option to make event listeners async, default is sync\n\t\tthis.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;\n\n\t\t// disable track changes\n\t\tthis.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;\n\n\t\t// option to observe objects and update them automatically, ignored if Object.observe is not supported\n\t\tthis.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;\n\n\t\t//option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n\t\tthis.ttl = {\n\t\t\tage: null,\n\t\t\tttlInterval: null,\n\t\t\tdaemon: null\n\t\t};\n\t\tthis.setTTL(options.ttl || -1, options.ttlInterval);\n\n\t\t// currentMaxId - change manually at your own peril!\n\t\tthis.maxId = 0;\n\n\t\tthis.DynamicViews = [];\n\n\t\t// events\n\t\tthis.events = {\n\t\t\t'insert': [],\n\t\t\t'update': [],\n\t\t\t'pre-insert': [],\n\t\t\t'pre-update': [],\n\t\t\t'close': [],\n\t\t\t'flushbuffer': [],\n\t\t\t'error': [],\n\t\t\t'delete': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\t// changes are tracked by collection and aggregated by the db\n\t\tthis.changes = [];\n\n\t\t// initialize the id index\n\t\tthis.ensureId();\n\t\tvar indices = [];\n\t\t// initialize optional user-supplied indices array ['age', 'lname', 'zip']\n\t\tif (options && options.indices) {\n\t\t\tif (Object.prototype.toString.call(options.indices) === '[object Array]') {\n\t\t\t\tindices = options.indices;\n\t\t\t} else if (typeof options.indices === 'string') {\n\t\t\t\tindices = [options.indices];\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Indices needs to be a string or an array of strings');\n\t\t\t}\n\t\t}\n\n\t\tfor (var idx = 0; idx < indices.length; idx++) {\n\t\t\tthis.ensureIndex(indices[idx]);\n\t\t}\n\n\t\tfunction observerCallback(changes) {\n\n\t\t\tvar changedObjects = typeof Set === 'function' ? new Set() : [];\n\n\t\t\tif (!changedObjects.add)\n\t\t\t\tchangedObjects.add = function (object) {\n\t\t\t\t\tif (this.indexOf(object) === -1)\n\t\t\t\t\t\tthis.push(object);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\n\t\t\tchanges.forEach(function (change) {\n\t\t\t\tchangedObjects.add(change.object);\n\t\t\t});\n\n\t\t\tchangedObjects.forEach(function (object) {\n\t\t\t\tif (!hasOwnProperty.call(object, '$loki'))\n\t\t\t\t\treturn self.removeAutoUpdateObserver(object);\n\t\t\t\ttry {\n\t\t\t\t\tself.update(object);\n\t\t\t\t} catch (err) {\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.observerCallback = observerCallback;\n\n\t\t/*\n\t\t * This method creates a clone of the current status of an object and associates operation and collection name,\n\t\t * so the parent db can aggregate and generate a changes object for the entire db\n\t\t */\n\t\tfunction createChange(name, op, obj) {\n\t\t\tself.changes.push({\n\t\t\t\tname: name,\n\t\t\t\toperation: op,\n\t\t\t\tobj: JSON.parse(JSON.stringify(obj))\n\t\t\t});\n\t\t}\n\n\t\t// clear all the changes\n\t\tfunction flushChanges() {\n\t\t\tself.changes = [];\n\t\t}\n\n\t\tthis.getChanges = function () {\n\t\t\treturn self.changes;\n\t\t};\n\n\t\tthis.flushChanges = flushChanges;\n\n\t\t/**\n\t\t * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled\n\t\t */\n\t\tfunction insertMeta(obj) {\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!obj.meta) {\n\t\t\t\tobj.meta = {};\n\t\t\t}\n\n\t\t\tobj.meta.created = (new Date()).getTime();\n\t\t\tobj.meta.revision = 0;\n\t\t}\n\n\t\tfunction updateMeta(obj) {\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tobj.meta.updated = (new Date()).getTime();\n\t\t\tobj.meta.revision += 1;\n\t\t}\n\n\t\tfunction createInsertChange(obj) {\n\t\t\tcreateChange(self.name, 'I', obj);\n\t\t}\n\n\t\tfunction createUpdateChange(obj) {\n\t\t\tcreateChange(self.name, 'U', obj);\n\t\t}\n\n\t\tfunction insertMetaWithChange(obj) {\n\t\t\tinsertMeta(obj);\n\t\t\tcreateInsertChange(obj);\n\t\t}\n\n\t\tfunction updateMetaWithChange(obj) {\n\t\t\tupdateMeta(obj);\n\t\t\tcreateUpdateChange(obj);\n\t\t}\n\n\n\t\t/* assign correct handler based on ChangesAPI flag */\n\t\tvar insertHandler, updateHandler;\n\n\t\tfunction setHandlers() {\n\t\t\tinsertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;\n\t\t\tupdateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;\n\t\t}\n\n\t\tsetHandlers();\n\n\t\tthis.setChangesApi = function (enabled) {\n\t\t\tself.disableChangesApi = !enabled;\n\t\t\tsetHandlers();\n\t\t};\n\t\t/**\n\t\t * built-in events\n\t\t */\n\t\tthis.on('insert', function insertCallback(obj) {\n\t\t\tinsertHandler(obj);\n\t\t});\n\n\t\tthis.on('update', function updateCallback(obj) {\n\t\t\tupdateHandler(obj);\n\t\t});\n\n\t\tthis.on('delete', function deleteCallback(obj) {\n\t\t\tif (!self.disableChangesApi) {\n\t\t\t\tcreateChange(self.name, 'R', obj);\n\t\t\t}\n\t\t});\n\n\t\tthis.on('warning', function (warning) {\n\t\t\tself.console.warn(warning);\n\t\t});\n\t\t// for de-serialization purposes\n\t\tflushChanges();\n\n\t\tthis.console = {\n\t\t\tlog: function () {\n\t\t\t},\n\t\t\twarn: function () {\n\t\t\t},\n\t\t\terror: function () {\n\t\t\t},\n\t\t};\n\n\t\t/* ------ STAGING API -------- */\n\t\t/**\n\t\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t\t * manipulated without affecting the data in the original collection\n\t\t */\n\t\tthis.stages = {};\n\t\tthis.commitLog = [];\n\t}\n\n\taddAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n\t}\n\n\tremoveAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.unobserve(object, this.observerCallback);\n\t}\n\n\t/**\n\t * Adds a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {array} transform - an array of transformation 'step' objects to save into the collection\n\t * @memberof Collection\n\t */\n\taddTransform(name, transform) {\n\t\tif (this.transforms.hasOwnProperty(name)) {\n\t\t\tthrow new Error(\"a transform by that name already exists\");\n\t\t}\n\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Updates a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {object} transform - a transformation object to save into collection\n\t * @memberof Collection\n\t */\n\tsetTransform(name, transform) {\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Removes a named collection transform from the collection\n\t * @param {string} name - name of collection transform to remove\n\t * @memberof Collection\n\t */\n\tremoveTransform(name) {\n\t\tdelete this.transforms[name];\n\t}\n\n\tbyExample(template) {\n\t\tvar k, obj, query;\n\t\tquery = [];\n\t\tfor (k in template) {\n\t\t\tif (!template.hasOwnProperty(k)) continue;\n\t\t\tquery.push((\n\t\t\t\tobj = {},\n\t\t\t\t\tobj[k] = template[k],\n\t\t\t\t\tobj\n\t\t\t));\n\t\t}\n\t\treturn {\n\t\t\t'$and': query\n\t\t};\n\t}\n\n\tfindObject(template) {\n\t\treturn this.findOne(this.byExample(template));\n\t}\n\n\tfindObjects(template) {\n\t\treturn this.find(this.byExample(template));\n\t}\n\n\t/*----------------------------+\n\t | TTL daemon                  |\n\t +----------------------------*/\n\tttlDaemonFuncGen() {\n\t\tvar collection = this;\n\t\tvar age = this.ttl.age;\n\t\treturn function ttlDaemon() {\n\t\t\tvar now = Date.now();\n\t\t\tvar toRemove = collection.chain().where(function daemonFilter(member) {\n\t\t\t\tvar timestamp = member.meta.updated || member.meta.created;\n\t\t\t\tvar diff = now - timestamp;\n\t\t\t\treturn age < diff;\n\t\t\t});\n\t\t\ttoRemove.remove();\n\t\t};\n\t}\n\n\tsetTTL(age, interval) {\n\t\tif (age < 0) {\n\t\t\tclearInterval(this.ttl.daemon);\n\t\t} else {\n\t\t\tthis.ttl.age = age;\n\t\t\tthis.ttl.ttlInterval = interval;\n\t\t\tthis.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n\t\t}\n\t}\n\n\t/*----------------------------+\n\t | INDEXING                    |\n\t +----------------------------*/\n\n\t/**\n\t * create a row filter that covers all documents in the collection\n\t */\n\tprepareFullDocIndex() {\n\t\tvar len = this.data.length;\n\t\tvar indexes = new Array(len);\n\t\tfor (var i = 0; i < len; i += 1) {\n\t\t\tindexes[i] = i;\n\t\t}\n\t\treturn indexes;\n\t}\n\n\t/**\n\t * Will allow reconfiguring certain collection options.\n\t * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n\t * @memberof Collection\n\t */\n\tconfigureOptions(options) {\n\t\toptions = options || {};\n\n\t\tif (options.hasOwnProperty('adaptiveBinaryIndices')) {\n\t\t\tthis.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\n\t\t\t// if switching to adaptive binary indices, make sure none are 'dirty'\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\tthis.ensureAllIndexes();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ensure binary index on a certain field\n\t * @param {string} property - name of property to create binary index on\n\t * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n\t * @memberof Collection\n\t */\n\tensureIndex(property, force) {\n\t\t// optional parameter to force rebuild whether flagged as dirty or not\n\t\tif (typeof(force) === 'undefined') {\n\t\t\tforce = false;\n\t\t}\n\n\t\tif (property === null || property === undefined) {\n\t\t\tthrow new Error('Attempting to set index without an associated property');\n\t\t}\n\n\t\tif (this.binaryIndices[property] && !force) {\n\t\t\tif (!this.binaryIndices[property].dirty) return;\n\t\t}\n\n\t\t// if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n\t\tif (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar index = {\n\t\t\t'name': property,\n\t\t\t'dirty': true,\n\t\t\t'values': this.prepareFullDocIndex()\n\t\t};\n\t\tthis.binaryIndices[property] = index;\n\n\t\tvar wrappedComparer =\n\t\t\t(function (p, data) {\n\t\t\t\treturn function (a, b) {\n\t\t\t\t\tvar objAp = data[a][p],\n\t\t\t\t\t\tobjBp = data[b][p];\n\t\t\t\t\tif (objAp !== objBp) {\n\t\t\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(objAp, objBp, false)) return -1;\n\t\t\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"b\" /* gtHelper */])(objAp, objBp, false)) return 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\t})(property, this.data);\n\n\t\tindex.values.sort(wrappedComparer);\n\t\tindex.dirty = false;\n\n\t\tthis.dirty = true; // for autosave scenarios\n\t}\n\n\tgetSequencedIndexValues(property) {\n\t\tvar idx, idxvals = this.binaryIndices[property].values;\n\t\tvar result = \"\";\n\n\t\tfor (idx = 0; idx < idxvals.length; idx++) {\n\t\t\tresult += \" [\" + idx + \"] \" + this.data[idxvals[idx]][property];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tensureUniqueIndex(field) {\n\t\tvar index = this.constraints.unique[field];\n\t\tif (!index) {\n\t\t\t// keep track of new unique index for regenerate after database (re)load.\n\t\t\tif (this.uniqueNames.indexOf(field) == -1) {\n\t\t\t\tthis.uniqueNames.push(field);\n\t\t\t}\n\t\t}\n\n\t\t// if index already existed, (re)loading it will likely cause collisions, rebuild always\n\t\tthis.constraints.unique[field] = index = new __WEBPACK_IMPORTED_MODULE_1__unique_index__[\"a\" /* UniqueIndex */](field);\n\t\tthis.data.forEach(function (obj) {\n\t\t\tindex.set(obj);\n\t\t});\n\t\treturn index;\n\t}\n\n\t/**\n\t * Ensure all binary indices\n\t */\n\tensureAllIndexes(force) {\n\t\tvar key, bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\tthis.ensureIndex(key, force);\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexesDirty() {\n\t\tvar key, bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\tbIndices[key].dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexDirty(index) {\n\t\tif (this.binaryIndices[index])\n\t\t\tthis.binaryIndices[index].dirty = true;\n\t}\n\n\t/**\n\t * Quickly determine number of documents in collection (or query)\n\t * @param {object=} query - (optional) query object to count results of\n\t * @returns {number} number of documents in the collection\n\t * @memberof Collection\n\t */\n\tcount(query) {\n\t\tif (!query) {\n\t\t\treturn this.data.length;\n\t\t}\n\n\t\treturn this.chain().find(query).filteredrows.length;\n\t}\n\n\t/**\n\t * Rebuild idIndex\n\t */\n\tensureId() {\n\t\tvar len = this.data.length,\n\t\t\ti = 0;\n\n\t\tthis.idIndex = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tthis.idIndex.push(this.data[i].$loki);\n\t\t}\n\t}\n\n\t/**\n\t * Add a dynamic view to the collection\n\t * @param {string} name - name of dynamic view to add\n\t * @param {object=} options - (optional) options to configure dynamic view with\n\t * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t * @returns {DynamicView} reference to the dynamic view added\n\t * @memberof Collection\n\t **/\n\taddDynamicView(name, options) {\n\t\tvar dv = new __WEBPACK_IMPORTED_MODULE_4__dynamic_view__[\"a\" /* DynamicView */](this, name, options);\n\t\tthis.DynamicViews.push(dv);\n\n\t\treturn dv;\n\t}\n\n\t/**\n\t * Remove a dynamic view from the collection\n\t * @param {string} name - name of dynamic view to remove\n\t * @memberof Collection\n\t **/\n\tremoveDynamicView(name) {\n\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\tthis.DynamicViews.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Look up dynamic view reference from within the collection\n\t * @param {string} name - name of dynamic view to retrieve reference of\n\t * @returns {DynamicView} A reference to the dynamic view with that name\n\t * @memberof Collection\n\t **/\n\tgetDynamicView(name) {\n\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\treturn this.DynamicViews[idx];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object and passes all results to an update function.\n\t * For filter function querying you should migrate to [\n\t * Where()]{@link Collection#updateWhere}.\n\t *\n\t * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tfindAndUpdate(filterObject, updateFunction) {\n\t\tif (typeof(filterObject) === \"function\") {\n\t\t\tthis.updateWhere(filterObject, updateFunction);\n\t\t} else {\n\t\t\tthis.chain().find(filterObject).update(updateFunction);\n\t\t}\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object removes all documents which match that filter.\n\t *\n\t * @param {object} filterObject - 'mongo-like' query object\n\t * @memberof Collection\n\t */\n\tfindAndRemove(filterObject) {\n\t\tthis.chain().find(filterObject).remove();\n\t}\n\n\t/**\n\t * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n\t * @param {(object|array)} doc - the document (or array of documents) to be inserted\n\t * @returns {(object|array)} document or documents inserted\n\t * @memberof Collection\n\t */\n\tinsert(doc) {\n\t\tif (!Array.isArray(doc)) {\n\t\t\treturn this.insertOne(doc);\n\t\t}\n\n\t\t// holder to the clone of the object inserted if collections is set to clone objects\n\t\tvar obj;\n\t\tvar results = [];\n\n\t\tthis.emit('pre-insert', doc);\n\t\tfor (var i = 0, len = doc.length; i < len; i++) {\n\t\t\tobj = this.insertOne(doc[i], true);\n\t\t\tif (!obj) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tresults.push(obj);\n\t\t}\n\t\tthis.emit('insert', doc);\n\t\treturn results.length === 1 ? results[0] : results;\n\t}\n\n\t/**\n\t * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n\t * @param {object} doc - the document to be inserted\n\t * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n\t * @returns {object} document or 'undefined' if there was a problem inserting it\n\t * @memberof Collection\n\t */\n\tinsertOne(doc, bulkInsert) {\n\t\tvar err = null;\n\t\tvar returnObj;\n\n\t\tif (typeof doc !== 'object') {\n\t\t\terr = new TypeError('Document needs to be an object');\n\t\t} else if (doc === null) {\n\t\t\terr = new TypeError('Object cannot be null');\n\t\t}\n\n\t\tif (err !== null) {\n\t\t\tthis.emit('error', err);\n\t\t\tthrow err;\n\t\t}\n\n\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\tvar obj = this.cloneObjects ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"a\" /* clone */])(doc, this.cloneMethod) : doc;\n\n\t\tif (typeof obj.meta === 'undefined') {\n\t\t\tobj.meta = {\n\t\t\t\trevision: 0,\n\t\t\t\tcreated: 0\n\t\t\t};\n\t\t}\n\n\t\t// allow pre-insert to modify actual collection reference even if cloning\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('pre-insert', obj);\n\t\t}\n\t\tif (!this.add(obj)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// FullTextSearch.\n\t\tif (this._fullTextSearch !== null) {\n\t\t\tthis._fullTextSearch.addDocument(doc);\n\t\t}\n\n\t\t// if cloning, give user back clone of 'cloned' object with $loki and meta\n\t\treturnObj = this.cloneObjects ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"a\" /* clone */])(obj, this.cloneMethod) : obj;\n\n\t\tthis.addAutoUpdateObserver(returnObj);\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('insert', returnObj);\n\t\t}\n\t\treturn returnObj;\n\t}\n\n\t/**\n\t * Empties the collection.\n\t * @param {object=} options - configure clear behavior\n\t * @param {bool=} options.removeIndices - (default: false)\n\t * @memberof Collection\n\t */\n\tclear(options) {\n\t\tvar self = this;\n\n\t\toptions = options || {};\n\n\t\tthis.data = [];\n\t\tthis.idIndex = [];\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\t\tthis.maxId = 0;\n\t\tthis.DynamicViews = [];\n\t\tthis.dirty = true;\n\n\t\t// if removing indices entirely\n\t\tif (options.removeIndices === true) {\n\t\t\tthis.binaryIndices = {};\n\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\t\t\tthis.uniqueNames = [];\n\t\t}\n\t\t// clear indices but leave definitions in place\n\t\telse {\n\t\t\t// clear binary indices\n\t\t\tvar keys = Object.keys(this.binaryIndices);\n\t\t\tkeys.forEach(function (biname) {\n\t\t\t\tself.binaryIndices[biname].dirty = false;\n\t\t\t\tself.binaryIndices[biname].values = [];\n\t\t\t});\n\n\t\t\t// clear entire unique indices definition\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\n\t\t\t// add definitions back\n\t\t\tthis.uniqueNames.forEach(function (uiname) {\n\t\t\t\tself.ensureUniqueIndex(uiname);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Updates an object and notifies collection that the document has changed.\n\t * @param {object} doc - document to update within the collection\n\t * @memberof Collection\n\t */\n\tupdate(doc) {\n\t\tif (Array.isArray(doc)) {\n\t\t\tvar k = 0,\n\t\t\t\tlen = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.update(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify object is a properly formed document\n\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\tthrow new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n\t\t}\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tvar arr = this.get(doc.$loki, true),\n\t\t\t\toldInternal, // ref to existing obj\n\t\t\t\tnewInternal, // ref to new internal obj\n\t\t\t\tposition,\n\t\t\t\tself = this;\n\n\t\t\tif (!arr) {\n\t\t\t\tthrow new Error('Trying to update a document not in collection.');\n\t\t\t}\n\n\t\t\toldInternal = arr[0]; // -internal- obj ref\n\t\t\tposition = arr[1]; // position in data array\n\n\t\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\t\tnewInternal = this.cloneObjects ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"a\" /* clone */])(doc, this.cloneMethod) : doc;\n\n\t\t\tthis.emit('pre-update', doc);\n\n\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\tself.constraints.unique[key].update(oldInternal, newInternal);\n\t\t\t});\n\n\t\t\t// operate the update\n\t\t\tthis.data[position] = newInternal;\n\n\t\t\tif (newInternal !== doc) {\n\t\t\t\tthis.addAutoUpdateObserver(doc);\n\t\t\t}\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].evaluateDocument(position, false);\n\t\t\t}\n\n\t\t\tvar key;\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexUpdate(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.idIndex[position] = newInternal.$loki;\n\t\t\t//this.flagBinaryIndexesDirty();\n\n\t\t\t// FullTextSearch.\n\t\t\tif (this._fullTextSearch !== null) {\n\t\t\t\tthis._fullTextSearch.updateDocument(doc);\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\tthis.emit('update', doc, this.cloneObjects ? __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"a\" /* clone */])(oldInternal, this.cloneMethod) : null);\n\t\t\treturn doc;\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Add object to collection\n\t */\n\tadd(obj) {\n\t\t// if parameter isn't object exit with throw\n\t\tif ('object' !== typeof obj) {\n\t\t\tthrow new TypeError('Object being added needs to be an object');\n\t\t}\n\t\t// if object you are adding already has id column it is either already in the collection\n\t\t// or the object is carrying its own 'id' property.  If it also has a meta property,\n\t\t// then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n\t\tif (typeof(obj.$loki) !== 'undefined') {\n\t\t\tthrow new Error('Document is already in collection, please use update()');\n\t\t}\n\n\t\t/*\n\t\t * try adding object to collection\n\t\t */\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tthis.maxId++;\n\n\t\t\tif (isNaN(this.maxId)) {\n\t\t\t\tthis.maxId = (this.data[this.data.length - 1].$loki + 1);\n\t\t\t}\n\n\t\t\tobj.$loki = this.maxId;\n\t\t\tobj.meta.version = 0;\n\n\t\t\tvar key, constrUnique = this.constraints.unique;\n\t\t\tfor (key in constrUnique) {\n\t\t\t\tif (hasOwnProperty.call(constrUnique, key)) {\n\t\t\t\t\tconstrUnique[key].set(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add new obj id to idIndex\n\t\t\tthis.idIndex.push(obj.$loki);\n\n\t\t\t// add the object\n\t\t\tthis.data.push(obj);\n\n\t\t\tvar addedPos = this.data.length - 1;\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tvar dvlen = this.DynamicViews.length;\n\t\t\tfor (var i = 0; i < dvlen; i++) {\n\t\t\t\tthis.DynamicViews[i].evaluateDocument(addedPos, true);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexInsert(addedPos, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\treturn (this.cloneObjects) ? (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"a\" /* clone */])(obj, this.cloneMethod)) : (obj);\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Applies a filter function and passes all results to an update function.\n\t *\n\t * @param {function} filterFunction - filter function whose results will execute update\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tupdateWhere(filterFunction, updateFunction) {\n\t\tvar results = this.where(filterFunction),\n\t\t\ti = 0,\n\t\t\tobj;\n\t\ttry {\n\t\t\tfor (i; i < results.length; i++) {\n\t\t\t\tobj = updateFunction(results[i]);\n\t\t\t\tthis.update(obj);\n\t\t\t}\n\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t}\n\t}\n\n\t/**\n\t * Remove all documents matching supplied filter function.\n\t * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n\t * @param {function|object} query - query object to filter on\n\t * @memberof Collection\n\t */\n\tremoveWhere(query) {\n\t\tvar list;\n\t\tif (typeof query === 'function') {\n\t\t\tlist = this.data.filter(query);\n\t\t\tthis.remove(list);\n\t\t} else {\n\t\t\tthis.chain().find(query).remove();\n\t\t}\n\t}\n\n\tremoveDataOnly() {\n\t\tthis.remove(this.data.slice());\n\t}\n\n\t/**\n\t * Remove a document from the collection\n\t * @param {object} doc - document to remove from collection\n\t * @memberof Collection\n\t */\n\tremove(doc) {\n\t\tif (typeof doc === 'number') {\n\t\t\tdoc = this.get(doc);\n\t\t}\n\n\t\tif ('object' !== typeof doc) {\n\t\t\tthrow new Error('Parameter is not an object');\n\t\t}\n\t\tif (Array.isArray(doc)) {\n\t\t\tvar k = 0,\n\t\t\t\tlen = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.remove(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\tthrow new Error('Object is not a document stored in the collection');\n\t\t}\n\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tvar arr = this.get(doc.$loki, true),\n\t\t\t\t// obj = arr[0],\n\t\t\t\tposition = arr[1];\n\t\t\tvar self = this;\n\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\tif (doc[key] !== null && typeof doc[key] !== 'undefined') {\n\t\t\t\t\tself.constraints.unique[key].remove(doc[key]);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to remove\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].removeDocument(position);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar key, bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexRemove(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.data.splice(position, 1);\n\t\t\tthis.removeAutoUpdateObserver(doc);\n\n\t\t\t// remove id from idIndex\n\t\t\tthis.idIndex.splice(position, 1);\n\n\t\t\t// FullTextSearch.\n\t\t\tif (this._fullTextSearch != null) {\n\t\t\t\tthis._fullTextSearch.removeDocument(doc);\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\t\t\tthis.emit('delete', arr[0]);\n\t\t\tdelete doc.$loki;\n\t\t\tdelete doc.meta;\n\t\t\treturn doc;\n\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/*---------------------+\n\t | Finding methods     |\n\t +----------------------*/\n\n\t/**\n\t * Get by Id - faster than other methods because of the searching algorithm\n\t * @param {int} id - $loki id of document you want to retrieve\n\t * @param {boolean} returnPosition - if 'true' we will return [object, position]\n\t * @returns {(object|array|null)} Object reference if document was found, null if not,\n\t *     or an array if 'returnPosition' was passed.\n\t * @memberof Collection\n\t */\n\tget(id, returnPosition) {\n\t\tvar retpos = returnPosition || false,\n\t\t\tdata = this.idIndex,\n\t\t\tmax = data.length - 1,\n\t\t\tmin = 0,\n\t\t\tmid = (min + max) >> 1;\n\n\t\tid = typeof id === 'number' ? id : parseInt(id, 10);\n\n\t\tif (isNaN(id)) {\n\t\t\tthrow new TypeError('Passed id is not an integer');\n\t\t}\n\n\t\twhile (data[min] < data[max]) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (data[mid] < id) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tif (max === min && data[min] === id) {\n\t\t\tif (retpos) {\n\t\t\t\treturn [this.data[min], min];\n\t\t\t}\n\t\t\treturn this.data[min];\n\t\t}\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n\t *    Since multiple documents may contain the same value (which the index is sorted on),\n\t *    we hone in on range and then linear scan range to find exact index array position.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tgetBinaryIndexPosition(dataPosition, binaryIndexName) {\n\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\n\t\t// i think calculateRange can probably be moved to collection\n\t\t// as it doesn't seem to need resultset.  need to verify\n\t\t//var rs = new Resultset(this, null, null);\n\t\tvar range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n\t\tif (range[0] === 0 && range[1] === -1) {\n\t\t\t// uhoh didn't find range\n\t\t\treturn null;\n\t\t}\n\n\t\tvar min = range[0];\n\t\tvar max = range[1];\n\n\t\t// narrow down the sub-segment of index values\n\t\t// where the indexed property value exactly matches our\n\t\t// value and then linear scan to find exact -index- position\n\t\tfor (var idx = min; idx <= max; idx++) {\n\t\t\tif (index[idx] === dataPosition) return idx;\n\t\t}\n\n\t\t// uhoh\n\t\treturn null;\n\t}\n\n\t/**\n\t * Adaptively insert a selected item to the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexInsert(dataPosition, binaryIndexName) {\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\t//var rs = new Resultset(this, null, null);\n\t\tvar idxPos = this.calculateRangeStart(binaryIndexName, val);\n\n\t\t// insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n\t\t// doing this after adjusting dataPositions so no clash with previous item at that position.\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n\t}\n\n\t/**\n\t * Adaptively update a selected item within an index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexUpdate(dataPosition, binaryIndexName) {\n\t\t// linear scan needed to find old position within index unless we optimize for clone scenarios later\n\t\t// within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n\t\tvar idxPos,\n\t\t\tindex = this.binaryIndices[binaryIndexName].values,\n\t\t\tlen = index.length;\n\n\t\tfor (idxPos = 0; idxPos < len; idxPos++) {\n\t\t\tif (index[idxPos] === dataPosition) break;\n\t\t}\n\n\t\t//var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t//this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n\t\tthis.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n\t}\n\n\t/**\n\t * Adaptively remove a selected item from the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexRemove(dataPosition, binaryIndexName, removedFromIndexOnly) {\n\t\tvar idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\tvar len,\n\t\t\tidx;\n\n\t\tif (idxPos === null) {\n\t\t\t// throw new Error('unable to determine binary index position');\n\t\t\treturn null;\n\t\t}\n\n\t\t// remove document from index\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t// if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n\t\t// in which case data positions stay the same.\n\t\tif (removedFromIndexOnly === true) {\n\t\t\treturn;\n\t\t}\n\n\t\t// since index stores data array positions, if we remove a document\n\t\t// we need to adjust array positions -1 for all document positions greater than removed position\n\t\tlen = index.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tif (index[idx] > dataPosition) {\n\t\t\t\tindex[idx]--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method used for index maintenance.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the proper location where it can be added.\n\t */\n\tcalculateRangeStart(prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(rcd[index[mid]][prop], val, false)) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tvar lbound = min;\n\n\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(rcd[index[lbound]][prop], val, false)) {\n\t\t\treturn lbound + 1;\n\t\t} else {\n\t\t\treturn lbound;\n\t\t}\n\t}\n\n\t/**\n\t * Internal method used for indexed $between.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the final position of that upper range value.\n\t */\n\tcalculateRangeEnd(prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(val, rcd[index[mid]][prop], false)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tvar ubound = max;\n\n\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"b\" /* gtHelper */])(rcd[index[ubound]][prop], val, false)) {\n\t\t\treturn ubound - 1;\n\t\t} else {\n\t\t\treturn ubound;\n\t\t}\n\t}\n\n\t/**\n\t * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n\t *    this is used for collection.find() and first find filter of resultset/dynview\n\t *    slightly different than get() binary search in that get() hones in on 1 value,\n\t *    but we have to hone in on many (range)\n\t * @param {string} op - operation, such as $eq\n\t * @param {string} prop - name of property to calculate range for\n\t * @param {object} val - value to use for range calculation.\n\t * @returns {array} [start, end] index array positions\n\t */\n\tcalculateRange(op, prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\t// when no documents are in collection, return empty range condition\n\t\tif (rcd.length === 0) {\n\t\t\treturn [0, -1];\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// if value falls outside of our range return [0, -1] to designate no results\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\tcase '$aeq':\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(val, minVal, false) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"b\" /* gtHelper */])(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$dteq':\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(val, minVal, false) || __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"b\" /* gtHelper */])(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gt':\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"b\" /* gtHelper */])(val, maxVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gte':\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"b\" /* gtHelper */])(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lt':\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(val, minVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(maxVal, val, false)) {\n\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lte':\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(val, minVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(maxVal, val, true)) {\n\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$between':\n\t\t\t\treturn ([this.calculateRangeStart(prop, val[0]), this.calculateRangeEnd(prop, val[1])]);\n\t\t\tcase '$in':\n\t\t\t\tvar idxset = [],\n\t\t\t\t\tsegResult = [];\n\t\t\t\t// query each value '$eq' operator and merge the seqment results.\n\t\t\t\tfor (var j = 0, len = val.length; j < len; j++) {\n\t\t\t\t\tvar seg = this.calculateRange('$eq', prop, val[j]);\n\n\t\t\t\t\tfor (var i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\tif (idxset[i] === undefined) {\n\t\t\t\t\t\t\tidxset[i] = true;\n\t\t\t\t\t\t\tsegResult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn segResult;\n\t\t}\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(rcd[index[mid]][prop], val, false)) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tvar lbound = min;\n\n\t\t// do not reset min, as the upper bound cannot be prior to the found low bound\n\t\tmax = index.length - 1;\n\n\t\t// hone in on end position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(val, rcd[index[mid]][prop], false)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tvar ubound = max;\n\n\t\tvar lval = rcd[index[lbound]][prop];\n\t\tvar uval = rcd[index[ubound]][prop];\n\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\t\tif (lval !== val) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (uval !== val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, ubound];\n\t\t\tcase '$dteq':\n\t\t\t\tif (lval > val || lval < val) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (uval > val || uval < val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, ubound];\n\n\n\t\t\tcase '$gt':\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(uval, val, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\treturn [ubound, rcd.length - 1];\n\n\t\t\tcase '$gte':\n\t\t\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(lval, val, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, rcd.length - 1];\n\n\t\t\tcase '$lt':\n\t\t\t\tif (lbound === 0 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(lval, val, false)) {\n\t\t\t\t\treturn [0, 0];\n\t\t\t\t}\n\t\t\t\treturn [0, lbound - 1];\n\n\t\t\tcase '$lte':\n\t\t\t\tif (uval !== val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\tif (ubound === 0 && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_6__helper__[\"a\" /* ltHelper */])(uval, val, false)) {\n\t\t\t\t\treturn [0, 0];\n\t\t\t\t}\n\t\t\t\treturn [0, ubound];\n\n\t\t\tdefault:\n\t\t\t\treturn [0, rcd.length - 1];\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve doc by Unique index\n\t * @param {string} field - name of uniquely indexed property to use when doing lookup\n\t * @param {value} value - unique value to search for\n\t * @returns {object} document matching the value passed\n\t * @memberof Collection\n\t */\n\tby(field, value) {\n\t\tvar self;\n\t\tif (value === undefined) {\n\t\t\tself = this;\n\t\t\treturn function (value) {\n\t\t\t\treturn self.by(field, value);\n\t\t\t};\n\t\t}\n\n\t\tvar result = this.constraints.unique[field].get(value);\n\t\tif (!this.cloneObjects) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"a\" /* clone */])(result, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Find one object by index property, by property equal to value\n\t * @param {object} query - query object used to perform search with\n\t * @returns {(object|null)} First matching document, or null if none\n\t * @memberof Collection\n\t */\n\tfindOne(query) {\n\t\tquery = query || {};\n\n\t\t// Instantiate Resultset and exec find op passing firstOnly = true param\n\t\tvar result = new __WEBPACK_IMPORTED_MODULE_3__resultset__[\"a\" /* Resultset */](this, {\n\t\t\tqueryObj: query,\n\t\t\tfirstOnly: true\n\t\t});\n\n\t\tif (Array.isArray(result) && result.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif (!this.cloneObjects) {\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"a\" /* clone */])(result, this.cloneMethod);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Chain method, used for beginning a series of chained find() and/or view() operations\n\t * on a collection.\n\t *\n\t * @param {array} transform - Ordered array of transform step objects similar to chain\n\t * @param {object} parameters - Object containing properties representing parameters to substitute\n\t * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n\t * @memberof Collection\n\t */\n\tchain(transform, parameters) {\n\t\tvar rs = new __WEBPACK_IMPORTED_MODULE_3__resultset__[\"a\" /* Resultset */](this);\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t}\n\n\t/**\n\t * Find method, api is similar to mongodb.\n\t * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n\t * @example {@tutorial Query Examples}\n\t * @param {object} query - 'mongo-like' query object\n\t * @returns {array} Array of matching documents\n\t * @memberof Collection\n\t */\n\tfind(query) {\n\t\tif (typeof(query) === 'undefined') {\n\t\t\tquery = 'getAll';\n\t\t}\n\n\t\tvar results = new __WEBPACK_IMPORTED_MODULE_3__resultset__[\"a\" /* Resultset */](this, {\n\t\t\tqueryObj: query\n\t\t});\n\t\tif (!this.cloneObjects) {\n\t\t\treturn results;\n\t\t} else {\n\t\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"b\" /* cloneObjectArray */])(results, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Find object by unindexed field by property equal to value,\n\t * simply iterates and returns the first element matching the query\n\t */\n\tfindOneUnindexed(prop, value) {\n\t\tvar i = this.data.length,\n\t\t\tdoc;\n\t\twhile (i--) {\n\t\t\tif (this.data[i][prop] === value) {\n\t\t\t\tdoc = this.data[i];\n\t\t\t\treturn doc;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Transaction methods\n\t */\n\n\t/** start the transation */\n\tstartTransaction() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"a\" /* clone */])(this.data, this.cloneMethod);\n\t\t\tthis.cachedIndex = this.idIndex;\n\t\t\tthis.cachedBinaryIndex = this.binaryIndices;\n\n\t\t\t// propagate startTransaction to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].startTransaction();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** commit the transation */\n\tcommit() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = null;\n\t\t\tthis.cachedIndex = null;\n\t\t\tthis.cachedBinaryIndex = null;\n\n\t\t\t// propagate commit to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].commit();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** roll back the transation */\n\trollback() {\n\t\tif (this.transactional) {\n\t\t\tif (this.cachedData !== null && this.cachedIndex !== null) {\n\t\t\t\tthis.data = this.cachedData;\n\t\t\t\tthis.idIndex = this.cachedIndex;\n\t\t\t\tthis.binaryIndices = this.cachedBinaryIndex;\n\t\t\t}\n\n\t\t\t// propagate rollback to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].rollback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query the collection by supplying a javascript filter function.\n\t * @example\n\t * var results = coll.where(function(obj) {\n\t *   return obj.legs === 8;\n\t * });\n\t *\n\t * @param {function} fun - filter function to run against all collection docs\n\t * @returns {array} all documents which pass your filter function\n\t * @memberof Collection\n\t */\n\twhere(fun) {\n\t\tvar results = new __WEBPACK_IMPORTED_MODULE_3__resultset__[\"a\" /* Resultset */](this, {\n\t\t\tqueryFunc: fun\n\t\t});\n\t\tif (!this.cloneObjects) {\n\t\t\treturn results;\n\t\t} else {\n\t\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_5__clone__[\"b\" /* cloneObjectArray */])(results, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Map Reduce operation\n\t *\n\t * @param {function} mapFunction - function to use as map function\n\t * @param {function} reduceFunction - function to use as reduce function\n\t * @returns {data} The result of your mapReduce operation\n\t * @memberof Collection\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data.map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Join two collections on specified properties\n\t *\n\t * @param {array} joinData - array of documents to 'join' to this collection\n\t * @param {string} leftJoinProp - property name in collection\n\t * @param {string} rightJoinProp - property name in joinData\n\t * @param {function=} mapFun - (Optional) map function to use\n\t * @returns {Resultset} Result of the mapping operation\n\t * @memberof Collection\n\t */\n\teqJoin(joinData, leftJoinProp, rightJoinProp, mapFun) {\n\t\t// logic in Resultset class\n\t\treturn new __WEBPACK_IMPORTED_MODULE_3__resultset__[\"a\" /* Resultset */](this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);\n\t}\n\n\t/* ------ STAGING API -------- */\n\t/**\n\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t * manipulated without affecting the data in the original collection\n\t */\n\n\n\t/**\n\t * (Staging API) create a stage and/or retrieve it\n\t * @memberof Collection\n\t */\n\tgetStage(name) {\n\t\tif (!this.stages[name]) {\n\t\t\tthis.stages[name] = {};\n\t\t}\n\t\treturn this.stages[name];\n\t}\n\n\t/**\n\t * a collection of objects recording the changes applied through a commmitStage\n\t */\n\n\t/**\n\t * (Staging API) create a copy of an object and insert it into a stage\n\t * @memberof Collection\n\t */\n\tstage(stageName, obj) {\n\t\tvar copy = JSON.parse(JSON.stringify(obj));\n\t\tthis.getStage(stageName)[obj.$loki] = copy;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n\t * then create a message to be inserted in the commitlog\n\t * @param {string} stageName - name of stage\n\t * @param {string} message\n\t * @memberof Collection\n\t */\n\tcommitStage(stageName, message) {\n\t\tvar stage = this.getStage(stageName),\n\t\t\tprop,\n\t\t\ttimestamp = new Date().getTime();\n\n\t\tfor (prop in stage) {\n\n\t\t\tthis.update(stage[prop]);\n\t\t\tthis.commitLog.push({\n\t\t\t\ttimestamp: timestamp,\n\t\t\t\tmessage: message,\n\t\t\t\tdata: JSON.parse(JSON.stringify(stage[prop]))\n\t\t\t});\n\t\t}\n\t\tthis.stages[stageName] = {};\n\t}\n\n\tno_op() {\n\t\treturn;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textract(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tisDotNotation = isDeepProperty(field),\n\t\t\tresult = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tresult.push(deepProperty(this.data[i], field, isDotNotation));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmax(field) {\n\t\treturn Math.max.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmin(field) {\n\t\treturn Math.min.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmaxRecord(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tdeep = isDeepProperty(field),\n\t\t\tresult = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\tmax;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (max !== undefined) {\n\t\t\t\tif (max < deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = max;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tminRecord(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tdeep = isDeepProperty(field),\n\t\t\tresult = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\tmin;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (min !== undefined) {\n\t\t\t\tif (min > deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = min;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textractNumerical(field) {\n\t\treturn this.extract(field).map(parseBase10).filter(Number).filter(function (n) {\n\t\t\treturn !(isNaN(n));\n\t\t});\n\t}\n\n\t/**\n\t * Calculates the average numerical value of a property\n\t *\n\t * @param {string} field - name of property in docs to average\n\t * @returns {number} average of property in all docs in the collection\n\t * @memberof Collection\n\t */\n\tavg(field) {\n\t\treturn average(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * Calculate standard deviation of a field\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tstdDev(field) {\n\t\treturn standardDeviation(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tmode(field) {\n\t\tvar dict = {},\n\t\t\tdata = this.extract(field);\n\t\tdata.forEach(function (obj) {\n\t\t\tif (dict[obj]) {\n\t\t\t\tdict[obj] += 1;\n\t\t\t} else {\n\t\t\t\tdict[obj] = 1;\n\t\t\t}\n\t\t});\n\t\tvar max,\n\t\t\tprop, mode;\n\t\tfor (prop in dict) {\n\t\t\tif (max) {\n\t\t\t\tif (max < dict[prop]) {\n\t\t\t\t\tmode = prop;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmode = prop;\n\t\t\t\tmax = dict[prop];\n\t\t\t}\n\t\t}\n\t\treturn mode;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field - property name\n\t */\n\tmedian(field) {\n\t\tvar values = this.extractNumerical(field);\n\t\tvalues.sort(sub);\n\n\t\tvar half = Math.floor(values.length / 2);\n\n\t\tif (values.length % 2) {\n\t\t\treturn values[half];\n\t\t} else {\n\t\t\treturn (values[half - 1] + values[half]) / 2.0;\n\t\t}\n\t}\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Collection;\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Utils; });\n/**\n * Created by toni on 1/27/17.\n */\n\n\nvar Utils = {\n\tcopyProperties: function(src, dest) {\n\t\tvar prop;\n\t\tfor (prop in src) {\n\t\t\tdest[prop] = src[prop];\n\t\t}\n\t},\n\t// used to recursively scan hierarchical transform step object for param substitution\n\tresolveTransformObject: function(subObj, params, depth) {\n\t\tvar prop,\n\t\t\tpname;\n\n\t\tif (typeof depth !== 'number') {\n\t\t\tdepth = 0;\n\t\t}\n\n\t\tif (++depth >= 10) return subObj;\n\n\t\tfor (prop in subObj) {\n\t\t\tif (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n\t\t\t\tpname = subObj[prop].substring(8);\n\t\t\t\tif (params.hasOwnProperty(pname)) {\n\t\t\t\t\tsubObj[prop] = params[pname];\n\t\t\t\t}\n\t\t\t} else if (typeof subObj[prop] === \"object\") {\n\t\t\t\tsubObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n\t\t\t}\n\t\t}\n\n\t\treturn subObj;\n\t},\n\t// top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\n\tresolveTransformParams: function(transform, params) {\n\t\tvar idx,\n\t\t\tclonedStep,\n\t\t\tresolvedTransform = [];\n\n\t\tif (typeof params === 'undefined') return transform;\n\n\t\t// iterate all steps in the transform array\n\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\t// clone transform so our scan and replace can operate directly on cloned transform\n\t\t\tclonedStep = JSON.parse(JSON.stringify(transform[idx]));\n\t\t\tresolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));\n\t\t}\n\n\t\treturn resolvedTransform;\n\t}\n};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = clone;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = cloneObjectArray;\nfunction clone(data, method) {\n\tif (data === null || data === undefined) {\n\t\treturn null;\n\t}\n\n\tvar cloneMethod = method || 'parse-stringify',\n\t\tcloned;\n\n\tswitch (cloneMethod) {\n\t\tcase \"parse-stringify\":\n\t\t\tcloned = JSON.parse(JSON.stringify(data));\n\t\t\tbreak;\n\t\tcase \"jquery-extend-deep\":\n\t\t\tcloned = jQuery.extend(true, {}, data);\n\t\t\tbreak;\n\t\tcase \"shallow\":\n\t\t\tcloned = Object.create(data.prototype || null);\n\t\t\tObject.keys(data).map(function(i) {\n\t\t\t\tcloned[i] = data[i];\n\t\t\t});\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn cloned;\n}\n\nfunction cloneObjectArray(objarray, method) {\n\tvar i,\n\t\tresult = [];\n\n\tif (method == \"parse-stringify\") {\n\t\treturn clone(objarray, method);\n\t}\n\n\ti = objarray.length - 1;\n\n\tfor (; i <= 0; i--) {\n\t\tresult.push(clone(objarray[i], method));\n\t}\n\n\treturn result;\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ltHelper;\n/* harmony export (immutable) */ __webpack_exports__[\"b\"] = gtHelper;\n/**\n * Created by toni on 1/27/17.\n */\n\n\n/** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n */\nfunction ltHelper(prop1, prop2, equal) {\n\tvar cv1, cv2;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\tif (equal) {\n\t\t\t\treturn prop1 === prop2;\n\t\t\t} else {\n\t\t\t\tif (prop1) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn prop2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\treturn equal;\n\t\t}\n\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (prop1 === prop2) {\n\t\treturn equal;\n\t}\n\n\tif (prop1 < prop2) {\n\t\treturn true;\n\t}\n\n\tif (prop1 > prop2) {\n\t\treturn false;\n\t}\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\tif (cv1 < cv2) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nfunction gtHelper(prop1, prop2, equal) {\n\tvar cv1, cv2;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\tif (equal) {\n\t\t\t\treturn prop1 === prop2;\n\t\t\t} else {\n\t\t\t\tif (prop1) {\n\t\t\t\t\treturn !prop2;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\treturn equal;\n\t\t}\n\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (prop1 === prop2) {\n\t\treturn equal;\n\t}\n\n\tif (prop1 > prop2) {\n\t\treturn true;\n\t}\n\n\tif (prop1 < prop2) {\n\t\treturn false;\n\t}\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\tif (cv1 > cv2) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__event_emitter__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__fs_adapter__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__local_storage_adapter__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__collection__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils__ = __webpack_require__(2);\n\n\n\n\n\n\n\n\n/*\n'LokiFsAdapter' is not defined                 no-undef\tx\n'LokiLocalStorageAdapter' is not defined       no-undef\tx\n'Collection' is not defined                    no-undef\tx\n'delim' is not defined                         no-undef\tx\n'Utils' is not defined                         no-undef\tx\n\nTBD:\n\t* Default persistence should be not available.\n\t* getIndexedAdapter is also obsolet\n\t* Make some functions private.\n\t* Inflate? -> Utils.copyProperties\n */\n\n/**\n * Loki: The main database class\n * @constructor Loki\n * @implements LokiEventEmitter\n * @param {string} filename - name of the file to be saved to\n * @param {object=} options - (Optional) config options object\n * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n * @param {boolean} options.verbose - enable console output (default is 'false')\n */\nclass Loki extends __WEBPACK_IMPORTED_MODULE_0__event_emitter__[\"a\" /* LokiEventEmitter */] {\n\n\tconstructor(filename, options) {\n\t\tsuper();\n\t\tthis.filename = filename || 'loki.db';\n\t\tthis.collections = [];\n\n\t\t// persist version of code which created the database to the database.\n\t\t// could use for upgrade scenarios\n\t\tthis.databaseVersion = 1.1;\n\t\tthis.engineVersion = 1.1;\n\n\t\t// autosave support (disabled by default)\n\t\t// pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n\t\tthis.autosave = false;\n\t\tthis.autosaveInterval = 5000;\n\t\tthis.autosaveHandle = null;\n\n\t\tthis.options = {\n\t\t\tserializationMethod: options && options.hasOwnProperty('serializationMethod') ? options.serializationMethod : 'normal',\n\t\t\tdestructureDelimiter: options && options.hasOwnProperty('destructureDelimiter') ? options.destructureDelimiter : '$<\\n'\n\t\t};\n\n\t\t// currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n\t\t// will not or cannot be deserialized.  You are required to configure persistence every time\n\t\t// you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\n\t\t// persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n\t\t// this is optional option param, otherwise environment detection will be used\n\t\t// if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n\t\tthis.persistenceMethod = null;\n\n\t\t// retain reference to optional (non-serializable) persistenceAdapter 'instance'\n\t\tthis.persistenceAdapter = null;\n\n\t\t// enable console output if verbose flag is set (disabled by default)\n\t\tthis.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;\n\n\t\tthis.events = {\n\t\t\t'init': [],\n\t\t\t'loaded': [],\n\t\t\t'flushChanges': [],\n\t\t\t'close': [],\n\t\t\t'changes': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\tvar getENV = function() {\n\t\t\tif (typeof window === 'undefined') {\n\t\t\t\treturn 'NODEJS';\n\t\t\t}\n\n\t\t\tif (typeof global !== 'undefined' && global.window) {\n\t\t\t\treturn 'NODEJS'; //node-webkit\n\t\t\t}\n\n\t\t\tif (typeof document !== 'undefined') {\n\t\t\t\tif (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n\t\t\t\t\treturn 'CORDOVA';\n\t\t\t\t}\n\t\t\t\treturn 'BROWSER';\n\t\t\t}\n\t\t\treturn 'CORDOVA';\n\t\t};\n\n\t\t// refactored environment detection due to invalid detection for browser environments.\n\t\t// if they do not specify an options.env we want to detect env rather than default to nodejs.\n\t\t// currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n\t\t//   might want to review whether we can consolidate.\n\t\tif (options && options.hasOwnProperty('env')) {\n\t\t\tthis.ENV = options.env;\n\t\t} else {\n\t\t\tthis.ENV = getENV();\n\t\t}\n\n\t\tthis.on('init', this.clearChanges);\n\t}\n\n\t// experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n\t// Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n\tgetIndexedAdapter() {\n\t\tvar adapter;\n\n\t\tif (true) {\n\t\t\tadapter = __webpack_require__(9);\n\t\t}\n\n\t\treturn adapter;\n\t}\n\n\n\t/**\n\t * configures options related to database persistence.\n\t *\n\t * @param {object} options - configuration options to apply to loki db object\n\t * @param {adapter} options.adapter - an instance of a loki persistence adapter\n\t * @param {boolean} options.autosave - enables autosave\n\t * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n\t * @param {boolean} options.autoload - enables autoload on loki instantiation\n\t * @param {object} options.inflate - options that are passed to loadDatabase if autoload enabled\n\t * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']\n\t * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n\t * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n\t * @memberof Loki\n\t */\n\tinitializePersistence(options) {\n\t\tvar self = this;\n\t\tvar defaultPersistence = {\n\t\t\t\t'NODEJS': 'fs',\n\t\t\t\t'BROWSER': 'localStorage',\n\t\t\t\t'CORDOVA': 'localStorage'\n\t\t\t},\n\t\t\tpersistenceMethods = {\n\t\t\t\t'fs': __WEBPACK_IMPORTED_MODULE_1__fs_adapter__[\"a\" /* LokiFsAdapter */],\n\t\t\t\t'localStorage': __WEBPACK_IMPORTED_MODULE_2__local_storage_adapter__[\"a\" /* LokiLocalStorageAdapter */]\n\t\t\t};\n\n\t\tthis.options = options || {};\n\n\t\tthis.persistenceMethod = null;\n\t\t// retain reference to optional persistence adapter 'instance'\n\t\t// currently keeping outside options because it can't be serialized\n\t\tthis.persistenceAdapter = null;\n\n\t\t// process the options\n\t\tif (this.options.hasOwnProperty('persistenceMethod')) {\n\t\t\t// check if the specified persistence method is known\n\t\t\tif (typeof(persistenceMethods[this.options.persistenceMethod]) === 'function') {\n\t\t\t\tthis.persistenceMethod = this.options.persistenceMethod;\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.options.persistenceMethod]();\n\t\t\t}\n\t\t\t// should be throw an error here, or just fall back to defaults ??\n\t\t}\n\n\t\t// ensure defaults exists for options which were not set\n\t\tif (!this.options.hasOwnProperty('serializationMethod')) {\n\t\t\tthis.options.serializationMethod = 'normal';\n\t\t}\n\n\t\t// ensure passed or default option exists\n\t\tif (!this.options.hasOwnProperty('destructureDelimiter')) {\n\t\t\tthis.options.destructureDelimiter = '$<\\n';\n\t\t}\n\n\t\t// if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n\t\tif (this.persistenceAdapter === null) {\n\t\t\tthis.persistenceMethod = defaultPersistence[this.ENV];\n\t\t\tif (this.persistenceMethod) {\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n\t\t\t}\n\t\t}\n\n\t\t// if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n\t\tif (this.options.hasOwnProperty('adapter')) {\n\t\t\tthis.persistenceMethod = 'adapter';\n\t\t\tthis.persistenceAdapter = this.options.adapter;\n\t\t}\n\n\t\tif (this.options.hasOwnProperty('autosaveInterval')) {\n\t\t\tthis.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n\t\t}\n\n\t\tthis.autosaveDisable();\n\n\t\tvar loaded;\n\n\t\t// if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n\t\tif (this.options.autoload) {\n\t\t\tloaded = this.loadDatabase(this.options.inflate);\n\t\t} else {\n\t\t\tloaded = Promise.resolve();\n\t\t}\n\n\t\treturn loaded.then(function() {\n\t\t\tif (self.options.autosave) {\n\t\t\t\tself.autosaveEnable();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n\t *\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n\t * @memberof Loki\n\t */\n\tcopy(options) {\n\t\tvar databaseCopy = new Loki(this.filename);\n\t\tvar clen, idx;\n\n\t\toptions = options || {};\n\n\t\t// currently inverting and letting loadJSONObject do most of the work\n\t\tdatabaseCopy.loadJSONObject(this, {\n\t\t\tretainDirtyFlags: true\n\t\t});\n\n\t\t// since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic\n\t\tif (options.hasOwnProperty(\"removeNonSerializable\") && options.removeNonSerializable === true) {\n\t\t\tdatabaseCopy.autosaveHandle = null;\n\t\t\tdatabaseCopy.persistenceAdapter = null;\n\n\t\t\tclen = databaseCopy.collections.length;\n\t\t\tfor (idx = 0; idx < clen; idx++) {\n\t\t\t\tdatabaseCopy.collections[idx].constraints = null;\n\t\t\t\tdatabaseCopy.collections[idx].ttl = null;\n\t\t\t}\n\t\t}\n\n\t\treturn databaseCopy;\n\t}\n\n\t/**\n\t * Shorthand method for quickly creating and populating an anonymous collection.\n\t *    This collection is not referenced internally so upon losing scope it will be garbage collected.\n\t *\n\t * @example\n\t * var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });\n\t *\n\t * @param {Array} docs - document array to initialize the anonymous collection with\n\t * @param {object} options - configuration object, see {@link Loki#addCollection} options\n\t * @returns {Collection} New collection which you can query or chain\n\t * @memberof Loki\n\t */\n\tanonym(docs, options) {\n\t\tvar collection = new __WEBPACK_IMPORTED_MODULE_3__collection__[\"a\" /* Collection */]('anonym', options);\n\t\tcollection.insert(docs);\n\n\t\tif (this.verbose)\n\t\t\tcollection.console = console;\n\n\t\treturn collection;\n\t}\n\n\t/**\n\t * Adds a collection to the database.\n\t * @param {string} name - name of collection to add\n\t * @param {object=} options - (optional) options to configure collection with.\n\t * @param {array} options.unique - array of property names to define unique constraints for\n\t * @param {array} options.exact - array of property names to define exact constraints for\n\t * @param {array} options.indices - array property names to define binary indexes for\n\t * @param {boolean} options.asyncListeners - default is false\n\t * @param {boolean} options.disableChangesApi - default is true\n\t * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n\t * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n\t * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n\t * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n\t * @returns {Collection} a reference to the collection which was just added\n\t * @memberof Loki\n\t */\n\taddCollection(name, options) {\n\t\tvar collection = new __WEBPACK_IMPORTED_MODULE_3__collection__[\"a\" /* Collection */](name, options);\n\t\tthis.collections.push(collection);\n\n\t\tif (this.verbose)\n\t\t\tcollection.console = console;\n\n\t\treturn collection;\n\t}\n\n\tloadCollection(collection) {\n\t\tif (!collection.name) {\n\t\t\tthrow new Error('Collection must have a name property to be loaded');\n\t\t}\n\t\tthis.collections.push(collection);\n\t}\n\n\t/**\n\t * Retrieves reference to a collection by name.\n\t * @param {string} collectionName - name of collection to look up\n\t * @returns {Collection} Reference to collection in database by that name, or null if not found\n\t * @memberof Loki\n\t */\n\tgetCollection(collectionName) {\n\t\tvar i,\n\t\t\tlen = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\treturn this.collections[i];\n\t\t\t}\n\t\t}\n\n\t\t// no such collection\n\t\tthis.emit('warning', 'collection ' + collectionName + ' not found');\n\t\treturn null;\n\t}\n\n\tlistCollections() {\n\n\t\tvar i = this.collections.length,\n\t\t\tcolls = [];\n\n\t\twhile (i--) {\n\t\t\tcolls.push({\n\t\t\t\tname: this.collections[i].name,\n\t\t\t\ttype: this.collections[i].objType,\n\t\t\t\tcount: this.collections[i].data.length\n\t\t\t});\n\t\t}\n\t\treturn colls;\n\t}\n\n\t/**\n\t * Removes a collection from the database.\n\t * @param {string} collectionName - name of collection to remove\n\t * @memberof Loki\n\t */\n\tremoveCollection(collectionName) {\n\t\tvar i,\n\t\t\tlen = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\tvar tmpcol = new __WEBPACK_IMPORTED_MODULE_3__collection__[\"a\" /* Collection */](collectionName, {});\n\t\t\t\tvar curcol = this.collections[i];\n\t\t\t\tfor (var prop in curcol) {\n\t\t\t\t\tif (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n\t\t\t\t\t\tcurcol[prop] = tmpcol[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.collections.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * serializeReplacer - used to prevent certain properties from being serialized\n\t *\n\t */\n\tserializeReplacer(key, value) {\n\t\tswitch (key) {\n\t\t\tcase 'autosaveHandle':\n\t\t\tcase 'persistenceAdapter':\n\t\t\tcase 'constraints':\n\t\t\tcase 'ttl':\n\t\t\t\treturn null;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n\t *\n\t * @returns {string} Stringified representation of the loki database.\n\t * @memberof Loki\n\t */\n\tserialize(options) {\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"serializationMethod\")) {\n\t\t\toptions.serializationMethod = this.options.serializationMethod;\n\t\t}\n\n\t\tswitch (options.serializationMethod) {\n\t\t\tcase \"normal\":\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t\tcase \"pretty\":\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer, 2);\n\t\t\tcase \"destructured\":\n\t\t\t\treturn this.serializeDestructured(); // use default options\n\t\t\tdefault:\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t}\n\t}\n\n\t// alias of serialize\n\ttoJson() {\n\t\treturn this.serialize;\n\t}\n\n\t/**\n\t * Destructured JSON serialization routine to allow alternate serialization methods.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {object=} options - output format options for use externally to loki\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {string|array} A custom, restructured aggregation of independent serializations.\n\t * @memberof Loki\n\t */\n\tserializeDestructured(options) {\n\t\tvar idx, sidx, result, resultlen;\n\t\tvar reconstruct = [];\n\t\tvar dbcopy;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n\t\tif (options.partitioned === true && options.hasOwnProperty(\"partition\") && options.partition >= 0) {\n\t\t\treturn this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: options.partition\n\t\t\t});\n\t\t}\n\n\t\t// not just an individual collection, so we will need to serialize db container via shallow copy\n\t\tdbcopy = new Loki(this.filename);\n\t\tdbcopy.loadJSONObject(this);\n\n\t\tfor (idx = 0; idx < dbcopy.collections.length; idx++) {\n\t\t\tdbcopy.collections[idx].data = [];\n\t\t}\n\n\t\t// if we -only- wanted the db container portion, return it now\n\t\tif (options.partitioned === true && options.partition === -1) {\n\t\t\t// since we are deconstructing, override serializationMethod to normal for here\n\t\t\treturn dbcopy.serialize({\n\t\t\t\tserializationMethod: \"normal\"\n\t\t\t});\n\t\t}\n\n\t\t// at this point we must be deconstructing the entire database\n\t\t// start by pushing db serialization into first array element\n\t\treconstruct.push(dbcopy.serialize({\n\t\t\tserializationMethod: \"normal\"\n\t\t}));\n\n\t\tdbcopy = null;\n\n\t\t// push collection data into subsequent elements\n\t\tfor (idx = 0; idx < this.collections.length; idx++) {\n\t\t\tresult = this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: idx\n\t\t\t});\n\n\t\t\t// NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n\t\t\tif (options.partitioned === false && options.delimited === false) {\n\t\t\t\tif (!Array.isArray(result)) {\n\t\t\t\t\tthrow new Error(\"a nondelimited, non partitioned collection serialization did not return an expected array\");\n\t\t\t\t}\n\n\t\t\t\t// Array.concat would probably duplicate memory overhead for copying strings.\n\t\t\t\t// Instead copy each individually, and clear old value after each copy.\n\t\t\t\t// Hopefully this will allow g.c. to reduce memory pressure, if needed.\n\t\t\t\tresultlen = result.length;\n\n\t\t\t\tfor (sidx = 0; sidx < resultlen; sidx++) {\n\t\t\t\t\treconstruct.push(result[sidx]);\n\t\t\t\t\tresult[sidx] = null;\n\t\t\t\t}\n\n\t\t\t\treconstruct.push(\"\");\n\t\t\t} else {\n\t\t\t\treconstruct.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n\t\tif (options.partitioned) {\n\t\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t\t// useful for simple future adaptations of existing persistence adapters to save collections separately\n\t\t\tif (options.delimited) {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t\t// This format might be the most versatile for 'rolling your own' partitioned sync or save.\n\t\t\t// Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n\t\t\telse {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t} else {\n\t\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t\t// This is the method Loki will use internally if 'destructured'.\n\t\t\t// Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n\t\t\tif (options.delimited) {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct.join(options.delimiter);\n\t\t\t}\n\t\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\t\t\t// This format might be best candidate for custom synchronous syncs or saves\n\t\t\telse {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t}\n\n\t\treconstruct.push(\"\");\n\n\t\treturn reconstruct.join(delim);\n\t}\n\n\t/**\n\t * Utility method to serialize a collection in a 'destructured' format\n\t *\n\t * @param {object} options - used to determine output of method\n\t * @param {int=} options.delimited - whether to return single delimited string or an array\n\t * @param {string=} options.delimiter - (optional) if delimited, this is delimiter to use\n\t * @param {int} options.collectionIndex -  specify which collection to serialize data for\n\t *\n\t * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n\t * @memberof Loki\n\t */\n\tserializeCollection(options) {\n\t\tvar doccount,\n\t\t\tdocidx,\n\t\t\tresultlines = [];\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"collectionIndex\")) {\n\t\t\tthrow new Error(\"serializeCollection called without 'collectionIndex' option\");\n\t\t}\n\n\t\tdoccount = this.collections[options.collectionIndex].data.length;\n\n\t\tresultlines = [];\n\n\t\tfor (docidx = 0; docidx < doccount; docidx++) {\n\t\t\tresultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));\n\t\t}\n\n\t\t// D and DA\n\t\tif (options.delimited) {\n\t\t\t// indicate no more documents in collection (via empty delimited string)\n\t\t\tresultlines.push(\"\");\n\n\t\t\treturn resultlines.join(options.delimiter);\n\t\t} else {\n\t\t\t// NDAA and NDA\n\t\t\treturn resultlines;\n\t\t}\n\t}\n\n\t/**\n\t * Destructured JSON deserialization routine to minimize memory overhead.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {string|array} destructuredSource - destructured json or array to deserialize from\n\t * @param {object=} options - source format options\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to deserialize only a single partition\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n\t * @memberof Loki\n\t */\n\tdeserializeDestructured(destructuredSource, options) {\n\t\tvar workarray = [];\n\t\tvar len, cdb;\n\t\tvar idx, collIndex = 0,\n\t\t\tcollCount, lineIndex = 1,\n\t\t\tdone = false;\n\t\tvar currLine, currObject;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// Partitioned\n\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t// -or- single partition\n\t\tif (options.partitioned) {\n\t\t\t// handle single partition\n\t\t\tif (options.hasOwnProperty('partition')) {\n\t\t\t\t// db only\n\t\t\t\tif (options.partition === -1) {\n\t\t\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\n\t\t\t\t\treturn cdb;\n\t\t\t\t}\n\n\t\t\t\t// single collection, return doc array\n\t\t\t\treturn this.deserializeCollection(destructuredSource[options.partition + 1], options);\n\t\t\t}\n\n\t\t\t// Otherwise we are restoring an entire partitioned db\n\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\t\t\tcollCount = cdb.collections.length;\n\t\t\tfor (collIndex = 0; collIndex < collCount; collIndex++) {\n\t\t\t\t// attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n\t\t\t\tcdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n\t\t\t}\n\n\t\t\treturn cdb;\n\t\t}\n\n\t\t// Non-Partitioned\n\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\n\t\t// D\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tdestructuredSource = null; // lower memory pressure\n\t\t\tlen = workarray.length;\n\n\t\t\tif (len === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// NDA\n\t\telse {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\t// first line is database and collection shells\n\t\tcdb = JSON.parse(workarray[0]);\n\t\tcollCount = cdb.collections.length;\n\t\tworkarray[0] = null;\n\n\t\twhile (!done) {\n\t\t\tcurrLine = workarray[lineIndex];\n\n\t\t\t// empty string indicates either end of collection or end of file\n\t\t\tif (workarray[lineIndex] === \"\") {\n\t\t\t\t// if no more collections to load into, we are done\n\t\t\t\tif (++collIndex > collCount) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrObject = JSON.parse(workarray[lineIndex]);\n\t\t\t\tcdb.collections[collIndex].data.push(currObject);\n\t\t\t}\n\n\t\t\t// lower memory pressure and advance iterator\n\t\t\tworkarray[lineIndex++] = null;\n\t\t}\n\n\t\treturn cdb;\n\t}\n\n\t/**\n\t * Deserializes a destructured collection.\n\t *\n\t * @param {string|array} destructuredSource - destructured representation of collection to inflate\n\t * @param {object} options - used to describe format of destructuredSource input\n\t * @param {int} options.delimited - whether source is delimited string or an array\n\t * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n\t *\n\t * @returns {array} an array of documents to attach to collection.data.\n\t * @memberof Loki\n\t */\n\tdeserializeCollection(destructuredSource, options) {\n\t\tvar workarray = [];\n\t\tvar idx, len;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tworkarray.pop();\n\t\t} else {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\tlen = workarray.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tworkarray[idx] = JSON.parse(workarray[idx]);\n\t\t}\n\n\t\treturn workarray;\n\t}\n\n\t/**\n\t * Inflates a loki database from a serialized JSON string\n\t *\n\t * @param {string} serializedDb - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t * @memberof Loki\n\t */\n\tloadJSON(serializedDb, options) {\n\t\tvar dbObject;\n\t\tif (serializedDb.length === 0) {\n\t\t\tdbObject = {};\n\t\t} else {\n\t\t\t// using option defined in instantiated db not what was in serialized db\n\t\t\tswitch (this.options.serializationMethod) {\n\t\t\t\tcase \"normal\":\n\t\t\t\tcase \"pretty\":\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"destructured\":\n\t\t\t\t\tdbObject = this.deserializeDestructured(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.loadJSONObject(dbObject, options);\n\t}\n\n\t/**\n\t * Inflates a loki database from a JS object\n\t *\n\t * @param {object} dbObject - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool?} options.retainDirtyFlags - whether collection dirty flags will be preserved\n\t * @memberof Loki\n\t */\n\tloadJSONObject(dbObject, options) {\n\t\tvar i = 0,\n\t\t\tlen = dbObject.collections ? dbObject.collections.length : 0,\n\t\t\tcoll,\n\t\t\tcopyColl,\n\t\t\tclen,\n\t\t\tj,\n\t\t\tloader,\n\t\t\tcollObj;\n\n\t\tthis.name = dbObject.name;\n\n\t\t// restore database version\n\t\tthis.databaseVersion = 1.0;\n\t\tif (dbObject.hasOwnProperty('databaseVersion')) {\n\t\t\tthis.databaseVersion = dbObject.databaseVersion;\n\t\t}\n\n\t\tthis.collections = [];\n\n\t\tfunction makeLoader(coll) {\n\t\t\tvar collOptions = options[coll.name];\n\t\t\tvar inflater;\n\n\t\t\tif (collOptions.proto) {\n\t\t\t\tinflater = collOptions.inflate || __WEBPACK_IMPORTED_MODULE_4__utils__[\"a\" /* Utils */].copyProperties;\n\n\t\t\t\treturn function(data) {\n\t\t\t\t\tvar collObj = new(collOptions.proto)();\n\t\t\t\t\tinflater(data, collObj);\n\t\t\t\t\treturn collObj;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn collOptions.inflate;\n\t\t}\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tcoll = dbObject.collections[i];\n\t\t\tcopyColl = this.addCollection(coll.name);\n\n\t\t\tcopyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? (coll.adaptiveBinaryIndices === true) : false;\n\t\t\tcopyColl.transactional = coll.transactional;\n\t\t\tcopyColl.asyncListeners = coll.asyncListeners;\n\t\t\tcopyColl.disableChangesApi = coll.disableChangesApi;\n\t\t\tcopyColl.cloneObjects = coll.cloneObjects;\n\t\t\tcopyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n\t\t\tcopyColl.autoupdate = coll.autoupdate;\n\t\t\tcopyColl.changes = coll.changes;\n\n\t\t\tif (options && options.retainDirtyFlags === true) {\n\t\t\t\tcopyColl.dirty = coll.dirty;\n\t\t\t} else {\n\t\t\t\tcopyColl.dirty = false;\n\t\t\t}\n\n\t\t\t// load each element individually\n\t\t\tclen = coll.data.length;\n\t\t\tj = 0;\n\t\t\tif (options && options.hasOwnProperty(coll.name)) {\n\t\t\t\tloader = makeLoader(coll);\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcollObj = loader(coll.data[j]);\n\t\t\t\t\tcopyColl.data[j] = collObj;\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(collObj);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcopyColl.data[j] = coll.data[j];\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(copyColl.data[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcopyColl.maxId = (coll.data.length === 0) ? 0 : coll.maxId;\n\t\t\tcopyColl.idIndex = coll.idIndex;\n\t\t\tif (typeof(coll.binaryIndices) !== 'undefined') {\n\t\t\t\tcopyColl.binaryIndices = coll.binaryIndices;\n\t\t\t}\n\t\t\tif (typeof coll.transforms !== 'undefined') {\n\t\t\t\tcopyColl.transforms = coll.transforms;\n\t\t\t}\n\n\t\t\tcopyColl.ensureId();\n\n\t\t\t// regenerate unique indexes\n\t\t\tcopyColl.uniqueNames = [];\n\t\t\tif (coll.hasOwnProperty(\"uniqueNames\")) {\n\t\t\t\tcopyColl.uniqueNames = coll.uniqueNames;\n\t\t\t\tfor (j = 0; j < copyColl.uniqueNames.length; j++) {\n\t\t\t\t\tcopyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case they are loading a database created before we added dynamic views, handle undefined\n\t\t\tif (typeof(coll.DynamicViews) === 'undefined') continue;\n\n\t\t\t// reinflate DynamicViews and attached Resultsets\n\t\t\tfor (var idx = 0; idx < coll.DynamicViews.length; idx++) {\n\t\t\t\tvar colldv = coll.DynamicViews[idx];\n\n\t\t\t\tvar dv = copyColl.addDynamicView(colldv.name, colldv.options);\n\t\t\t\tdv.resultdata = colldv.resultdata;\n\t\t\t\tdv.resultsdirty = colldv.resultsdirty;\n\t\t\t\tdv.filterPipeline = colldv.filterPipeline;\n\n\t\t\t\tdv.sortCriteria = colldv.sortCriteria;\n\t\t\t\tdv.sortFunction = null;\n\n\t\t\t\tdv.sortDirty = colldv.sortDirty;\n\t\t\t\tdv.resultset.filteredrows = colldv.resultset.filteredrows;\n\t\t\t\tdv.resultset.searchIsChained = colldv.resultset.searchIsChained;\n\t\t\t\tdv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\n\t\t\t\tdv.rematerialize({\n\t\t\t\t\tremoveWhereFilters: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n\t * Does not actually destroy the db.\n\t *\n\t * @returns {Promise} a Promise that resolves after closing the database succeeded\n\t * @memberof Loki\n\t */\n\tclose() {\n\t\tvar self = this;\n\t\tvar saved;\n\n\t\t// for autosave scenarios, we will let close perform final save (if dirty)\n\t\t// For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n\t\tif (this.autosave) {\n\t\t\tthis.autosaveDisable();\n\t\t\tif (this.autosaveDirty()) {\n\t\t\t\tsaved = this.saveDatabase();\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(function() {\n\t\t\tself.emit('close');\n\t\t});\n\t}\n\n\t/**-------------------------+\n\t | Changes API               |\n\t +--------------------------*/\n\n\t/**\n\t * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n\t * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n\t */\n\n\t/**\n\t * (Changes API) : takes all the changes stored in each\n\t * collection and creates a single array for the entire database. If an array of names\n\t * of collections is passed then only the included collections will be tracked.\n\t *\n\t * @param {array=} optional array of collection names. No arg means all collections are processed.\n\t * @returns {array} array of changes\n\t * @see private method createChange() in Collection\n\t * @memberof Loki\n\t */\n\tgenerateChangesNotification(arrayOfCollectionNames) {\n\t\tfunction getCollName(coll) {\n\t\t\treturn coll.name;\n\t\t}\n\t\tvar changes = [],\n\t\t\tselectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\n\t\tthis.collections.forEach(function(coll) {\n\t\t\tif (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n\t\t\t\tchanges = changes.concat(coll.getChanges());\n\t\t\t}\n\t\t});\n\t\treturn changes;\n\t}\n\n\t/**\n\t * (Changes API) - stringify changes for network transmission\n\t * @returns {string} string representation of the changes\n\t * @memberof Loki\n\t */\n\tserializeChanges(collectionNamesArray) {\n\t\treturn JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n\t}\n\n\t/**\n\t * (Changes API) : clears all the changes in all collections.\n\t * @memberof Loki\n\t */\n\tclearChanges() {\n\t\tthis.collections.forEach(function(coll) {\n\t\t\tif (coll.flushChanges) {\n\t\t\t\tcoll.flushChanges();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Handles loading from file system, local storage, or adapter (indexeddb).\n\t *\n\t * @param {object} options - an object containing inflation options for each collection\n\t * @returns {Promise} a Promise that resolves after the database is loaded\n\t * @memberof Loki\n\t */\n\tloadDatabase(options) {\n\t\tvar self = this;\n\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.loadDatabase(this.filename))\n\t\t\t.then(function loadDatabaseCallback(dbString) {\n\t\t\t\tif (typeof(dbString) === 'string') {\n\t\t\t\t\tself.loadJSON(dbString, options || {});\n\t\t\t\t\tself.emit('load', self);\n\t\t\t\t} else {\n\t\t\t\t\t// if adapter has returned an js object (other than null or error) attempt to load from JSON object\n\t\t\t\t\tif (typeof(dbString) === \"object\" && dbString !== null && !(dbString instanceof Error)) {\n\t\t\t\t\t\tself.loadJSONObject(dbString, options || {});\n\t\t\t\t\t\tself.emit('load', self);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dbString instanceof Error)\n\t\t\t\t\t\t\tthrow dbString;\n\n\t\t\t\t\t\tthrow new TypeError('The persistence adapter did not load a serialized DB string or object.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles saving to file system, local storage, or adapter (indexeddb)\n\t *\n\t * @memberof Loki\n\t * @returns {Promise} a Promise that resolves after the database is persisted\n\t */\n\tsaveDatabase() {\n\t\tvar self = this;\n\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\tvar saved;\n\n\t\t// check if the adapter is requesting (and supports) a 'reference' mode export\n\t\tif (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n\t\t\t// filename may seem redundant but loadDatabase will need to expect this same filename\n\t\t\tsaved = this.persistenceAdapter.exportDatabase(this.filename, this.copy({\n\t\t\t\tremoveNonSerializable: true\n\t\t\t}));\n\t\t}\n\t\t// otherwise just pass the serialized database to adapter\n\t\telse {\n\t\t\tsaved = this.persistenceAdapter.saveDatabase(this.filename, self.serialize());\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(function() {\n\t\t\tself.autosaveClearFlags();\n\t\t\tself.emit(\"save\");\n\t\t});\n\t}\n\n\t// alias\n\tsave() {\n\t\treturn this.saveDatabase();\n\t}\n\n\t/**\n\t * Handles deleting a database from file system, local storage, or adapter (indexeddb)\n\t *\n\t * @returns {Promise} a Promise that resolves after the database is deleted\n\t * @memberof Loki\n\t */\n\tdeleteDatabase() {\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.deleteDatabase(this.filename));\n\t}\n\n\t/**\n\t * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n\t *\n\t * @returns {boolean} - true if database has changed since last autosave, false if not.\n\t */\n\tautosaveDirty() {\n\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\tif (this.collections[idx].dirty) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * autosaveClearFlags - resets dirty flags on all collections.\n\t *    Called from saveDatabase() after db is saved.\n\t *\n\t */\n\tautosaveClearFlags() {\n\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\tthis.collections[idx].dirty = false;\n\t\t}\n\t}\n\n\t/**\n\t * autosaveEnable - begin a javascript interval to periodically save the database.\n\t *\n\t */\n\tautosaveEnable() {\n\t\tif (this.autosaveHandle) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this;\n\t\tvar running = true;\n\n\t\tthis.autosave = true;\n\t\tthis.autosaveHandle = function() {\n\t\t\trunning = false;\n\t\t\tself.autosaveHandle = undefined;\n\t\t};\n\n\t\t(function saveDatabase() {\n\t\t\tsetTimeout(function() {\n\t\t\t\tif (running) {\n\t\t\t\t\tself.saveDatabase().then(saveDatabase, saveDatabase);\n\t\t\t\t}\n\t\t\t}, self.autosaveInterval);\n\t\t})();\n\t}\n\n\t/**\n\t * autosaveDisable - stop the autosave interval timer.\n\t *\n\t */\n\tautosaveDisable() {\n\t\tthis.autosave = false;\n\n\t\tif (this.autosaveHandle) {\n\t\t\tthis.autosaveHandle();\n\t\t}\n\t}\n}\n/* harmony export (immutable) */ __webpack_exports__[\"Loki\"] = Loki;\n\n\nLoki.Plugins = {};\n\n/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(10)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__clone__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__collection__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__helper__ = __webpack_require__(4);\n/* unused harmony export LokiOps */\n\n\n\n\n\n/*\n 'Utils' is not defined                 no-undef\t(resolveTransformParams)\n 'sortHelper' is not defined            no-undef\n 'compoundeval' is not defined          no-undef\n 'indexedOpsList' is not defined        no-undef\n 'LokiOps' is not defined               no-undef\n 'dotSubScan' is not defined            no-undef\n 'clone' is not defined                 no-undef\n\n\n */\n\nfunction containsCheckFn(a) {\n\tif (typeof a === 'string' || Array.isArray(a)) {\n\t\treturn function(b) {\n\t\t\treturn a.indexOf(b) !== -1;\n\t\t};\n\t} else if (typeof a === 'object' && a !== null) {\n\t\treturn function(b) {\n\t\t\treturn hasOwnProperty.call(a, b);\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction doQueryOp(val, op) {\n\tfor (var p in op) {\n\t\tif (hasOwnProperty.call(op, p)) {\n\t\t\treturn LokiOps[p](val, op[p]);\n\t\t}\n\t}\n\treturn false;\n}\n\n\nvar LokiOps = {\n\t// comparison operators\n\t// a is the value in the collection\n\t// b is the query value\n\t$eq: function(a, b) {\n\t\treturn a === b;\n\t},\n\n\t// abstract/loose equality\n\t$aeq: function(a, b) {\n\t\treturn a == b;\n\t},\n\n\t$ne: function(a, b) {\n\t\t// ecma 5 safe test for NaN\n\t\tif (b !== b) {\n\t\t\t// ecma 5 test value is not NaN\n\t\t\treturn (a === a);\n\t\t}\n\n\t\treturn a !== b;\n\t},\n\n\t$dteq: function(a, b) {\n\t\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"a\" /* ltHelper */])(a, b, false)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"b\" /* gtHelper */])(a, b, false);\n\t},\n\n\t$gt: function(a, b) {\n\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"b\" /* gtHelper */])(a, b, false);\n\t},\n\n\t$gte: function(a, b) {\n\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"b\" /* gtHelper */])(a, b, true);\n\t},\n\n\t$lt: function(a, b) {\n\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"a\" /* ltHelper */])(a, b, false);\n\t},\n\n\t$lte: function(a, b) {\n\t\treturn __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"a\" /* ltHelper */])(a, b, true);\n\t},\n\n\t// ex : coll.find({'orderCount': {$between: [10, 50]}});\n\t$between: function(a, vals) {\n\t\tif (a === undefined || a === null) return false;\n\t\treturn (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"b\" /* gtHelper */])(a, vals[0], true) && __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"a\" /* ltHelper */])(a, vals[1], true));\n\t},\n\n\t$in: function(a, b) {\n\t\treturn b.indexOf(a) !== -1;\n\t},\n\n\t$nin: function(a, b) {\n\t\treturn b.indexOf(a) === -1;\n\t},\n\n\t$keyin: function(a, b) {\n\t\treturn a in b;\n\t},\n\n\t$nkeyin: function(a, b) {\n\t\treturn !(a in b);\n\t},\n\n\t$definedin: function(a, b) {\n\t\treturn b[a] !== undefined;\n\t},\n\n\t$undefinedin: function(a, b) {\n\t\treturn b[a] === undefined;\n\t},\n\n\t$regex: function(a, b) {\n\t\treturn b.test(a);\n\t},\n\n\t$containsString: function(a, b) {\n\t\treturn (typeof a === 'string') && (a.indexOf(b) !== -1);\n\t},\n\n\t$containsNone: function(a, b) {\n\t\treturn !LokiOps.$containsAny(a, b);\n\t},\n\n\t$containsAny: function(a, b) {\n\t\tvar checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$contains: function(a, b) {\n\t\tvar checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$type: function(a, b) {\n\t\tvar type = typeof a;\n\t\tif (type === 'object') {\n\t\t\tif (Array.isArray(a)) {\n\t\t\t\ttype = 'array';\n\t\t\t} else if (a instanceof Date) {\n\t\t\t\ttype = 'date';\n\t\t\t}\n\t\t}\n\t\treturn (typeof b !== 'object') ? (type === b) : doQueryOp(type, b);\n\t},\n\n\t$size: function(a, b) {\n\t\tif (Array.isArray(a)) {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$len: function(a, b) {\n\t\tif (typeof a === 'string') {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$where: function(a, b) {\n\t\treturn b(a) === true;\n\t},\n\n\t// field-level logical operators\n\t// a is the value in the collection\n\t// b is the nested query operation (for '$not')\n\t//   or an array of nested query operations (for '$and' and '$or')\n\t$not: function(a, b) {\n\t\treturn !doQueryOp(a, b);\n\t},\n\n\t$and: function(a, b) {\n\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (!doQueryOp(a, b[idx])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t$or: function(a, b) {\n\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (doQueryOp(a, b[idx])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\n// making indexing opt-in... our range function knows how to deal with these ops :\nvar indexedOpsList = ['$eq', '$aeq', '$dteq', '$gt', '$gte', '$lt', '$lte', '$in', '$between'];\n\n\nfunction sortHelper(prop1, prop2, desc) {\n\tif (prop1 === prop2) {\n\t\treturn 0;\n\t}\n\n\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"a\" /* ltHelper */])(prop1, prop2, false)) {\n\t\treturn (desc) ? (1) : (-1);\n\t}\n\n\tif (__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_3__helper__[\"b\" /* gtHelper */])(prop1, prop2, false)) {\n\t\treturn (desc) ? (-1) : (1);\n\t}\n\n\t// not lt, not gt so implied equality-- date compatible\n\treturn 0;\n}\n\n/**\n * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n *\n * @param {array} properties - array of property names, in order, by which to evaluate sort order\n * @param {object} obj1 - first object to compare\n * @param {object} obj2 - second object to compare\n * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n */\nfunction compoundeval(properties, obj1, obj2) {\n\tvar res = 0;\n\tvar prop, field;\n\tfor (var i = 0, len = properties.length; i < len; i++) {\n\t\tprop = properties[i];\n\t\tfield = prop[0];\n\t\tres = sortHelper(obj1[field], obj2[field], prop[1]);\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n/**\n * dotSubScan - helper function used for dot notation queries.\n *\n * @param {object} root - object to traverse\n * @param {array} paths - array of properties to drill into\n * @param {function} fun - evaluation function to test with\n * @param {any} value - comparative value to also pass to (compare) fun\n * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n */\nfunction dotSubScan(root, paths, fun, value, poffset) {\n\tvar pathOffset = poffset || 0;\n\tvar path = paths[pathOffset];\n\tif (root === undefined || root === null || !hasOwnProperty.call(root, path)) {\n\t\treturn false;\n\t}\n\n\tvar valueFound = false;\n\tvar element = root[path];\n\tif (pathOffset + 1 >= paths.length) {\n\t\t// if we have already expanded out the dot notation,\n\t\t// then just evaluate the test function and value on the element\n\t\tvalueFound = fun(element, value);\n\t} else if (Array.isArray(element)) {\n\t\tfor (var index = 0, len = element.length; index < len; index += 1) {\n\t\t\tvalueFound = dotSubScan(element[index], paths, fun, value, pathOffset + 1);\n\t\t\tif (valueFound === true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvalueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);\n\t}\n\n\treturn valueFound;\n}\n\n/**\n * Resultset class allowing chainable queries.  Intended to be instanced internally.\n *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n *\n * @example\n *    mycollection.chain()\n *      .find({ 'doors' : 4 })\n *      .where(function(obj) { return obj.name === 'Toyota' })\n *      .data();\n *\n * @constructor Resultset\n * @param {Collection} collection - The collection which this Resultset will query against.\n * @param {Object=} options - Object containing one or more options.\n * @param {string} options.queryObj - Optional mongo-style query object to initialize resultset with.\n * @param {function} options.queryFunc - Optional javascript filter function to initialize resultset with.\n * @param {bool} options.firstOnly - Optional boolean used by collection.findOne().\n */\nclass Resultset {\n\n\tconstructor(collection, options) {\n\t\toptions = options || {};\n\n\t\toptions.queryObj = options.queryObj || null;\n\t\toptions.queryFunc = options.queryFunc || null;\n\t\toptions.firstOnly = options.firstOnly || false;\n\n\t\t// retain reference to collection we are querying against\n\t\tthis.collection = collection;\n\n\t\t// if chain() instantiates with null queryObj and queryFunc, so we will keep flag for later\n\t\tthis.searchIsChained = (!options.queryObj && !options.queryFunc);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\t// if user supplied initial queryObj or queryFunc, apply it\n\t\tif (typeof(options.queryObj) !== \"undefined\" && options.queryObj !== null) {\n\t\t\treturn this.find(options.queryObj, options.firstOnly);\n\t\t}\n\t\tif (typeof(options.queryFunc) !== \"undefined\" && options.queryFunc !== null) {\n\t\t\treturn this.where(options.queryFunc);\n\t\t}\n\n\t\t// otherwise return unfiltered Resultset for future filtering\n\t\treturn this;\n\t}\n\n\t/**\n\t * reset() - Reset the resultset to its initial state.\n\t *\n\t * @returns {Resultset} Reference to this resultset, for future chain operations.\n\t */\n\treset() {\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tthis.filteredrows = [];\n\t\t}\n\t\tthis.filterInitialized = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tvar copy = this.copy();\n\t\tcopy.collection = null;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Allows you to limit the number of documents passed to next chain operation.\n\t *    A resultset copy() is made to avoid altering original resultset.\n\t *\n\t * @param {int} qty - The number of documents to return.\n\t * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\tlimit(qty) {\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar rscopy = new Resultset(this.collection);\n\t\trscopy.filteredrows = this.filteredrows.slice(0, qty);\n\t\trscopy.filterInitialized = true;\n\t\treturn rscopy;\n\t}\n\n\t/**\n\t * Used for skipping 'pos' number of documents in the resultset.\n\t *\n\t * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n\t * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\toffset(pos) {\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar rscopy = new Resultset(this.collection);\n\t\trscopy.filteredrows = this.filteredrows.slice(pos);\n\t\trscopy.filterInitialized = true;\n\t\treturn rscopy;\n\t}\n\n\t/**\n\t * copy() - To support reuse of resultset in branched query situations.\n\t *\n\t * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n\t * @memberof Resultset\n\t */\n\tcopy() {\n\t\tvar result = new Resultset(this.collection);\n\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tresult.filteredrows = this.filteredrows.slice();\n\t\t}\n\t\tresult.filterInitialized = this.filterInitialized;\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Alias of copy()\n\t * @memberof Resultset\n\t */\n\tbranch() {\n\t\treturn this.copy();\n\t}\n\n\t/**\n\t * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n\t *\n\t * @param transform {(string|array)} - name of collection transform or raw transform array\n\t * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n\t * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n\t * @memberof Resultset\n\t */\n\ttransform(transform, parameters) {\n\t\tvar idx,\n\t\t\tstep,\n\t\t\trs = this;\n\n\t\t// if transform is name, then do lookup first\n\t\tif (typeof transform === 'string') {\n\t\t\tif (this.collection.transforms.hasOwnProperty(transform)) {\n\t\t\t\ttransform = this.collection.transforms[transform];\n\t\t\t}\n\t\t}\n\n\t\t// either they passed in raw transform array or we looked it up, so process\n\t\tif (typeof transform !== 'object' || !Array.isArray(transform)) {\n\t\t\tthrow new Error(\"Invalid transform\");\n\t\t}\n\n\t\tif (typeof parameters !== 'undefined') {\n\t\t\ttransform = __WEBPACK_IMPORTED_MODULE_2__utils__[\"a\" /* Utils */].resolveTransformParams(transform, parameters);\n\t\t}\n\n\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\tstep = transform[idx];\n\n\t\t\tswitch (step.type) {\n\t\t\t\tcase \"find\":\n\t\t\t\t\trs.find(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"where\":\n\t\t\t\t\trs.where(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"simplesort\":\n\t\t\t\t\trs.simplesort(step.property, step.desc);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"compoundsort\":\n\t\t\t\t\trs.compoundsort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sort\":\n\t\t\t\t\trs.sort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"limit\":\n\t\t\t\t\trs = rs.limit(step.value);\n\t\t\t\t\tbreak; // limit makes copy so update reference\n\t\t\t\tcase \"offset\":\n\t\t\t\t\trs = rs.offset(step.value);\n\t\t\t\t\tbreak; // offset makes copy so update reference\n\t\t\t\tcase \"map\":\n\t\t\t\t\trs = rs.map(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"eqJoin\":\n\t\t\t\t\trs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases break chain by returning array data so make any of these last in transform steps\n\t\t\t\tcase \"mapReduce\":\n\t\t\t\t\trs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases update documents in current filtered resultset (use carefully)\n\t\t\t\tcase \"update\":\n\t\t\t\t\trs.update(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\trs.remove();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn rs;\n\t}\n\n\t/**\n\t * Instances a new anonymous collection with the documents contained in the current resultset.\n\t *\n\t * @param {object} collectionOptions - Options to pass to new anonymous collection construction.\n\t * @returns {Collection} A reference to an anonymous collection initialized with resultset data().\n\t * @memberof Resultset\n\t */\n\tinstance(collectionOptions) {\n\t\tvar docs = this.data();\n\t\tvar idx,\n\t\t\tdoc;\n\n\t\tcollectionOptions = collectionOptions || {};\n\n\t\tvar instanceCollection = new __WEBPACK_IMPORTED_MODULE_1__collection__[\"a\" /* Collection */](collectionOptions);\n\n\t\tfor (idx = 0; idx < docs.length; idx++) {\n\t\t\tif (this.collection.cloneObjects) {\n\t\t\t\tdoc = docs[idx];\n\t\t\t} else {\n\t\t\t\tdoc = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__clone__[\"a\" /* clone */])(docs[idx], this.collection.cloneMethod);\n\t\t\t}\n\n\t\t\tdelete doc.$loki;\n\t\t\tdelete doc.meta;\n\n\t\t\tinstanceCollection.insert(doc);\n\t\t}\n\n\t\treturn instanceCollection;\n\t}\n\n\t/**\n\t * User supplied compare function is provided two documents to compare. (chainable)\n\t * @example\n\t *    rslt.sort(function(obj1, obj2) {\n\t *      if (obj1.name === obj2.name) return 0;\n\t *      if (obj1.name > obj2.name) return 1;\n\t *      if (obj1.name < obj2.name) return -1;\n\t *    });\n\t *\n\t * @param {function} comparefun - A javascript compare function used for sorting.\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsort(comparefun) {\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(userComparer, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn userComparer(data[a], data[b]);\n\t\t\t\t};\n\t\t\t})(comparefun, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n\t *    Sorting based on the same lt/gt helper functions used for binary indices.\n\t *\n\t * @param {string} propname - name of property to sort by.\n\t * @param {bool=} isdesc - (Optional) If true, the property will be sorted in descending order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsimplesort(propname, isdesc) {\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t// if we have a binary index and no other filters applied, we can use that instead of sorting (again)\n\t\t\tif (this.collection.binaryIndices.hasOwnProperty(propname)) {\n\t\t\t\t// make sure index is up-to-date\n\t\t\t\tthis.collection.ensureIndex(propname);\n\t\t\t\t// copy index values into filteredrows\n\t\t\t\tthis.filteredrows = this.collection.binaryIndices[propname].values.slice(0);\n\t\t\t\t// we are done, return this (resultset) for further chain ops\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t// otherwise initialize array for sort below\n\t\t\telse {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(isdesc) === 'undefined') {\n\t\t\tisdesc = false;\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(prop, desc, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn sortHelper(data[a][prop], data[b][prop], desc);\n\t\t\t\t};\n\t\t\t})(propname, isdesc, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * rs.compoundsort(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * rs.compoundsort(['age', ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tcompoundsort(properties) {\n\t\tif (properties.length === 0) {\n\t\t\tthrow new Error(\"Invalid call to compoundsort, need at least one property\");\n\t\t}\n\n\t\tvar prop;\n\t\tif (properties.length === 1) {\n\t\t\tprop = properties[0];\n\t\t\tif (Array.isArray(prop)) {\n\t\t\t\treturn this.simplesort(prop[0], prop[1]);\n\t\t\t}\n\t\t\treturn this.simplesort(prop, false);\n\t\t}\n\n\t\t// unify the structure of 'properties' to avoid checking it repeatedly while sorting\n\t\tfor (var i = 0, len = properties.length; i < len; i += 1) {\n\t\t\tprop = properties[i];\n\t\t\tif (!Array.isArray(prop)) {\n\t\t\t\tproperties[i] = [prop, false];\n\t\t\t}\n\t\t}\n\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(props, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn compoundeval(props, data[a], data[b]);\n\t\t\t\t};\n\t\t\t})(properties, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * findOr() - oversee the operation of OR'ed query expressions.\n\t *    OR'ed expression evaluation runs each expression individually against the full collection,\n\t *    and finally does a set OR on each expression's results.\n\t *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindOr(expressionArray) {\n\t\tvar fr = null,\n\t\t\tfri = 0,\n\t\t\tfrlen = 0,\n\t\t\tdocset = [],\n\t\t\tidxset = [],\n\t\t\tidx = 0,\n\t\t\torigCount = this.count();\n\n\t\t// If filter is already initialized, then we query against only those items already in filter.\n\t\t// This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n\t\tfor (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n\t\t\t// we need to branch existing query to run each filter separately and combine results\n\t\t\tfr = this.branch().find(expressionArray[ei]).filteredrows;\n\t\t\tfrlen = fr.length;\n\t\t\t// if the find operation did not reduce the initial set, then the initial set is the actual result\n\t\t\tif (frlen === origCount) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// add any document 'hits'\n\t\t\tfor (fri = 0; fri < frlen; fri++) {\n\t\t\t\tidx = fr[fri];\n\t\t\t\tif (idxset[idx] === undefined) {\n\t\t\t\t\tidxset[idx] = true;\n\t\t\t\t\tdocset.push(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.filteredrows = docset;\n\t\tthis.filterInitialized = true;\n\n\t\treturn this;\n\t}\n\t$or() {\n\t\treturn this.findOr(...arguments);\n\t}\n\n\t/**\n\t * findAnd() - oversee the operation of AND'ed query expressions.\n\t *    AND'ed expression evaluation runs each expression progressively against the full collection,\n\t *    internally utilizing existing chained resultset functionality.\n\t *    Only the first filter can utilize a binary index.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindAnd(expressionArray) {\n\t\t// we have already implementing method chaining in this (our Resultset class)\n\t\t// so lets just progressively apply user supplied and filters\n\t\tfor (var i = 0, len = expressionArray.length; i < len; i++) {\n\t\t\tif (this.count() === 0) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis.find(expressionArray[i]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t$and() {\n\t\treturn this.findAnd(...arguments);\n\t}\n\n\t/**\n\t * Used for querying via a mongo-style query object.\n\t *\n\t * @param {object} query - A mongo-style query object used for filtering current results.\n\t * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tfind(query, firstOnly) {\n\t\tif (this.collection.data.length === 0) {\n\t\t\tif (this.searchIsChained) {\n\t\t\t\tthis.filteredrows = [];\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tvar queryObject = query || 'getAll',\n\t\t\tp,\n\t\t\tproperty,\n\t\t\tqueryObjectOp,\n\t\t\toperator,\n\t\t\tvalue,\n\t\t\tkey,\n\t\t\tsearchByIndex = false,\n\t\t\tresult = [],\n\t\t\tindex = null;\n\n\t\t// if this was note invoked via findOne()\n\t\tfirstOnly = firstOnly || false;\n\n\t\tif (typeof queryObject === 'object') {\n\t\t\tfor (p in queryObject) {\n\t\t\t\tif (hasOwnProperty.call(queryObject, p)) {\n\t\t\t\t\tproperty = p;\n\t\t\t\t\tqueryObjectOp = queryObject[p];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// apply no filters if they want all\n\t\tif (!property || queryObject === 'getAll') {\n\t\t\t// coll.find(), coll.findOne(), coll.chain().find().data() all path here\n\n\t\t\tif (firstOnly) {\n\t\t\t\treturn (this.collection.data.length > 0) ? this.collection.data[0] : null;\n\t\t\t}\n\n\t\t\treturn (this.searchIsChained) ? (this) : (this.collection.data.slice());\n\t\t}\n\n\t\t// injecting $and and $or expression tree evaluation here.\n\t\tif (property === '$and' || property === '$or') {\n\t\t\tif (this.searchIsChained) {\n\t\t\t\tthis[property](queryObjectOp);\n\n\t\t\t\t// for chained find with firstonly,\n\t\t\t\tif (firstOnly && this.filteredrows.length > 1) {\n\t\t\t\t\tthis.filteredrows = this.filteredrows.slice(0, 1);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\t// our $and operation internally chains filters\n\t\t\t\tresult = this.collection.chain()[property](queryObjectOp).data();\n\n\t\t\t\t// if this was coll.findOne() return first object or empty array if null\n\t\t\t\t// since this is invoked from a constructor we can't return null, so we will\n\t\t\t\t// make null in coll.findOne();\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\treturn (result.length === 0) ? ([]) : (result[0]);\n\t\t\t\t}\n\n\t\t\t\t// not first only return all results\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// see if query object is in shorthand mode (assuming eq operator)\n\t\tif (queryObjectOp === null || (typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date)) {\n\t\t\toperator = '$eq';\n\t\t\tvalue = queryObjectOp;\n\t\t} else if (typeof queryObjectOp === 'object') {\n\t\t\tfor (key in queryObjectOp) {\n\t\t\t\tif (hasOwnProperty.call(queryObjectOp, key)) {\n\t\t\t\t\toperator = key;\n\t\t\t\t\tvalue = queryObjectOp[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Do not know what you want to do.');\n\t\t}\n\n\t\t// for regex ops, precompile\n\t\tif (operator === '$regex') {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue = new RegExp(value[0], value[1]);\n\t\t\t} else if (!(value instanceof RegExp)) {\n\t\t\t\tvalue = new RegExp(value);\n\t\t\t}\n\t\t}\n\n\t\tif (query.query) {\n\t\t\tlet res = this.collection._fullTextSearch.search(query);\n\t\t\tlet docIds = Object.keys(res);\n\t\t\tlet results = [];\n\t\t\tfor (let i = 0; i < docIds.length; i++) {\n\t\t\t\tlet docId = parseInt(docIds[i]);\n\t\t\t\tfor (let j = 0; j < this.collection.data.length; j++) {\n\t\t\t\t\tif (this.collection.data[j].$loki === docId) {\n\t\t\t\t\t\tresults.push(this.collection.data[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\t// if user is deep querying the object such as find('name.first': 'odin')\n\t\tvar usingDotNotation = (property.indexOf('.') !== -1);\n\n\t\t// if an index exists for the property being queried against, use it\n\t\t// for now only enabling for non-chained query (who's set of docs matches index)\n\t\t// or chained queries where it is the first filter applied and prop is indexed\n\t\tvar doIndexCheck = !usingDotNotation &&\n\t\t\t(!this.searchIsChained || !this.filterInitialized);\n\n\t\tif (doIndexCheck && this.collection.binaryIndices[property] &&\n\t\t\tindexedOpsList.indexOf(operator) !== -1) {\n\t\t\t// this is where our lazy index rebuilding will take place\n\t\t\t// basically we will leave all indexes dirty until we need them\n\t\t\t// so here we will rebuild only the index tied to this property\n\t\t\t// ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n\t\t\tif (this.collection.adaptiveBinaryIndices !== true) {\n\t\t\t\tthis.collection.ensureIndex(property);\n\t\t\t}\n\n\t\t\tsearchByIndex = true;\n\t\t\tindex = this.collection.binaryIndices[property];\n\t\t}\n\n\t\t// the comparison function\n\t\tvar fun = LokiOps[operator];\n\n\t\t// \"shortcut\" for collection data\n\t\tvar t = this.collection.data;\n\t\t// filter data length\n\t\tvar i = 0,\n\t\t\tlen = 0;\n\n\t\t// Query executed differently depending on :\n\t\t//    - whether it is chained or not\n\t\t//    - whether the property being queried has an index defined\n\t\t//    - if chained, we handle first pass differently for initial filteredrows[] population\n\t\t//\n\t\t// For performance reasons, each case has its own if block to minimize in-loop calculations\n\n\t\t// If not a chained query, bypass filteredrows and work directly against data\n\t\tif (!this.searchIsChained) {\n\t\t\tif (!searchByIndex) {\n\t\t\t\ti = t.length;\n\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\t\treturn (t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\t\treturn (t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\t// if using dot notation then treat property as keypath such as 'name.first'.\n\t\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// searching by binary index via calculateRange() utility method\n\t\t\t\tvar seg = this.collection.calculateRange(operator, property, value);\n\n\t\t\t\t// not chained so this 'find' was designated in Resultset constructor\n\t\t\t\t// so return object itself\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\tif (seg[1] !== -1) {\n\t\t\t\t\t\treturn t[index.values[seg[0]]];\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\tfor (i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\tresult.push(t[index.values[i]]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, len = seg.length; i < len; i++) {\n\t\t\t\t\t\tresult.push(t[index.values[seg[i]]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// not a chained query so return result as data[]\n\t\t\treturn result;\n\t\t}\n\n\n\t\t// Otherwise this is a chained query\n\t\t// Chained queries now preserve results ordering at expense on slightly reduced unindexed performance\n\n\t\tvar filter, rowIdx = 0;\n\n\t\t// If the filteredrows[] is already initialized, use it\n\t\tif (this.filterInitialized) {\n\t\t\tfilter = this.filteredrows;\n\t\t\tlen = filter.length;\n\n\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\tif (usingDotNotation) {\n\t\t\t\tproperty = property.split('.');\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (dotSubScan(t[rowIdx], property, fun, value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (fun(t[rowIdx][property], value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// first chained query so work against data[] but put results in filteredrows\n\t\telse {\n\t\t\t// if not searching by index\n\t\t\tif (!searchByIndex) {\n\t\t\t\tlen = t.length;\n\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// search by index\n\t\t\t\tvar segm = this.collection.calculateRange(operator, property, value);\n\n\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\tfor (i = segm[0]; i <= segm[1]; i++) {\n\t\t\t\t\t\tresult.push(index.values[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, len = segm.length; i < len; i++) {\n\t\t\t\t\t\tresult.push(index.values[segm[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.filterInitialized = true; // next time work against filteredrows[]\n\t\t}\n\n\t\tthis.filteredrows = result;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * where() - Used for filtering via a javascript filter function.\n\t *\n\t * @param {function} fun - A javascript function used for filtering current results by.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\twhere(fun) {\n\t\tvar viewFunction,\n\t\t\tresult = [];\n\n\t\tif ('function' === typeof fun) {\n\t\t\tviewFunction = fun;\n\t\t} else {\n\t\t\tthrow new TypeError('Argument is not a stored view or a function');\n\t\t}\n\t\ttry {\n\t\t\t// if not a chained query then run directly against data[] and return object []\n\t\t\tif (!this.searchIsChained) {\n\t\t\t\tvar i = this.collection.data.length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (viewFunction(this.collection.data[i]) === true) {\n\t\t\t\t\t\tresult.push(this.collection.data[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// not a chained query so returning result as data[]\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t// else chained query, so run against filteredrows\n\t\t\telse {\n\t\t\t\t// If the filteredrows[] is already initialized, use it\n\t\t\t\tif (this.filterInitialized) {\n\t\t\t\t\tvar j = this.filteredrows.length;\n\n\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\tif (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n\t\t\t\t\t\t\tresult.push(this.filteredrows[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filteredrows = result;\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\t// otherwise this is initial chained op, work against data, push into filteredrows[]\n\t\t\t\telse {\n\t\t\t\t\tvar k = this.collection.data.length;\n\n\t\t\t\t\twhile (k--) {\n\t\t\t\t\t\tif (viewFunction(this.collection.data[k]) === true) {\n\t\t\t\t\t\t\tresult.push(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\tthis.filterInitialized = true;\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * count() - returns the number of documents in the resultset.\n\t *\n\t * @returns {number} The number of documents in the resultset.\n\t * @memberof Resultset\n\t */\n\tcount() {\n\t\tif (this.searchIsChained && this.filterInitialized) {\n\t\t\treturn this.filteredrows.length;\n\t\t}\n\t\treturn this.collection.count();\n\t}\n\n\t/**\n\t * Terminates the chain and returns array of filtered documents\n\t *\n\t * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n\t * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n\t *        the collection is not configured for clone object.\n\t * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n\t *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'\n\t *\n\t * @returns {array} Array of documents in the resultset\n\t * @memberof Resultset\n\t */\n\tdata(options) {\n\t\tvar result = [],\n\t\t\tdata = this.collection.data,\n\t\t\tlen,\n\t\t\ti,\n\t\t\tmethod;\n\n\t\toptions = options || {};\n\n\t\t// if this is chained resultset with no filters applied, just return collection.data\n\t\tif (this.searchIsChained && !this.filterInitialized) {\n\t\t\tif (this.filteredrows.length === 0) {\n\t\t\t\t// determine whether we need to clone objects or not\n\t\t\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\t\t\tlen = data.length;\n\t\t\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tresult.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__clone__[\"a\" /* clone */])(data[i], method));\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t// otherwise we are not cloning so return sliced array with same object references\n\t\t\t\telse {\n\t\t\t\t\treturn data.slice();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// filteredrows must have been set manually, so use it\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t}\n\t\t}\n\n\t\tvar fr = this.filteredrows;\n\t\tlen = fr.length;\n\n\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tresult.push(__webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0__clone__[\"a\" /* clone */])(data[fr[i]], method));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tresult.push(data[fr[i]]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Used to run an update operation on all documents currently in the resultset.\n\t *\n\t * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tupdate(updateFunction) {\n\n\t\tif (typeof(updateFunction) !== \"function\") {\n\t\t\tthrow new TypeError('Argument is not a function');\n\t\t}\n\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar len = this.filteredrows.length,\n\t\t\trcd = this.collection.data;\n\n\t\tfor (var idx = 0; idx < len; idx++) {\n\t\t\t// pass in each document object currently in resultset to user supplied updateFunction\n\t\t\tupdateFunction(rcd[this.filteredrows[idx]]);\n\n\t\t\t// notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate\n\t\t\tthis.collection.update(rcd[this.filteredrows[idx]]);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all document objects which are currently in resultset from collection (as well as resultset)\n\t *\n\t * @returns {Resultset} this (empty) resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tremove() {\n\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tthis.collection.remove(this.data());\n\n\t\tthis.filteredrows = [];\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns {value} The output of your reduceFunction\n\t * @memberof Resultset\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n\t * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n\t * @param {Array} joinData - Data array to join to.\n\t * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n\t * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n\t * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n\t * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n\t * @memberof Resultset\n\t */\n\teqJoin(joinData, leftJoinKey, rightJoinKey, mapFun) {\n\n\t\tvar leftData = [],\n\t\t\tleftDataLength,\n\t\t\trightData = [],\n\t\t\trightDataLength,\n\t\t\tkey,\n\t\t\tresult = [],\n\t\t\tleftKeyisFunction = typeof leftJoinKey === 'function',\n\t\t\trightKeyisFunction = typeof rightJoinKey === 'function',\n\t\t\tjoinMap = {};\n\n\t\t//get the left data\n\t\tleftData = this.data();\n\t\tleftDataLength = leftData.length;\n\n\t\t//get the right data\n\t\tif (joinData instanceof Resultset) {\n\t\t\trightData = joinData.data();\n\t\t} else if (Array.isArray(joinData)) {\n\t\t\trightData = joinData;\n\t\t} else {\n\t\t\tthrow new TypeError('joinData needs to be an array or result set');\n\t\t}\n\t\trightDataLength = rightData.length;\n\n\t\t//construct a lookup table\n\n\t\tfor (var i = 0; i < rightDataLength; i++) {\n\t\t\tkey = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n\t\t\tjoinMap[key] = rightData[i];\n\t\t}\n\n\t\tif (!mapFun) {\n\t\t\tmapFun = function(left, right) {\n\t\t\t\treturn {\n\t\t\t\t\tleft: left,\n\t\t\t\t\tright: right\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\t//Run map function over each object in the resultset\n\t\tfor (var j = 0; j < leftDataLength; j++) {\n\t\t\tkey = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n\t\t\tresult.push(mapFun(leftData[j], joinMap[key] || {}));\n\t\t}\n\n\t\t//return return a new resultset with no filters\n\t\tthis.collection = new __WEBPACK_IMPORTED_MODULE_1__collection__[\"a\" /* Collection */]('joinData');\n\t\tthis.collection.insert(result);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t}\n\n\tmap(mapFun) {\n\t\tvar data = this.data().map(mapFun);\n\t\t//return return a new resultset with no filters\n\t\tthis.collection = new __WEBPACK_IMPORTED_MODULE_1__collection__[\"a\" /* Collection */]('mappedData');\n\t\tthis.collection.insert(data);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t}\n\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = Resultset;\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * A loki persistence adapter which persists using node fs module\n * @constructor LokiFsAdapter\n */\nclass LokiFsAdapter {\n\n\tconstructor() {\n\t\tthis.fs = undefined; //TODO require('fs');\n\t}\n\n\t/**\n\t * loadDatabase() - Load data from file, will throw an error if the file does not exist\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiFsAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tvar self = this;\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.stat(dbname, function(err, stats) {\n\t\t\t\tif (!err && stats.isFile()) {\n\t\t\t\t\tself.fs.readFile(dbname, {\n\t\t\t\t\t\tencoding: 'utf8'\n\t\t\t\t\t}, function readFileCallback(err, data) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * saveDatabase() - save data to file, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiFsAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tvar self = this;\n\t\tvar tmpdbname = dbname + '~';\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.writeFile(tmpdbname, dbstring, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tself.fs.rename(tmpdbname, dbname, function(err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * deleteDatabase() - delete the database file, will throw an error if the\n\t * file can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiFsAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tvar self = this;\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = LokiFsAdapter;\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n\nfunction localStorageAvailable() {\n\ttry {\n\t\treturn (window && window.localStorage !== undefined && window.localStorage !== null);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n/*\n 'localStorageAvailable' is not defined\n */\n\n/**\n * A loki persistence adapter which persists to web browser's local storage object\n * @constructor LokiLocalStorageAdapter\n */\nclass LokiLocalStorageAdapter {\n\n\t/**\n\t * loadDatabase() - Load data from localstorage\n\t * @param {string} dbname - the name of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\treturn Promise.resolve(localStorage.getItem(dbname));\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n\t/**\n\t * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was saved\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.setItem(dbname, dbstring);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n\t/**\n\t * deleteDatabase() - delete the database from localstorage, will throw an error if it\n\t * can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.removeItem(dbname);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = LokiLocalStorageAdapter;\n\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/*\nLoki IndexedDb Adapter (need to include this script to use it)\n\nConsole Usage can be used for management/diagnostic, here are a few examples :\nadapter.getDatabaseList(); // with no callback passed, this method will log results to console\nadapter.saveDatabase(\"UserDatabase\", JSON.stringify(myDb));\nadapter.loadDatabase(\"UserDatabase\"); // will log the serialized db to console\nadapter.deleteDatabase(\"UserDatabase\");\n*/\n\n/**\n * Loki persistence adapter class for indexedDb.\n *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n *     Utilizes the included LokiCatalog app/key/value database for actual database persistence.\n *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n *     allow separate contexts for separate apps within a domain.\n *\n * @example\n * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n *\n * @constructor LokiIndexedAdapter\n *\n * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, \"loki\" by default\n */\nclass LokiIndexedAdapter {\n\n\tconstructor(appname) {\n\t\tthis.app = \"loki\";\n\n\t\tif (typeof(appname) !== \"undefined\") {\n\t\t\tthis.app = appname;\n\t\t}\n\n\t\t// keep reference to catalog class for base AKV operations\n\t\tthis.catalog = null;\n\n\t\tif (!this.checkAvailability()) {\n\t\t\tthrow new Error(\"indexedDB does not seem to be supported for your environment\");\n\t\t}\n\t}\n\n\t/**\n\t * Used to check if adapter is available\n\t *\n\t * @returns {boolean} true if indexeddb is available, false if not.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tcheckAvailability() {\n\t\tif (typeof indexedDB !== \"undefined\" && indexedDB) return true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Retrieves a serialized db string from the catalog.\n\t *\n\t * @example\n\t * // LOAD\n\t * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t * var db = new loki(\"test\", { adapter: idbAdapter });\n\t *   db.loadDatabase(function(result) {\n\t *   console.log(\"done\");\n\t * });\n\t *\n\t * @param {string} dbname - the name of the database to retrieve.\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiIndexedAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tadapter.catalog = new LokiCatalog(function(cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t\tresolve(adapter.loadDatabase(dbname));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// lookup up db string in AKV db\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.catalog.getAppKey(appName, dbname, function(result) {\n\t\t\t\tif (result.id === 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(result.val);\n\t\t\t});\n\t\t});\n\t}\n\n\t// alias\n\tloadKey(dbname) {\n\t\treturn this.loadDatabase(dbname);\n\t}\n\n\t/**\n\t * Saves a serialized db to the catalog.\n\t *\n\t * @example\n\t * // SAVE : will save App/Key/Val as \"finance\"/\"test\"/{serializedDb}\n\t * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t * var db = new loki(\"test\", { adapter: idbAdapter });\n\t * var coll = db.addCollection(\"testColl\");\n\t * coll.insert({test: \"val\"});\n\t * db.saveDatabase();  // could pass callback if needed for async complete\n\t *\n\t * @param {string} dbname - the name to give the serialized database within the catalog.\n\t * @param {string} dbstring - the serialized db string to save.\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiIndexedAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\tvar resolve, reject;\n\t\tvar result = new Promise(function(res, rej) {\n\t\t\tresolve = res;\n\t\t\treject = rej;\n\t\t});\n\n\t\tfunction saveCallback(result) {\n\t\t\tif (result && result.success === true) {\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\treject(new Error(\"Error saving database\"));\n\t\t\t}\n\t\t}\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t// now that catalog has been initialized, set (add/update) the AKV entry\n\t\t\t\tcat.setAppKey(appName, dbname, dbstring, saveCallback);\n\t\t\t});\n\n\t\t\treturn result;\n\t\t}\n\n\t\t// set (add/update) entry to AKV database\n\t\tthis.catalog.setAppKey(appName, dbname, dbstring, saveCallback);\n\n\t\treturn result;\n\t}\n\n\t// alias\n\tsaveKey(dbname, dbstring) {\n\t\treturn this.saveDatabase(dbname, dbstring);\n\t}\n\n\t/**\n\t * Deletes a serialized db from the catalog.\n\t *\n\t * @example\n\t * // DELETE DATABASE\n\t * // delete \"finance\"/\"test\" value from catalog\n\t * idbAdapter.deleteDatabase(\"test\", function {\n\t *   // database deleted\n\t * });\n\t *\n\t * @param {string} dbname - the name of the database to delete from the catalog.\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiIndexedAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference and pass callback ahead\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tadapter.catalog = new LokiCatalog(function(cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t\tresolve(adapter.deleteDatabase(dbname));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// catalog was already initialized, so just lookup object and delete by id\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.catalog.getAppKey(appName, dbname, function(result) {\n\t\t\t\tvar id = result.id;\n\n\t\t\t\tif (id !== 0) {\n\t\t\t\t\tadapter.catalog.deleteAppKey(id);\n\t\t\t\t}\n\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\t// alias\n\tdeleteKey(dbname) {\n\t\treturn this.deleteDatabase(dbname);\n\t}\n\n\t/**\n\t * Removes all database partitions and pages with the base filename passed in.\n\t * This utility method does not (yet) guarantee async deletions will be completed before returning\n\t *\n\t * @param {string} dbname - the base filename which container, partitions, or pages are derived\n\t * @memberof LokiIndexedAdapter\n\t */\n\tdeleteDatabasePartitions(dbname) {\n\t\tvar self = this;\n\t\tthis.getDatabaseList(function(result) {\n\t\t\tresult.forEach(function(str) {\n\t\t\t\tif (str.startsWith(dbname)) {\n\t\t\t\t\tself.deleteDatabase(str);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves object array of catalog entries for current app.\n\t *\n\t * @example\n\t * idbAdapter.getDatabaseList(function(result) {\n\t *   // result is array of string names for that appcontext (\"finance\")\n\t *   result.forEach(function(str) {\n\t *     console.log(str);\n\t *   });\n\t * });\n\t *\n\t * @param {function} callback - should accept array of database names in the catalog for current app.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tgetDatabaseList(callback) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\tadapter.getDatabaseList(callback);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// catalog already initialized\n\t\t// get all keys for current appName, and transpose results so just string array\n\t\tthis.catalog.getAppKeys(appName, function(results) {\n\t\t\tvar names = [];\n\n\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\tnames.push(results[idx].key);\n\t\t\t}\n\n\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\tcallback(names);\n\t\t\t} else {\n\t\t\t\tnames.forEach(function(obj) {\n\t\t\t\t\tconsole.log(obj);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t// alias\n\tgetKeyList(callback) {\n\t\treturn this.getDatabaseList(callback);\n\t}\n\n\t/**\n\t * Allows retrieval of list of all keys in catalog along with size\n\t *\n\t * @param {function} callback - (Optional) callback to accept result array.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tgetCatalogSummary(callback) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\tadapter.getCatalogSummary(callback);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// catalog already initialized\n\t\t// get all keys for current appName, and transpose results so just string array\n\t\tthis.catalog.getAllKeys(function(results) {\n\t\t\tvar entries = [];\n\t\t\tvar obj,\n\t\t\t\tsize,\n\t\t\t\toapp,\n\t\t\t\tokey,\n\t\t\t\toval;\n\n\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\tobj = results[idx];\n\t\t\t\toapp = obj.app || '';\n\t\t\t\tokey = obj.key || '';\n\t\t\t\toval = obj.val || '';\n\n\t\t\t\t// app and key are composited into an appkey column so we will mult by 2\n\t\t\t\tsize = oapp.length * 2 + okey.length * 2 + oval.length + 1;\n\n\t\t\t\tentries.push({\n\t\t\t\t\t\"app\": obj.app,\n\t\t\t\t\t\"key\": obj.key,\n\t\t\t\t\t\"size\": size\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\tcallback(entries);\n\t\t\t} else {\n\t\t\t\tentries.forEach(function(obj) {\n\t\t\t\t\tconsole.log(obj);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n/* harmony export (immutable) */ __webpack_exports__[\"LokiIndexedAdapter\"] = LokiIndexedAdapter;\n\n\n/**\n * LokiCatalog - underlying App/Key/Value catalog persistence\n *    This non-interface class implements the actual persistence.\n *    Used by the IndexedAdapter class.\n */\nclass LokiCatalog {\n\tconstructor(callback) {\n\t\tthis.db = null;\n\t\tthis.initializeLokiCatalog(callback);\n\t}\n\n\tinitializeLokiCatalog(callback) {\n\t\tvar openRequest = indexedDB.open(\"LokiCatalog\", 1);\n\t\tvar cat = this;\n\n\t\t// If database doesn't exist yet or its version is lower than our version specified above (2nd param in line above)\n\t\topenRequest.onupgradeneeded = function(e) {\n\t\t\tvar thisDB = e.target.result;\n\t\t\tif (thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\tthisDB.deleteObjectStore(\"LokiAKV\");\n\t\t\t}\n\n\t\t\tif (!thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\tvar objectStore = thisDB.createObjectStore(\"LokiAKV\", {\n\t\t\t\t\tkeyPath: \"id\",\n\t\t\t\t\tautoIncrement: true\n\t\t\t\t});\n\t\t\t\tobjectStore.createIndex(\"app\", \"app\", {\n\t\t\t\t\tunique: false\n\t\t\t\t});\n\t\t\t\tobjectStore.createIndex(\"key\", \"key\", {\n\t\t\t\t\tunique: false\n\t\t\t\t});\n\t\t\t\t// hack to simulate composite key since overhead is low (main size should be in val field)\n\t\t\t\t// user (me) required to duplicate the app and key into comma delimited appkey field off object\n\t\t\t\t// This will allow retrieving single record with that composite key as well as\n\t\t\t\t// still supporting opening cursors on app or key alone\n\t\t\t\tobjectStore.createIndex(\"appkey\", \"appkey\", {\n\t\t\t\t\tunique: true\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\topenRequest.onsuccess = function(e) {\n\t\t\tcat.db = e.target.result;\n\n\t\t\tif (typeof(callback) === \"function\") callback(cat);\n\t\t};\n\n\t\topenRequest.onerror = function(e) {\n\t\t\tthrow e;\n\t\t};\n\t}\n\n\tgetAppKey(app, key, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"appkey\");\n\t\tvar appkey = app + \",\" + key;\n\t\tvar request = index.get(appkey);\n\n\t\trequest.onsuccess = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar lres = e.target.result;\n\n\t\t\t\tif (lres === null || typeof(lres) === \"undefined\") {\n\t\t\t\t\tlres = {\n\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(lres);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(lres);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback({\n\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t}\n\n\tgetAppKeyById(id, callback, data) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar request = store.get(id);\n\n\t\trequest.onsuccess = (function(data, usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(e.target.result, data);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(e.target.result);\n\t\t\t\t}\n\t\t\t};\n\t\t})(data, callback);\n\t}\n\n\tsetAppKey(app, key, val, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"appkey\");\n\t\tvar appkey = app + \",\" + key;\n\t\tvar request = index.get(appkey);\n\n\t\t// first try to retrieve an existing object by that key\n\t\t// need to do this because to update an object you need to have id in object, otherwise it will append id with new autocounter and clash the unique index appkey\n\t\trequest.onsuccess = function(e) {\n\t\t\tvar res = e.target.result;\n\n\t\t\tif (res === null || res === undefined) {\n\t\t\t\tres = {\n\t\t\t\t\tapp: app,\n\t\t\t\t\tkey: key,\n\t\t\t\t\tappkey: app + \",\" + key,\n\t\t\t\t\tval: val\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres.val = val;\n\t\t\t}\n\n\t\t\tvar requestPut = store.put(res);\n\n\t\t\trequestPut.onerror = (function(usercallback) {\n\t\t\t\treturn function(e) {\n\t\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (set) onerror\");\n\t\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t})(callback);\n\n\t\t\trequestPut.onsuccess = (function(usercallback) {\n\t\t\t\treturn function(e) {\n\t\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tsuccess: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t})(callback);\n\t\t};\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback({\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (get) onerror\");\n\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t}\n\n\tdeleteAppKey(id, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar request = store.delete(id);\n\n\t\trequest.onsuccess = (function(usercallback) {\n\t\t\treturn function(evt) {\n\t\t\t\tif (typeof(usercallback) === \"function\") usercallback({\n\t\t\t\t\tsuccess: true\n\t\t\t\t});\n\t\t\t};\n\t\t})(callback);\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(evt) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(false);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.deleteAppKey raised onerror\");\n\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t}\n\n\tgetAppKeys(app, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"app\");\n\n\t\t// We want cursor to all values matching our (single) app param\n\t\tvar singleKeyRange = IDBKeyRange.only(app);\n\n\t\t// To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n\t\tvar cursor = index.openCursor(singleKeyRange);\n\n\t\t// cursor internally, pushing results into this.data[] and return\n\t\t// this.data[] when done (similar to service)\n\t\tvar localdata = [];\n\n\t\tcursor.onsuccess = (function(data, callback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar cursor = e.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tvar currObject = cursor.value;\n\n\t\t\t\t\tdata.push(currObject);\n\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})(localdata, callback);\n\n\t\tcursor.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(null);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.getAppKeys raised onerror\");\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\n\t}\n\n\t// Hide \"cursoring\" and return array of { id: id, key: key }\n\tgetAllKeys(callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar cursor = store.openCursor();\n\n\t\tvar localdata = [];\n\n\t\tcursor.onsuccess = (function(data, callback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar cursor = e.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tvar currObject = cursor.value;\n\n\t\t\t\t\tdata.push(currObject);\n\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})(localdata, callback);\n\n\t\tcursor.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") usercallback(null);\n\t\t\t};\n\t\t})(callback);\n\t}\n}\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__event_emitter__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resultset__ = __webpack_require__(6);\n\n\n\n/*\n'LokiEventEmitter' is not defined        no-undef\n'Resultset' is not defined               no-undef\n\napplySortCriteria -> like Resultset::compoundsort\n\nqueueRebuildEvent -> Promise?\n\n */\n\n/**\n * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n *\n * @example\n * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n * mydv.applyFind({ 'doors' : 4 });\n * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n * var results = mydv.data();\n *\n * @constructor DynamicView\n * @implements LokiEventEmitter\n * @param {Collection} collection - A reference to the collection to work against\n * @param {string} name - The name of this dynamic view\n * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n */\nclass DynamicView extends __WEBPACK_IMPORTED_MODULE_0__event_emitter__[\"a\" /* LokiEventEmitter */] {\n\n\tconstructor(collection, name, options) {\n\t\tsuper();\n\t\tthis.collection = collection;\n\t\tthis.name = name;\n\t\tthis.rebuildPending = false;\n\t\tthis.options = options || {};\n\n\t\tif (!this.options.hasOwnProperty('persistent')) {\n\t\t\tthis.options.persistent = false;\n\t\t}\n\n\t\t// 'persistentSortPriority':\n\t\t// 'passive' will defer the sort phase until they call data(). (most efficient overall)\n\t\t// 'active' will sort async whenever next idle. (prioritizes read speeds)\n\t\tif (!this.options.hasOwnProperty('sortPriority')) {\n\t\t\tthis.options.sortPriority = 'passive';\n\t\t}\n\n\t\tif (!this.options.hasOwnProperty('minRebuildInterval')) {\n\t\t\tthis.options.minRebuildInterval = 1;\n\t\t}\n\n\t\tthis.resultset = new __WEBPACK_IMPORTED_MODULE_1__resultset__[\"a\" /* Resultset */](collection);\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = false;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\t// for now just have 1 event for when we finally rebuilt lazy view\n\t\t// once we refactor transactions, i will tie in certain transactional events\n\n\t\tthis.events = {\n\t\t\t'rebuild': []\n\t\t};\n\t}\n\n\t/**\n\t * rematerialize() - intended for use immediately after deserialization (loading)\n\t *    This will clear out and reapply filterPipeline ops, recreating the view.\n\t *    Since where filters do not persist correctly, this method allows\n\t *    restoring the view to state where user can re-apply those where filters.\n\t *\n\t * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n\t * @returns {DynamicView} This dynamic view for further chained ops.\n\t * @memberof DynamicView\n\t * @fires DynamicView.rebuild\n\t */\n\trematerialize(options) {\n\t\tvar fpl,\n\t\t\tfpi,\n\t\t\tidx;\n\n\t\toptions = options || {};\n\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\t\tthis.resultset = new __WEBPACK_IMPORTED_MODULE_1__resultset__[\"a\" /* Resultset */](this.collection);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.sortDirty = true;\n\t\t}\n\n\t\tif (options.hasOwnProperty('removeWhereFilters')) {\n\t\t\t// for each view see if it had any where filters applied... since they don't\n\t\t\t// serialize those functions lets remove those invalid filters\n\t\t\tfpl = this.filterPipeline.length;\n\t\t\tfpi = fpl;\n\t\t\twhile (fpi--) {\n\t\t\t\tif (this.filterPipeline[fpi].type === 'where') {\n\t\t\t\t\tif (fpi !== this.filterPipeline.length - 1) {\n\t\t\t\t\t\tthis.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filterPipeline.length--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n\t\tvar ofp = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\t// now re-apply 'find' filterPipeline ops\n\t\tfpl = ofp.length;\n\t\tfor (idx = 0; idx < fpl; idx++) {\n\t\t\tthis.applyFind(ofp[idx].val);\n\t\t}\n\n\t\t// during creation of unit tests, i will remove this forced refresh and leave lazy\n\t\tthis.data();\n\n\t\t// emit rebuild event in case user wants to be notified\n\t\tthis.emit('rebuild', this);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * branchResultset() - Makes a copy of the internal resultset for branched queries.\n\t *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n\t *    so your branched query should be immediately resolved and not held for future evaluation.\n\t *\n\t * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n\t * @param {object=} parameters - optional parameters (if optional transform requires them)\n\t * @returns {Resultset} A copy of the internal resultset for branched queries.\n\t * @memberof DynamicView\n\t */\n\tbranchResultset(transform, parameters) {\n\t\tvar rs = this.resultset.branch();\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t}\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tvar copy = new DynamicView(this.collection, this.name, this.options);\n\n\t\tcopy.resultset = this.resultset;\n\t\tcopy.resultdata = []; // let's not save data (copy) to minimize size\n\t\tcopy.resultsdirty = true;\n\t\tcopy.filterPipeline = this.filterPipeline;\n\t\tcopy.sortFunction = this.sortFunction;\n\t\tcopy.sortCriteria = this.sortCriteria;\n\t\tcopy.sortDirty = this.sortDirty;\n\n\t\t// avoid circular reference, reapply in db.loadJSON()\n\t\tcopy.collection = null;\n\n\t\treturn copy;\n\t}\n\n\t/**\n\t * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n\t *     Existing options should be retained.\n\t * @param {object=} options - configure removeFilter behavior\n\t * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n\t * @memberof DynamicView\n\t */\n\tremoveFilters(options) {\n\t\toptions = options || {};\n\n\t\tthis.rebuildPending = false;\n\t\tthis.resultset.reset();\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\tif (options.queueSortPhase === true) {\n\t\t\tthis.queueSortPhase();\n\t\t}\n\t}\n\n\t/**\n\t * applySort() - Used to apply a sort to the dynamic view\n\t * @example\n\t * dv.applySort(function(obj1, obj2) {\n\t *   if (obj1.name === obj2.name) return 0;\n\t *   if (obj1.name > obj2.name) return 1;\n\t *   if (obj1.name < obj2.name) return -1;\n\t * });\n\t *\n\t * @param {function} comparefun - a javascript compare function used for sorting\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySort(comparefun) {\n\t\tthis.sortFunction = comparefun;\n\t\tthis.sortCriteria = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applySimpleSort() - Used to specify a property used for view translation.\n\t * @example\n\t * dv.applySimpleSort(\"name\");\n\t *\n\t * @param {string} propname - Name of property by which to sort.\n\t * @param {boolean=} isdesc - (Optional) If true, the sort will be in descending order.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySimpleSort(propname, isdesc) {\n\t\tthis.sortCriteria = [\n\t\t\t[propname, isdesc || false]\n\t\t];\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * dv.applySortCriteria(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * dv.applySortCriteria(['age', ['name', true]);\n\t * // to sort by age (descending) and then by name (descending)\n\t * dv.applySortCriteria(['age', true], ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n\t * @memberof DynamicView\n\t */\n\tapplySortCriteria(criteria) {\n\t\tthis.sortCriteria = criteria;\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * startTransaction() - marks the beginning of a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tstartTransaction() {\n\t\tthis.cachedresultset = this.resultset.copy();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * commit() - commits a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tcommit() {\n\t\tthis.cachedresultset = null;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * rollback() - rolls back a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\trollback() {\n\t\tthis.resultset = this.cachedresultset;\n\n\t\tif (this.options.persistent) {\n\t\t\t// for now just rebuild the persistent dynamic view data in this worst case scenario\n\t\t\t// (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n\t\t\tthis.resultdata = this.resultset.data();\n\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Implementation detail.\n\t * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter.\n\t * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n\t */\n\t_indexOfFilterWithId(uid) {\n\t\tif (typeof uid === 'string' || typeof uid === 'number') {\n\t\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n\t\t\t\tif (uid === this.filterPipeline[idx].uid) {\n\t\t\t\t\treturn idx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Implementation detail.\n\t * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n\t *\n\t * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n\t */\n\t_addFilter(filter) {\n\t\tthis.filterPipeline.push(filter);\n\t\tthis.resultset[filter.type](filter.val);\n\t}\n\n\t/**\n\t * reapplyFilters() - Reapply all the filters in the current pipeline.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\treapplyFilters() {\n\t\tthis.resultset.reset();\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tvar filters = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\tfor (var idx = 0, len = filters.length; idx < len; idx += 1) {\n\t\t\tthis._addFilter(filters[idx]);\n\t\t}\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n\t *\n\t * @param {object} filter - A filter object to add to the pipeline.\n\t *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFilter(filter) {\n\t\tvar idx = this._indexOfFilterWithId(filter.uid);\n\t\tif (idx >= 0) {\n\t\t\tthis.filterPipeline[idx] = filter;\n\t\t\treturn this.reapplyFilters();\n\t\t}\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tthis._addFilter(filter);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n\t *\n\t * @param {object} query - A mongo-style query object to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFind(query, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'find',\n\t\t\tval: query,\n\t\t\tuid: uid\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n\t *\n\t * @param {function} fun - A javascript filter function to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyWhere(fun, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'where',\n\t\t\tval: fun,\n\t\t\tuid: uid\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter to be removed.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tremoveFilter(uid) {\n\t\tvar idx = this._indexOfFilterWithId(uid);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n\t\t}\n\n\t\tthis.filterPipeline.splice(idx, 1);\n\t\tthis.reapplyFilters();\n\t\treturn this;\n\t}\n\n\t/**\n\t * count() - returns the number of documents representing the current DynamicView contents.\n\t *\n\t * @returns {number} The number of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tcount() {\n\t\t// in order to be accurate we will pay the minimum cost (and not alter dv state management)\n\t\t// recurring resultset data resolutions should know internally its already up to date.\n\t\t// for persistent data this will not update resultdata nor fire rebuild event.\n\t\tif (this.resultsdirty) {\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t}\n\n\t\treturn this.resultset.count();\n\t}\n\n\t/**\n\t * data() - resolves and pending filtering and sorting, then returns document array as result.\n\t *\n\t * @returns {array} An array of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tdata() {\n\t\t// using final sort phase as 'catch all' for a few use cases which require full rebuild\n\t\tif (this.sortDirty || this.resultsdirty) {\n\t\t\tthis.performSortPhase({\n\t\t\t\tsuppressRebuildEvent: true\n\t\t\t});\n\t\t}\n\t\treturn (this.options.persistent) ? (this.resultdata) : (this.resultset.data());\n\t}\n\n\t/**\n\t * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n\t *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n\t */\n\tqueueRebuildEvent() {\n\t\tif (this.rebuildPending) {\n\t\t\treturn;\n\t\t}\n\t\tthis.rebuildPending = true;\n\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tif (self.rebuildPending) {\n\t\t\t\tself.rebuildPending = false;\n\t\t\t\tself.emit('rebuild', self);\n\t\t\t}\n\t\t}, this.options.minRebuildInterval);\n\t}\n\n\t/**\n\t * queueSortPhase : If the view is sorted we will throttle sorting to either :\n\t *    (1) passive - when the user calls data(), or\n\t *    (2) active - once they stop updating and yield js thread control\n\t */\n\tqueueSortPhase() {\n\t\t// already queued? exit without queuing again\n\t\tif (this.sortDirty) {\n\t\t\treturn;\n\t\t}\n\t\tthis.sortDirty = true;\n\n\t\tvar self = this;\n\t\tif (this.options.sortPriority === \"active\") {\n\t\t\t// active sorting... once they are done and yield js thread, run async performSortPhase()\n\t\t\tsetTimeout(function() {\n\t\t\t\tself.performSortPhase();\n\t\t\t}, this.options.minRebuildInterval);\n\t\t} else {\n\t\t\t// must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n\t\t\t// potentially notify user that data has changed.\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\t}\n\n\t/**\n\t * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n\t *\n\t */\n\tperformSortPhase(options) {\n\t\t// async call to this may have been pre-empted by synchronous call to data before async could fire\n\t\tif (!this.sortDirty && !this.resultsdirty) {\n\t\t\treturn;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tif (this.sortDirty) {\n\t\t\tif (this.sortFunction) {\n\t\t\t\tthis.resultset.sort(this.sortFunction);\n\t\t\t} else if (this.sortCriteria) {\n\t\t\t\tthis.resultset.compoundsort(this.sortCriteria);\n\t\t\t}\n\n\t\t\tthis.sortDirty = false;\n\t\t}\n\n\t\tif (this.options.persistent) {\n\t\t\t// persistent view, rebuild local resultdata array\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t\tthis.resultsdirty = false;\n\t\t}\n\n\t\tif (!options.suppressRebuildEvent) {\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\t}\n\n\t/**\n\t * evaluateDocument() - internal method for (re)evaluating document inclusion.\n\t *    Called by : collection.insert() and collection.update().\n\t *\n\t * @param {int} objIndex - index of document to (re)run through filter pipeline.\n\t * @param {bool} isNew - true if the document was just added to the collection.\n\t */\n\tevaluateDocument(objIndex, isNew) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar ofr = this.resultset.filteredrows;\n\t\tvar oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));\n\t\tvar oldlen = ofr.length;\n\n\t\t// creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n\t\t// mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n\t\tvar evalResultset = new __WEBPACK_IMPORTED_MODULE_1__resultset__[\"a\" /* Resultset */](this.collection);\n\t\tevalResultset.filteredrows = [objIndex];\n\t\tevalResultset.filterInitialized = true;\n\t\tvar filter;\n\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n\t\t\tfilter = this.filterPipeline[idx];\n\t\t\tevalResultset[filter.type](filter.val);\n\t\t}\n\n\t\t// not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n\t\tvar newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;\n\n\t\t// wasn't in old, shouldn't be now... do nothing\n\t\tif (oldPos === -1 && newPos === -1) return;\n\n\t\t// wasn't in resultset, should be now... add\n\t\tif (oldPos === -1 && newPos !== -1) {\n\t\t\tofr.push(objIndex);\n\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata.push(this.collection.data[objIndex]);\n\t\t\t}\n\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, shouldn't be now... delete\n\t\tif (oldPos !== -1 && newPos === -1) {\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr.splice(oldPos, 1);\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.splice(oldPos, 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, should still be now... (update persistent only?)\n\t\tif (oldPos !== -1 && newPos !== -1) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\t// in case document changed, replace persistent view data with the latest collection.data document\n\t\t\t\tthis.resultdata[oldPos] = this.collection.data[objIndex];\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * removeDocument() - internal function called on collection.delete()\n\t */\n\tremoveDocument(objIndex) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar ofr = this.resultset.filteredrows;\n\t\tvar oldPos = ofr.indexOf(+objIndex);\n\t\tvar oldlen = ofr.length;\n\t\tvar idx;\n\n\t\tif (oldPos !== -1) {\n\t\t\t// if not last row in resultdata, swap last to hole and truncate last row\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr[oldPos] = ofr[oldlen - 1];\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata[oldPos] = this.resultdata[oldlen - 1];\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// last row, so just truncate last row\n\t\t\telse {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t}\n\n\t\t// since we are using filteredrows to store data array positions\n\t\t// if they remove a document (whether in our view or not),\n\t\t// we need to adjust array positions -1 for all document array references after that position\n\t\toldlen = ofr.length;\n\t\tfor (idx = 0; idx < oldlen; idx++) {\n\t\t\tif (ofr[idx] > objIndex) {\n\t\t\t\tofr[idx]--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * mapReduce() - data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns The output of your reduceFunction\n\t * @memberof DynamicView\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = DynamicView;\n\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nclass ExactIndex {\n\n\tconstructor(exactField) {\n\t\tthis.index = {};\n\t\tthis.field = exactField;\n\t}\n\n\t// add the value you want returned to the key in the index\n\tset(key, val) {\n\t\tif (this.index[key]) {\n\t\t\tthis.index[key].push(val);\n\t\t} else {\n\t\t\tthis.index[key] = [val];\n\t\t}\n\t\tconsole.log(\"?\");\n\t}\n\n\t// remove the value from the index, if the value was the last one, remove the key\n\tremove(key, val) {\n\t\tvar idxSet = this.index[key];\n\t\tfor (var i in idxSet) {\n\t\t\tif (idxSet[i] == val) {\n\t\t\t\tidxSet.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\tif (idxSet.length < 1) {\n\t\t\tthis.index[key] = undefined;\n\t\t}\n\t}\n\n\t// get the values related to the key, could be more than one\n\tget(key) {\n\t\tconsole.log(\"!\");\n\t\treturn this.index[key];\n\t}\n\n\t// clear will zap the index\n\tclear(key) {\n\t\tthis.index = {};\n\t}\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = ExactIndex;\n\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nclass UniqueIndex {\n\n\tconstructor(uniqueField) {\n\t\tthis.field = uniqueField;\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t}\n\n\tset(obj) {\n\t\tvar fieldValue = obj[this.field];\n\t\tif (fieldValue !== null && typeof(fieldValue) !== 'undefined') {\n\t\t\tif (this.keyMap[fieldValue]) {\n\t\t\t\tthrow new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n\t\t\t} else {\n\t\t\t\tthis.keyMap[fieldValue] = obj;\n\t\t\t\tthis.lokiMap[obj.$loki] = fieldValue;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\treturn this.keyMap[key];\n\t}\n\n\tbyId(id) {\n\t\treturn this.keyMap[this.lokiMap[id]];\n\t}\n\n\t/**\n\t * Updates a document's unique index given an updated object.\n\t * @param  {Object} obj Original document object\n\t * @param  {Object} doc New document object (likely the same as obj)\n\t */\n\tupdate(obj, doc) {\n\t\tif (this.lokiMap[obj.$loki] !== doc[this.field]) {\n\t\t\tvar old = this.lokiMap[obj.$loki];\n\t\t\tthis.set(doc);\n\t\t\t// make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n\t\t\tthis.keyMap[old] = undefined;\n\t\t} else {\n\t\t\tthis.keyMap[obj[this.field]] = doc;\n\t\t}\n\t}\n\tremove(key) {\n\t\tvar obj = this.keyMap[key];\n\t\tif (obj !== null && typeof obj !== 'undefined') {\n\t\t\tthis.keyMap[key] = undefined;\n\t\t\tthis.lokiMap[obj.$loki] = undefined;\n\t\t} else {\n\t\t\tthrow new Error('Key is not in unique index: ' + this.field);\n\t\t}\n\t}\n\tclear() {\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t}\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = UniqueIndex;\n\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// loki.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 55f15f730af5566e2a15","\n/*\n 'listen' is not defined  no-undef\n */\n\n/**\n * LokiEventEmitter is a minimalist version of EventEmitter. It enables any\n * constructor that inherits EventEmitter to emit events and trigger\n * listeners that have been added to the event through the on(event, callback) method\n *\n * @constructor LokiEventEmitter\n */\nexport class LokiEventEmitter {\n\n\tconstructor() {\n\t\t/**\n\t\t * @prop {hashmap} events - a hashmap, with each property being an array of callbacks\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.events = {};\n\n\t\t/**\n\t\t * @prop {boolean} asyncListeners - boolean determines whether or not the callbacks associated with each event\n\t\t * should happen in an async fashion or not\n\t\t * Default is false, which means events are synchronous\n\t\t * @memberof LokiEventEmitter\n\t\t */\n\t\tthis.asyncListeners = false;\n\t}\n\n\t/**\n\t * on(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\ton(eventName, listener) {\n\t\tvar event;\n\t\tvar self = this;\n\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach(function(currentEventName) {\n\t\t\t\tself.on(currentEventName, listener);\n\t\t\t});\n\t\t\treturn listener;\n\t\t}\n\n\t\tevent = this.events[eventName];\n\t\tif (!event) {\n\t\t\tevent = this.events[eventName] = [];\n\t\t}\n\t\tevent.push(listener);\n\t\treturn listener;\n\t}\n\n\t/**\n\t * emit(eventName, data) - emits a particular event\n\t * with the option of passing optional parameters which are going to be processed by the callback\n\t * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)\n\t * @param {string} eventName - the name of the event\n\t * @param {object=} data - optional object passed with the event\n\t * @memberof LokiEventEmitter\n\t */\n\temit(eventName, data) {\n\t\tvar self = this;\n\t\tif (eventName && this.events[eventName]) {\n\t\t\tthis.events[eventName].forEach(function(listener) {\n\t\t\t\tif (self.asyncListeners) {\n\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\tlistener(data);\n\t\t\t\t\t}, 1);\n\t\t\t\t} else {\n\t\t\t\t\tlistener(data);\n\t\t\t\t}\n\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Alias of LokiEventEmitter.prototype.on\n\t * addListener(eventName, listener) - adds a listener to the queue of callbacks associated to an event\n\t * @param {string|string[]} eventName - the name(s) of the event(s) to listen to\n\t * @param {function} listener - callback function of listener to attach\n\t * @returns {int} the index of the callback in the array of listeners for a particular event\n\t * @memberof LokiEventEmitter\n\t */\n\taddListener(eventName, listener) {\n\t\treturn this.on(eventName, listener);\n\t}\n\n\t/**\n\t * removeListener() - removes the listener at position 'index' from the event 'eventName'\n\t * @param {string|string[]} eventName - the name(s) of the event(s) which the listener is attached to\n\t * @param {function} listener - the listener callback function to remove from emitter\n\t * @memberof LokiEventEmitter\n\t */\n\tremoveListener(eventName, listener) {\n\t\tvar self = this;\n\t\tif (Array.isArray(eventName)) {\n\t\t\teventName.forEach(function(currentEventName) {\n\t\t\t\tself.removeListener(currentEventName, listen);\n\t\t\t});\n\t\t}\n\n\t\tif (this.events[eventName]) {\n\t\t\tvar listeners = this.events[eventName];\n\t\t\tlisteners.splice(listeners.indexOf(listener), 1);\n\t\t}\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/event_emitter.js\n// module id = 0\n// module chunks = 0","import {LokiEventEmitter} from './event_emitter';\nimport {UniqueIndex} from './unique_index';\nimport {ExactIndex} from './exact_index';\nimport {Resultset} from './resultset';\nimport {DynamicView} from './dynamic_view';\nimport {clone, cloneObjectArray} from './clone';\nimport {ltHelper, gtHelper} from './helper';\nimport {Loki} from './loki';\n\n/*\n 'isDeepProperty' is not defined              no-undef\n 'deepProperty' is not defined                no-undef\n 'average' is not defined                     no-undef\n 'standardDeviation' is not defined           no-undef\n 'sub' is not defined                         no-undef\n\n byExample?\n indexing -> own class?\n remove data only?\n */\n\n/**\n * General utils, including statistical functions\n */\nfunction isDeepProperty(field) {\n\treturn field.indexOf('.') !== -1;\n}\n\nfunction parseBase10(num) {\n\treturn parseFloat(num, 10);\n}\n\nfunction add(a, b) {\n\treturn a + b;\n}\n\nfunction sub(a, b) {\n\treturn a - b;\n}\n\nfunction average(array) {\n\treturn (array.reduce(add, 0)) / array.length;\n}\n\nfunction standardDeviation(values) {\n\tvar avg = average(values);\n\tvar squareDiffs = values.map(function(value) {\n\t\tvar diff = value - avg;\n\t\tvar sqrDiff = diff * diff;\n\t\treturn sqrDiff;\n\t});\n\n\tvar avgSquareDiff = average(squareDiffs);\n\n\tvar stdDev = Math.sqrt(avgSquareDiff);\n\treturn stdDev;\n}\n\nfunction deepProperty(obj, property, isDeep) {\n\tif (isDeep === false) {\n\t\t// pass without processing\n\t\treturn obj[property];\n\t}\n\tvar pieces = property.split('.'),\n\t\troot = obj;\n\twhile (pieces.length > 0) {\n\t\troot = root[pieces.shift()];\n\t}\n\treturn root;\n}\n\n/**\n * Collection class that handles documents of same type\n * @constructor Collection\n * @implements LokiEventEmitter\n * @param {string} name - collection name\n * @param {(array|object)=} options - (optional) array of property names to be indicized OR a configuration object\n * @param {array} options.unique - array of property names to define unique constraints for\n * @param {array} options.exact - array of property names to define exact constraints for\n * @param {array} options.indices - array property names to define binary indexes for\n * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily (default: true)\n * @param {boolean} options.asyncListeners - default is false\n * @param {boolean} options.disableChangesApi - default is true\n * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n * @see {@link Loki#addCollection} for normal creation of collections\n */\nexport class Collection extends LokiEventEmitter {\n\n\tconstructor(name, options) {\n\t\tsuper();\n\t\t// the name of the collection\n\n\t\tthis.name = name;\n\t\t// the data held by the collection\n\t\tthis.data = [];\n\t\tthis.idIndex = []; // index of id\n\t\tthis.binaryIndices = {}; // user defined indexes\n\t\tthis.constraints = {\n\t\t\tunique: {},\n\t\t\texact: {}\n\t\t};\n\n\t\t// unique contraints contain duplicate object references, so they are not persisted.\n\t\t// we will keep track of properties which have unique contraint applied here, and regenerate on load\n\t\tthis.uniqueNames = [];\n\n\t\t// transforms will be used to store frequently used query chains as a series of steps\n\t\t// which itself can be stored along with the database.\n\t\tthis.transforms = {};\n\n\t\t// the object type of the collection\n\t\tthis.objType = name;\n\n\t\t// in autosave scenarios we will use collection level dirty flags to determine whether save is needed.\n\t\t// currently, if any collection is dirty we will autosave the whole database if autosave is configured.\n\t\t// defaulting to true since this is called from addCollection and adding a collection should trigger save\n\t\tthis.dirty = true;\n\n\t\t// private holders for cached data\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\t\tvar self = this;\n\n\t\t/* OPTIONS */\n\t\toptions = options || {};\n\n\t\t// exact match and unique constraints\n\t\tif (options.hasOwnProperty('unique')) {\n\t\t\tif (!Array.isArray(options.unique)) {\n\t\t\t\toptions.unique = [options.unique];\n\t\t\t}\n\t\t\toptions.unique.forEach(function (prop) {\n\t\t\t\tself.uniqueNames.push(prop); // used to regenerate on subsequent database loads\n\t\t\t\tself.constraints.unique[prop] = new UniqueIndex(prop);\n\t\t\t});\n\t\t}\n\n\t\tif (options.hasOwnProperty('exact')) {\n\t\t\toptions.exact.forEach(function (prop) {\n\t\t\t\tself.constraints.exact[prop] = new ExactIndex(prop);\n\t\t\t});\n\t\t}\n\n\t\t// Inverted index\n\t\tthis._fullTextSearch = null;\n\t\tif (Loki.FullTextSearch !== undefined) {\n\t\t\tthis._fullTextSearch = options.hasOwnProperty('fullTextSearch')\n\t\t\t\t? new (Loki.FullTextSearch.FullTextSearch)(options.fullTextSearch) : null;\n\t\t}\n\n\t\t// if set to true we will optimally keep indices 'fresh' during insert/update/remove ops (never dirty/never needs rebuild)\n\t\t// if you frequently intersperse insert/update/remove ops between find ops this will likely be significantly faster option.\n\t\tthis.adaptiveBinaryIndices = options.hasOwnProperty('adaptiveBinaryIndices') ? options.adaptiveBinaryIndices : true;\n\n\t\t// is collection transactional\n\t\tthis.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;\n\n\t\t// options to clone objects when inserting them\n\t\tthis.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;\n\n\t\t// default clone method (if enabled) is parse-stringify\n\t\tthis.cloneMethod = options.hasOwnProperty('cloneMethod') ? options.cloneMethod : \"parse-stringify\";\n\n\t\t// option to make event listeners async, default is sync\n\t\tthis.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;\n\n\t\t// disable track changes\n\t\tthis.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;\n\n\t\t// option to observe objects and update them automatically, ignored if Object.observe is not supported\n\t\tthis.autoupdate = options.hasOwnProperty('autoupdate') ? options.autoupdate : false;\n\n\t\t//option to activate a cleaner daemon - clears \"aged\" documents at set intervals.\n\t\tthis.ttl = {\n\t\t\tage: null,\n\t\t\tttlInterval: null,\n\t\t\tdaemon: null\n\t\t};\n\t\tthis.setTTL(options.ttl || -1, options.ttlInterval);\n\n\t\t// currentMaxId - change manually at your own peril!\n\t\tthis.maxId = 0;\n\n\t\tthis.DynamicViews = [];\n\n\t\t// events\n\t\tthis.events = {\n\t\t\t'insert': [],\n\t\t\t'update': [],\n\t\t\t'pre-insert': [],\n\t\t\t'pre-update': [],\n\t\t\t'close': [],\n\t\t\t'flushbuffer': [],\n\t\t\t'error': [],\n\t\t\t'delete': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\t// changes are tracked by collection and aggregated by the db\n\t\tthis.changes = [];\n\n\t\t// initialize the id index\n\t\tthis.ensureId();\n\t\tvar indices = [];\n\t\t// initialize optional user-supplied indices array ['age', 'lname', 'zip']\n\t\tif (options && options.indices) {\n\t\t\tif (Object.prototype.toString.call(options.indices) === '[object Array]') {\n\t\t\t\tindices = options.indices;\n\t\t\t} else if (typeof options.indices === 'string') {\n\t\t\t\tindices = [options.indices];\n\t\t\t} else {\n\t\t\t\tthrow new TypeError('Indices needs to be a string or an array of strings');\n\t\t\t}\n\t\t}\n\n\t\tfor (var idx = 0; idx < indices.length; idx++) {\n\t\t\tthis.ensureIndex(indices[idx]);\n\t\t}\n\n\t\tfunction observerCallback(changes) {\n\n\t\t\tvar changedObjects = typeof Set === 'function' ? new Set() : [];\n\n\t\t\tif (!changedObjects.add)\n\t\t\t\tchangedObjects.add = function (object) {\n\t\t\t\t\tif (this.indexOf(object) === -1)\n\t\t\t\t\t\tthis.push(object);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\n\t\t\tchanges.forEach(function (change) {\n\t\t\t\tchangedObjects.add(change.object);\n\t\t\t});\n\n\t\t\tchangedObjects.forEach(function (object) {\n\t\t\t\tif (!hasOwnProperty.call(object, '$loki'))\n\t\t\t\t\treturn self.removeAutoUpdateObserver(object);\n\t\t\t\ttry {\n\t\t\t\t\tself.update(object);\n\t\t\t\t} catch (err) {\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tthis.observerCallback = observerCallback;\n\n\t\t/*\n\t\t * This method creates a clone of the current status of an object and associates operation and collection name,\n\t\t * so the parent db can aggregate and generate a changes object for the entire db\n\t\t */\n\t\tfunction createChange(name, op, obj) {\n\t\t\tself.changes.push({\n\t\t\t\tname: name,\n\t\t\t\toperation: op,\n\t\t\t\tobj: JSON.parse(JSON.stringify(obj))\n\t\t\t});\n\t\t}\n\n\t\t// clear all the changes\n\t\tfunction flushChanges() {\n\t\t\tself.changes = [];\n\t\t}\n\n\t\tthis.getChanges = function () {\n\t\t\treturn self.changes;\n\t\t};\n\n\t\tthis.flushChanges = flushChanges;\n\n\t\t/**\n\t\t * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled\n\t\t */\n\t\tfunction insertMeta(obj) {\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!obj.meta) {\n\t\t\t\tobj.meta = {};\n\t\t\t}\n\n\t\t\tobj.meta.created = (new Date()).getTime();\n\t\t\tobj.meta.revision = 0;\n\t\t}\n\n\t\tfunction updateMeta(obj) {\n\t\t\tif (!obj) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tobj.meta.updated = (new Date()).getTime();\n\t\t\tobj.meta.revision += 1;\n\t\t}\n\n\t\tfunction createInsertChange(obj) {\n\t\t\tcreateChange(self.name, 'I', obj);\n\t\t}\n\n\t\tfunction createUpdateChange(obj) {\n\t\t\tcreateChange(self.name, 'U', obj);\n\t\t}\n\n\t\tfunction insertMetaWithChange(obj) {\n\t\t\tinsertMeta(obj);\n\t\t\tcreateInsertChange(obj);\n\t\t}\n\n\t\tfunction updateMetaWithChange(obj) {\n\t\t\tupdateMeta(obj);\n\t\t\tcreateUpdateChange(obj);\n\t\t}\n\n\n\t\t/* assign correct handler based on ChangesAPI flag */\n\t\tvar insertHandler, updateHandler;\n\n\t\tfunction setHandlers() {\n\t\t\tinsertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;\n\t\t\tupdateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;\n\t\t}\n\n\t\tsetHandlers();\n\n\t\tthis.setChangesApi = function (enabled) {\n\t\t\tself.disableChangesApi = !enabled;\n\t\t\tsetHandlers();\n\t\t};\n\t\t/**\n\t\t * built-in events\n\t\t */\n\t\tthis.on('insert', function insertCallback(obj) {\n\t\t\tinsertHandler(obj);\n\t\t});\n\n\t\tthis.on('update', function updateCallback(obj) {\n\t\t\tupdateHandler(obj);\n\t\t});\n\n\t\tthis.on('delete', function deleteCallback(obj) {\n\t\t\tif (!self.disableChangesApi) {\n\t\t\t\tcreateChange(self.name, 'R', obj);\n\t\t\t}\n\t\t});\n\n\t\tthis.on('warning', function (warning) {\n\t\t\tself.console.warn(warning);\n\t\t});\n\t\t// for de-serialization purposes\n\t\tflushChanges();\n\n\t\tthis.console = {\n\t\t\tlog: function () {\n\t\t\t},\n\t\t\twarn: function () {\n\t\t\t},\n\t\t\terror: function () {\n\t\t\t},\n\t\t};\n\n\t\t/* ------ STAGING API -------- */\n\t\t/**\n\t\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t\t * manipulated without affecting the data in the original collection\n\t\t */\n\t\tthis.stages = {};\n\t\tthis.commitLog = [];\n\t}\n\n\taddAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.observe(object, this.observerCallback, ['add', 'update', 'delete', 'reconfigure', 'setPrototype']);\n\t}\n\n\tremoveAutoUpdateObserver(object) {\n\t\tif (!this.autoupdate || typeof Object.observe !== 'function')\n\t\t\treturn;\n\n\t\tObject.unobserve(object, this.observerCallback);\n\t}\n\n\t/**\n\t * Adds a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {array} transform - an array of transformation 'step' objects to save into the collection\n\t * @memberof Collection\n\t */\n\taddTransform(name, transform) {\n\t\tif (this.transforms.hasOwnProperty(name)) {\n\t\t\tthrow new Error(\"a transform by that name already exists\");\n\t\t}\n\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Updates a named collection transform to the collection\n\t * @param {string} name - name to associate with transform\n\t * @param {object} transform - a transformation object to save into collection\n\t * @memberof Collection\n\t */\n\tsetTransform(name, transform) {\n\t\tthis.transforms[name] = transform;\n\t}\n\n\t/**\n\t * Removes a named collection transform from the collection\n\t * @param {string} name - name of collection transform to remove\n\t * @memberof Collection\n\t */\n\tremoveTransform(name) {\n\t\tdelete this.transforms[name];\n\t}\n\n\tbyExample(template) {\n\t\tvar k, obj, query;\n\t\tquery = [];\n\t\tfor (k in template) {\n\t\t\tif (!template.hasOwnProperty(k)) continue;\n\t\t\tquery.push((\n\t\t\t\tobj = {},\n\t\t\t\t\tobj[k] = template[k],\n\t\t\t\t\tobj\n\t\t\t));\n\t\t}\n\t\treturn {\n\t\t\t'$and': query\n\t\t};\n\t}\n\n\tfindObject(template) {\n\t\treturn this.findOne(this.byExample(template));\n\t}\n\n\tfindObjects(template) {\n\t\treturn this.find(this.byExample(template));\n\t}\n\n\t/*----------------------------+\n\t | TTL daemon                  |\n\t +----------------------------*/\n\tttlDaemonFuncGen() {\n\t\tvar collection = this;\n\t\tvar age = this.ttl.age;\n\t\treturn function ttlDaemon() {\n\t\t\tvar now = Date.now();\n\t\t\tvar toRemove = collection.chain().where(function daemonFilter(member) {\n\t\t\t\tvar timestamp = member.meta.updated || member.meta.created;\n\t\t\t\tvar diff = now - timestamp;\n\t\t\t\treturn age < diff;\n\t\t\t});\n\t\t\ttoRemove.remove();\n\t\t};\n\t}\n\n\tsetTTL(age, interval) {\n\t\tif (age < 0) {\n\t\t\tclearInterval(this.ttl.daemon);\n\t\t} else {\n\t\t\tthis.ttl.age = age;\n\t\t\tthis.ttl.ttlInterval = interval;\n\t\t\tthis.ttl.daemon = setInterval(this.ttlDaemonFuncGen(), interval);\n\t\t}\n\t}\n\n\t/*----------------------------+\n\t | INDEXING                    |\n\t +----------------------------*/\n\n\t/**\n\t * create a row filter that covers all documents in the collection\n\t */\n\tprepareFullDocIndex() {\n\t\tvar len = this.data.length;\n\t\tvar indexes = new Array(len);\n\t\tfor (var i = 0; i < len; i += 1) {\n\t\t\tindexes[i] = i;\n\t\t}\n\t\treturn indexes;\n\t}\n\n\t/**\n\t * Will allow reconfiguring certain collection options.\n\t * @param {boolean} options.adaptiveBinaryIndices - collection indices will be actively rebuilt rather than lazily\n\t * @memberof Collection\n\t */\n\tconfigureOptions(options) {\n\t\toptions = options || {};\n\n\t\tif (options.hasOwnProperty('adaptiveBinaryIndices')) {\n\t\t\tthis.adaptiveBinaryIndices = options.adaptiveBinaryIndices;\n\n\t\t\t// if switching to adaptive binary indices, make sure none are 'dirty'\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\tthis.ensureAllIndexes();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ensure binary index on a certain field\n\t * @param {string} property - name of property to create binary index on\n\t * @param {boolean=} force - (Optional) flag indicating whether to construct index immediately\n\t * @memberof Collection\n\t */\n\tensureIndex(property, force) {\n\t\t// optional parameter to force rebuild whether flagged as dirty or not\n\t\tif (typeof(force) === 'undefined') {\n\t\t\tforce = false;\n\t\t}\n\n\t\tif (property === null || property === undefined) {\n\t\t\tthrow new Error('Attempting to set index without an associated property');\n\t\t}\n\n\t\tif (this.binaryIndices[property] && !force) {\n\t\t\tif (!this.binaryIndices[property].dirty) return;\n\t\t}\n\n\t\t// if the index is already defined and we are using adaptiveBinaryIndices and we are not forcing a rebuild, return.\n\t\tif (this.adaptiveBinaryIndices === true && this.binaryIndices.hasOwnProperty(property) && !force) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar index = {\n\t\t\t'name': property,\n\t\t\t'dirty': true,\n\t\t\t'values': this.prepareFullDocIndex()\n\t\t};\n\t\tthis.binaryIndices[property] = index;\n\n\t\tvar wrappedComparer =\n\t\t\t(function (p, data) {\n\t\t\t\treturn function (a, b) {\n\t\t\t\t\tvar objAp = data[a][p],\n\t\t\t\t\t\tobjBp = data[b][p];\n\t\t\t\t\tif (objAp !== objBp) {\n\t\t\t\t\t\tif (ltHelper(objAp, objBp, false)) return -1;\n\t\t\t\t\t\tif (gtHelper(objAp, objBp, false)) return 1;\n\t\t\t\t\t}\n\t\t\t\t\treturn 0;\n\t\t\t\t};\n\t\t\t})(property, this.data);\n\n\t\tindex.values.sort(wrappedComparer);\n\t\tindex.dirty = false;\n\n\t\tthis.dirty = true; // for autosave scenarios\n\t}\n\n\tgetSequencedIndexValues(property) {\n\t\tvar idx, idxvals = this.binaryIndices[property].values;\n\t\tvar result = \"\";\n\n\t\tfor (idx = 0; idx < idxvals.length; idx++) {\n\t\t\tresult += \" [\" + idx + \"] \" + this.data[idxvals[idx]][property];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tensureUniqueIndex(field) {\n\t\tvar index = this.constraints.unique[field];\n\t\tif (!index) {\n\t\t\t// keep track of new unique index for regenerate after database (re)load.\n\t\t\tif (this.uniqueNames.indexOf(field) == -1) {\n\t\t\t\tthis.uniqueNames.push(field);\n\t\t\t}\n\t\t}\n\n\t\t// if index already existed, (re)loading it will likely cause collisions, rebuild always\n\t\tthis.constraints.unique[field] = index = new UniqueIndex(field);\n\t\tthis.data.forEach(function (obj) {\n\t\t\tindex.set(obj);\n\t\t});\n\t\treturn index;\n\t}\n\n\t/**\n\t * Ensure all binary indices\n\t */\n\tensureAllIndexes(force) {\n\t\tvar key, bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\tthis.ensureIndex(key, force);\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexesDirty() {\n\t\tvar key, bIndices = this.binaryIndices;\n\t\tfor (key in bIndices) {\n\t\t\tif (hasOwnProperty.call(bIndices, key)) {\n\t\t\t\tbIndices[key].dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tflagBinaryIndexDirty(index) {\n\t\tif (this.binaryIndices[index])\n\t\t\tthis.binaryIndices[index].dirty = true;\n\t}\n\n\t/**\n\t * Quickly determine number of documents in collection (or query)\n\t * @param {object=} query - (optional) query object to count results of\n\t * @returns {number} number of documents in the collection\n\t * @memberof Collection\n\t */\n\tcount(query) {\n\t\tif (!query) {\n\t\t\treturn this.data.length;\n\t\t}\n\n\t\treturn this.chain().find(query).filteredrows.length;\n\t}\n\n\t/**\n\t * Rebuild idIndex\n\t */\n\tensureId() {\n\t\tvar len = this.data.length,\n\t\t\ti = 0;\n\n\t\tthis.idIndex = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tthis.idIndex.push(this.data[i].$loki);\n\t\t}\n\t}\n\n\t/**\n\t * Add a dynamic view to the collection\n\t * @param {string} name - name of dynamic view to add\n\t * @param {object=} options - (optional) options to configure dynamic view with\n\t * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n\t * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n\t * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n\t * @returns {DynamicView} reference to the dynamic view added\n\t * @memberof Collection\n\t **/\n\taddDynamicView(name, options) {\n\t\tvar dv = new DynamicView(this, name, options);\n\t\tthis.DynamicViews.push(dv);\n\n\t\treturn dv;\n\t}\n\n\t/**\n\t * Remove a dynamic view from the collection\n\t * @param {string} name - name of dynamic view to remove\n\t * @memberof Collection\n\t **/\n\tremoveDynamicView(name) {\n\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\tthis.DynamicViews.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Look up dynamic view reference from within the collection\n\t * @param {string} name - name of dynamic view to retrieve reference of\n\t * @returns {DynamicView} A reference to the dynamic view with that name\n\t * @memberof Collection\n\t **/\n\tgetDynamicView(name) {\n\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\tif (this.DynamicViews[idx].name === name) {\n\t\t\t\treturn this.DynamicViews[idx];\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object and passes all results to an update function.\n\t * For filter function querying you should migrate to [\n\t * Where()]{@link Collection#updateWhere}.\n\t *\n\t * @param {object|function} filterObject - 'mongo-like' query object (or deprecated filterFunction mode)\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tfindAndUpdate(filterObject, updateFunction) {\n\t\tif (typeof(filterObject) === \"function\") {\n\t\t\tthis.updateWhere(filterObject, updateFunction);\n\t\t} else {\n\t\t\tthis.chain().find(filterObject).update(updateFunction);\n\t\t}\n\t}\n\n\t/**\n\t * Applies a 'mongo-like' find query object removes all documents which match that filter.\n\t *\n\t * @param {object} filterObject - 'mongo-like' query object\n\t * @memberof Collection\n\t */\n\tfindAndRemove(filterObject) {\n\t\tthis.chain().find(filterObject).remove();\n\t}\n\n\t/**\n\t * Adds object(s) to collection, ensure object(s) have meta properties, clone it if necessary, etc.\n\t * @param {(object|array)} doc - the document (or array of documents) to be inserted\n\t * @returns {(object|array)} document or documents inserted\n\t * @memberof Collection\n\t */\n\tinsert(doc) {\n\t\tif (!Array.isArray(doc)) {\n\t\t\treturn this.insertOne(doc);\n\t\t}\n\n\t\t// holder to the clone of the object inserted if collections is set to clone objects\n\t\tvar obj;\n\t\tvar results = [];\n\n\t\tthis.emit('pre-insert', doc);\n\t\tfor (var i = 0, len = doc.length; i < len; i++) {\n\t\t\tobj = this.insertOne(doc[i], true);\n\t\t\tif (!obj) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t\tresults.push(obj);\n\t\t}\n\t\tthis.emit('insert', doc);\n\t\treturn results.length === 1 ? results[0] : results;\n\t}\n\n\t/**\n\t * Adds a single object, ensures it has meta properties, clone it if necessary, etc.\n\t * @param {object} doc - the document to be inserted\n\t * @param {boolean} bulkInsert - quiet pre-insert and insert event emits\n\t * @returns {object} document or 'undefined' if there was a problem inserting it\n\t * @memberof Collection\n\t */\n\tinsertOne(doc, bulkInsert) {\n\t\tvar err = null;\n\t\tvar returnObj;\n\n\t\tif (typeof doc !== 'object') {\n\t\t\terr = new TypeError('Document needs to be an object');\n\t\t} else if (doc === null) {\n\t\t\terr = new TypeError('Object cannot be null');\n\t\t}\n\n\t\tif (err !== null) {\n\t\t\tthis.emit('error', err);\n\t\t\tthrow err;\n\t\t}\n\n\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\tvar obj = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n\t\tif (typeof obj.meta === 'undefined') {\n\t\t\tobj.meta = {\n\t\t\t\trevision: 0,\n\t\t\t\tcreated: 0\n\t\t\t};\n\t\t}\n\n\t\t// allow pre-insert to modify actual collection reference even if cloning\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('pre-insert', obj);\n\t\t}\n\t\tif (!this.add(obj)) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// FullTextSearch.\n\t\tif (this._fullTextSearch !== null) {\n\t\t\tthis._fullTextSearch.addDocument(doc);\n\t\t}\n\n\t\t// if cloning, give user back clone of 'cloned' object with $loki and meta\n\t\treturnObj = this.cloneObjects ? clone(obj, this.cloneMethod) : obj;\n\n\t\tthis.addAutoUpdateObserver(returnObj);\n\t\tif (!bulkInsert) {\n\t\t\tthis.emit('insert', returnObj);\n\t\t}\n\t\treturn returnObj;\n\t}\n\n\t/**\n\t * Empties the collection.\n\t * @param {object=} options - configure clear behavior\n\t * @param {bool=} options.removeIndices - (default: false)\n\t * @memberof Collection\n\t */\n\tclear(options) {\n\t\tvar self = this;\n\n\t\toptions = options || {};\n\n\t\tthis.data = [];\n\t\tthis.idIndex = [];\n\t\tthis.cachedIndex = null;\n\t\tthis.cachedBinaryIndex = null;\n\t\tthis.cachedData = null;\n\t\tthis.maxId = 0;\n\t\tthis.DynamicViews = [];\n\t\tthis.dirty = true;\n\n\t\t// if removing indices entirely\n\t\tif (options.removeIndices === true) {\n\t\t\tthis.binaryIndices = {};\n\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\t\t\tthis.uniqueNames = [];\n\t\t}\n\t\t// clear indices but leave definitions in place\n\t\telse {\n\t\t\t// clear binary indices\n\t\t\tvar keys = Object.keys(this.binaryIndices);\n\t\t\tkeys.forEach(function (biname) {\n\t\t\t\tself.binaryIndices[biname].dirty = false;\n\t\t\t\tself.binaryIndices[biname].values = [];\n\t\t\t});\n\n\t\t\t// clear entire unique indices definition\n\t\t\tthis.constraints = {\n\t\t\t\tunique: {},\n\t\t\t\texact: {}\n\t\t\t};\n\n\t\t\t// add definitions back\n\t\t\tthis.uniqueNames.forEach(function (uiname) {\n\t\t\t\tself.ensureUniqueIndex(uiname);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Updates an object and notifies collection that the document has changed.\n\t * @param {object} doc - document to update within the collection\n\t * @memberof Collection\n\t */\n\tupdate(doc) {\n\t\tif (Array.isArray(doc)) {\n\t\t\tvar k = 0,\n\t\t\t\tlen = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.update(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// verify object is a properly formed document\n\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\tthrow new Error('Trying to update unsynced document. Please save the document first by using insert() or addMany()');\n\t\t}\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tvar arr = this.get(doc.$loki, true),\n\t\t\t\toldInternal, // ref to existing obj\n\t\t\t\tnewInternal, // ref to new internal obj\n\t\t\t\tposition,\n\t\t\t\tself = this;\n\n\t\t\tif (!arr) {\n\t\t\t\tthrow new Error('Trying to update a document not in collection.');\n\t\t\t}\n\n\t\t\toldInternal = arr[0]; // -internal- obj ref\n\t\t\tposition = arr[1]; // position in data array\n\n\t\t\t// if configured to clone, do so now... otherwise just use same obj reference\n\t\t\tnewInternal = this.cloneObjects ? clone(doc, this.cloneMethod) : doc;\n\n\t\t\tthis.emit('pre-update', doc);\n\n\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\tself.constraints.unique[key].update(oldInternal, newInternal);\n\t\t\t});\n\n\t\t\t// operate the update\n\t\t\tthis.data[position] = newInternal;\n\n\t\t\tif (newInternal !== doc) {\n\t\t\t\tthis.addAutoUpdateObserver(doc);\n\t\t\t}\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].evaluateDocument(position, false);\n\t\t\t}\n\n\t\t\tvar key;\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexUpdate(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.idIndex[position] = newInternal.$loki;\n\t\t\t//this.flagBinaryIndexesDirty();\n\n\t\t\t// FullTextSearch.\n\t\t\tif (this._fullTextSearch !== null) {\n\t\t\t\tthis._fullTextSearch.updateDocument(doc);\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\tthis.emit('update', doc, this.cloneObjects ? clone(oldInternal, this.cloneMethod) : null);\n\t\t\treturn doc;\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Add object to collection\n\t */\n\tadd(obj) {\n\t\t// if parameter isn't object exit with throw\n\t\tif ('object' !== typeof obj) {\n\t\t\tthrow new TypeError('Object being added needs to be an object');\n\t\t}\n\t\t// if object you are adding already has id column it is either already in the collection\n\t\t// or the object is carrying its own 'id' property.  If it also has a meta property,\n\t\t// then this is already in collection so throw error, otherwise rename to originalId and continue adding.\n\t\tif (typeof(obj.$loki) !== 'undefined') {\n\t\t\tthrow new Error('Document is already in collection, please use update()');\n\t\t}\n\n\t\t/*\n\t\t * try adding object to collection\n\t\t */\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tthis.maxId++;\n\n\t\t\tif (isNaN(this.maxId)) {\n\t\t\t\tthis.maxId = (this.data[this.data.length - 1].$loki + 1);\n\t\t\t}\n\n\t\t\tobj.$loki = this.maxId;\n\t\t\tobj.meta.version = 0;\n\n\t\t\tvar key, constrUnique = this.constraints.unique;\n\t\t\tfor (key in constrUnique) {\n\t\t\t\tif (hasOwnProperty.call(constrUnique, key)) {\n\t\t\t\t\tconstrUnique[key].set(obj);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// add new obj id to idIndex\n\t\t\tthis.idIndex.push(obj.$loki);\n\n\t\t\t// add the object\n\t\t\tthis.data.push(obj);\n\n\t\t\tvar addedPos = this.data.length - 1;\n\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to evaluate for inclusion/exclusion\n\t\t\tvar dvlen = this.DynamicViews.length;\n\t\t\tfor (var i = 0; i < dvlen; i++) {\n\t\t\t\tthis.DynamicViews[i].evaluateDocument(addedPos, true);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexInsert(addedPos, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\n\t\t\treturn (this.cloneObjects) ? (clone(obj, this.cloneMethod)) : (obj);\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\tthrow (err); // re-throw error so user does not think it succeeded\n\t\t}\n\t}\n\n\t/**\n\t * Applies a filter function and passes all results to an update function.\n\t *\n\t * @param {function} filterFunction - filter function whose results will execute update\n\t * @param {function} updateFunction - update function to run against filtered documents\n\t * @memberof Collection\n\t */\n\tupdateWhere(filterFunction, updateFunction) {\n\t\tvar results = this.where(filterFunction),\n\t\t\ti = 0,\n\t\t\tobj;\n\t\ttry {\n\t\t\tfor (i; i < results.length; i++) {\n\t\t\t\tobj = updateFunction(results[i]);\n\t\t\t\tthis.update(obj);\n\t\t\t}\n\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t}\n\t}\n\n\t/**\n\t * Remove all documents matching supplied filter function.\n\t * For 'mongo-like' querying you should migrate to [findAndRemove()]{@link Collection#findAndRemove}.\n\t * @param {function|object} query - query object to filter on\n\t * @memberof Collection\n\t */\n\tremoveWhere(query) {\n\t\tvar list;\n\t\tif (typeof query === 'function') {\n\t\t\tlist = this.data.filter(query);\n\t\t\tthis.remove(list);\n\t\t} else {\n\t\t\tthis.chain().find(query).remove();\n\t\t}\n\t}\n\n\tremoveDataOnly() {\n\t\tthis.remove(this.data.slice());\n\t}\n\n\t/**\n\t * Remove a document from the collection\n\t * @param {object} doc - document to remove from collection\n\t * @memberof Collection\n\t */\n\tremove(doc) {\n\t\tif (typeof doc === 'number') {\n\t\t\tdoc = this.get(doc);\n\t\t}\n\n\t\tif ('object' !== typeof doc) {\n\t\t\tthrow new Error('Parameter is not an object');\n\t\t}\n\t\tif (Array.isArray(doc)) {\n\t\t\tvar k = 0,\n\t\t\t\tlen = doc.length;\n\t\t\tfor (k; k < len; k += 1) {\n\t\t\t\tthis.remove(doc[k]);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (!hasOwnProperty.call(doc, '$loki')) {\n\t\t\tthrow new Error('Object is not a document stored in the collection');\n\t\t}\n\n\t\ttry {\n\t\t\tthis.startTransaction();\n\t\t\tvar arr = this.get(doc.$loki, true),\n\t\t\t\t// obj = arr[0],\n\t\t\t\tposition = arr[1];\n\t\t\tvar self = this;\n\t\t\tObject.keys(this.constraints.unique).forEach(function (key) {\n\t\t\t\tif (doc[key] !== null && typeof doc[key] !== 'undefined') {\n\t\t\t\t\tself.constraints.unique[key].remove(doc[key]);\n\t\t\t\t}\n\t\t\t});\n\t\t\t// now that we can efficiently determine the data[] position of newly added document,\n\t\t\t// submit it for all registered DynamicViews to remove\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].removeDocument(position);\n\t\t\t}\n\n\t\t\tif (this.adaptiveBinaryIndices) {\n\t\t\t\t// for each binary index defined in collection, immediately update rather than flag for lazy rebuild\n\t\t\t\tvar key, bIndices = this.binaryIndices;\n\t\t\t\tfor (key in bIndices) {\n\t\t\t\t\tthis.adaptiveBinaryIndexRemove(position, key);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.flagBinaryIndexesDirty();\n\t\t\t}\n\n\t\t\tthis.data.splice(position, 1);\n\t\t\tthis.removeAutoUpdateObserver(doc);\n\n\t\t\t// remove id from idIndex\n\t\t\tthis.idIndex.splice(position, 1);\n\n\t\t\t// FullTextSearch.\n\t\t\tif (this._fullTextSearch != null) {\n\t\t\t\tthis._fullTextSearch.removeDocument(doc);\n\t\t\t}\n\n\t\t\tthis.commit();\n\t\t\tthis.dirty = true; // for autosave scenarios\n\t\t\tthis.emit('delete', arr[0]);\n\t\t\tdelete doc.$loki;\n\t\t\tdelete doc.meta;\n\t\t\treturn doc;\n\n\t\t} catch (err) {\n\t\t\tthis.rollback();\n\t\t\tthis.console.error(err.message);\n\t\t\tthis.emit('error', err);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/*---------------------+\n\t | Finding methods     |\n\t +----------------------*/\n\n\t/**\n\t * Get by Id - faster than other methods because of the searching algorithm\n\t * @param {int} id - $loki id of document you want to retrieve\n\t * @param {boolean} returnPosition - if 'true' we will return [object, position]\n\t * @returns {(object|array|null)} Object reference if document was found, null if not,\n\t *     or an array if 'returnPosition' was passed.\n\t * @memberof Collection\n\t */\n\tget(id, returnPosition) {\n\t\tvar retpos = returnPosition || false,\n\t\t\tdata = this.idIndex,\n\t\t\tmax = data.length - 1,\n\t\t\tmin = 0,\n\t\t\tmid = (min + max) >> 1;\n\n\t\tid = typeof id === 'number' ? id : parseInt(id, 10);\n\n\t\tif (isNaN(id)) {\n\t\t\tthrow new TypeError('Passed id is not an integer');\n\t\t}\n\n\t\twhile (data[min] < data[max]) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (data[mid] < id) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tif (max === min && data[min] === id) {\n\t\t\tif (retpos) {\n\t\t\t\treturn [this.data[min], min];\n\t\t\t}\n\t\t\treturn this.data[min];\n\t\t}\n\t\treturn null;\n\n\t}\n\n\t/**\n\t * Perform binary range lookup for the data[dataPosition][binaryIndexName] property value\n\t *    Since multiple documents may contain the same value (which the index is sorted on),\n\t *    we hone in on range and then linear scan range to find exact index array position.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tgetBinaryIndexPosition(dataPosition, binaryIndexName) {\n\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\n\t\t// i think calculateRange can probably be moved to collection\n\t\t// as it doesn't seem to need resultset.  need to verify\n\t\t//var rs = new Resultset(this, null, null);\n\t\tvar range = this.calculateRange(\"$eq\", binaryIndexName, val);\n\n\t\tif (range[0] === 0 && range[1] === -1) {\n\t\t\t// uhoh didn't find range\n\t\t\treturn null;\n\t\t}\n\n\t\tvar min = range[0];\n\t\tvar max = range[1];\n\n\t\t// narrow down the sub-segment of index values\n\t\t// where the indexed property value exactly matches our\n\t\t// value and then linear scan to find exact -index- position\n\t\tfor (var idx = min; idx <= max; idx++) {\n\t\t\tif (index[idx] === dataPosition) return idx;\n\t\t}\n\n\t\t// uhoh\n\t\treturn null;\n\t}\n\n\t/**\n\t * Adaptively insert a selected item to the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexInsert(dataPosition, binaryIndexName) {\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\tvar val = this.data[dataPosition][binaryIndexName];\n\t\t//var rs = new Resultset(this, null, null);\n\t\tvar idxPos = this.calculateRangeStart(binaryIndexName, val);\n\n\t\t// insert new data index into our binary index at the proper sorted location for relevant property calculated by idxPos.\n\t\t// doing this after adjusting dataPositions so no clash with previous item at that position.\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 0, dataPosition);\n\t}\n\n\t/**\n\t * Adaptively update a selected item within an index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexUpdate(dataPosition, binaryIndexName) {\n\t\t// linear scan needed to find old position within index unless we optimize for clone scenarios later\n\t\t// within (my) node 5.6.0, the following for() loop with strict compare is -much- faster than indexOf()\n\t\tvar idxPos,\n\t\t\tindex = this.binaryIndices[binaryIndexName].values,\n\t\t\tlen = index.length;\n\n\t\tfor (idxPos = 0; idxPos < len; idxPos++) {\n\t\t\tif (index[idxPos] === dataPosition) break;\n\t\t}\n\n\t\t//var idxPos = this.binaryIndices[binaryIndexName].values.indexOf(dataPosition);\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t//this.adaptiveBinaryIndexRemove(dataPosition, binaryIndexName, true);\n\t\tthis.adaptiveBinaryIndexInsert(dataPosition, binaryIndexName);\n\t}\n\n\t/**\n\t * Adaptively remove a selected item from the index.\n\t * @param {int} dataPosition : coll.data array index/position\n\t * @param {string} binaryIndexName : index to search for dataPosition in\n\t */\n\tadaptiveBinaryIndexRemove(dataPosition, binaryIndexName, removedFromIndexOnly) {\n\t\tvar idxPos = this.getBinaryIndexPosition(dataPosition, binaryIndexName);\n\t\tvar index = this.binaryIndices[binaryIndexName].values;\n\t\tvar len,\n\t\t\tidx;\n\n\t\tif (idxPos === null) {\n\t\t\t// throw new Error('unable to determine binary index position');\n\t\t\treturn null;\n\t\t}\n\n\t\t// remove document from index\n\t\tthis.binaryIndices[binaryIndexName].values.splice(idxPos, 1);\n\n\t\t// if we passed this optional flag parameter, we are calling from adaptiveBinaryIndexUpdate,\n\t\t// in which case data positions stay the same.\n\t\tif (removedFromIndexOnly === true) {\n\t\t\treturn;\n\t\t}\n\n\t\t// since index stores data array positions, if we remove a document\n\t\t// we need to adjust array positions -1 for all document positions greater than removed position\n\t\tlen = index.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tif (index[idx] > dataPosition) {\n\t\t\t\tindex[idx]--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method used for index maintenance.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the proper location where it can be added.\n\t */\n\tcalculateRangeStart(prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(rcd[index[mid]][prop], val, false)) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tvar lbound = min;\n\n\t\tif (ltHelper(rcd[index[lbound]][prop], val, false)) {\n\t\t\treturn lbound + 1;\n\t\t} else {\n\t\t\treturn lbound;\n\t\t}\n\t}\n\n\t/**\n\t * Internal method used for indexed $between.  Given a prop (index name), and a value\n\t * (which may or may not yet exist) this will find the final position of that upper range value.\n\t */\n\tcalculateRangeEnd(prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\tif (index.length === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(val, rcd[index[mid]][prop], false)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tvar ubound = max;\n\n\t\tif (gtHelper(rcd[index[ubound]][prop], val, false)) {\n\t\t\treturn ubound - 1;\n\t\t} else {\n\t\t\treturn ubound;\n\t\t}\n\t}\n\n\t/**\n\t * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.\n\t *    this is used for collection.find() and first find filter of resultset/dynview\n\t *    slightly different than get() binary search in that get() hones in on 1 value,\n\t *    but we have to hone in on many (range)\n\t * @param {string} op - operation, such as $eq\n\t * @param {string} prop - name of property to calculate range for\n\t * @param {object} val - value to use for range calculation.\n\t * @returns {array} [start, end] index array positions\n\t */\n\tcalculateRange(op, prop, val) {\n\t\tvar rcd = this.data;\n\t\tvar index = this.binaryIndices[prop].values;\n\t\tvar min = 0;\n\t\tvar max = index.length - 1;\n\t\tvar mid = 0;\n\n\t\t// when no documents are in collection, return empty range condition\n\t\tif (rcd.length === 0) {\n\t\t\treturn [0, -1];\n\t\t}\n\n\t\tvar minVal = rcd[index[min]][prop];\n\t\tvar maxVal = rcd[index[max]][prop];\n\n\t\t// if value falls outside of our range return [0, -1] to designate no results\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\tcase '$aeq':\n\t\t\t\tif (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$dteq':\n\t\t\t\tif (ltHelper(val, minVal, false) || gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gt':\n\t\t\t\tif (gtHelper(val, maxVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$gte':\n\t\t\t\tif (gtHelper(val, maxVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lt':\n\t\t\t\tif (ltHelper(val, minVal, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (ltHelper(maxVal, val, false)) {\n\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$lte':\n\t\t\t\tif (ltHelper(val, minVal, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (ltHelper(maxVal, val, true)) {\n\t\t\t\t\treturn [0, rcd.length - 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '$between':\n\t\t\t\treturn ([this.calculateRangeStart(prop, val[0]), this.calculateRangeEnd(prop, val[1])]);\n\t\t\tcase '$in':\n\t\t\t\tvar idxset = [],\n\t\t\t\t\tsegResult = [];\n\t\t\t\t// query each value '$eq' operator and merge the seqment results.\n\t\t\t\tfor (var j = 0, len = val.length; j < len; j++) {\n\t\t\t\t\tvar seg = this.calculateRange('$eq', prop, val[j]);\n\n\t\t\t\t\tfor (var i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\tif (idxset[i] === undefined) {\n\t\t\t\t\t\t\tidxset[i] = true;\n\t\t\t\t\t\t\tsegResult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn segResult;\n\t\t}\n\n\t\t// hone in on start position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(rcd[index[mid]][prop], val, false)) {\n\t\t\t\tmin = mid + 1;\n\t\t\t} else {\n\t\t\t\tmax = mid;\n\t\t\t}\n\t\t}\n\n\t\tvar lbound = min;\n\n\t\t// do not reset min, as the upper bound cannot be prior to the found low bound\n\t\tmax = index.length - 1;\n\n\t\t// hone in on end position of value\n\t\twhile (min < max) {\n\t\t\tmid = (min + max) >> 1;\n\n\t\t\tif (ltHelper(val, rcd[index[mid]][prop], false)) {\n\t\t\t\tmax = mid;\n\t\t\t} else {\n\t\t\t\tmin = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\tvar ubound = max;\n\n\t\tvar lval = rcd[index[lbound]][prop];\n\t\tvar uval = rcd[index[ubound]][prop];\n\n\t\tswitch (op) {\n\t\t\tcase '$eq':\n\t\t\t\tif (lval !== val) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (uval !== val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, ubound];\n\t\t\tcase '$dteq':\n\t\t\t\tif (lval > val || lval < val) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\t\t\t\tif (uval > val || uval < val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, ubound];\n\n\n\t\t\tcase '$gt':\n\t\t\t\tif (ltHelper(uval, val, true)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\treturn [ubound, rcd.length - 1];\n\n\t\t\tcase '$gte':\n\t\t\t\tif (ltHelper(lval, val, false)) {\n\t\t\t\t\treturn [0, -1];\n\t\t\t\t}\n\n\t\t\t\treturn [lbound, rcd.length - 1];\n\n\t\t\tcase '$lt':\n\t\t\t\tif (lbound === 0 && ltHelper(lval, val, false)) {\n\t\t\t\t\treturn [0, 0];\n\t\t\t\t}\n\t\t\t\treturn [0, lbound - 1];\n\n\t\t\tcase '$lte':\n\t\t\t\tif (uval !== val) {\n\t\t\t\t\tubound--;\n\t\t\t\t}\n\n\t\t\t\tif (ubound === 0 && ltHelper(uval, val, false)) {\n\t\t\t\t\treturn [0, 0];\n\t\t\t\t}\n\t\t\t\treturn [0, ubound];\n\n\t\t\tdefault:\n\t\t\t\treturn [0, rcd.length - 1];\n\t\t}\n\t}\n\n\t/**\n\t * Retrieve doc by Unique index\n\t * @param {string} field - name of uniquely indexed property to use when doing lookup\n\t * @param {value} value - unique value to search for\n\t * @returns {object} document matching the value passed\n\t * @memberof Collection\n\t */\n\tby(field, value) {\n\t\tvar self;\n\t\tif (value === undefined) {\n\t\t\tself = this;\n\t\t\treturn function (value) {\n\t\t\t\treturn self.by(field, value);\n\t\t\t};\n\t\t}\n\n\t\tvar result = this.constraints.unique[field].get(value);\n\t\tif (!this.cloneObjects) {\n\t\t\treturn result;\n\t\t} else {\n\t\t\treturn clone(result, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Find one object by index property, by property equal to value\n\t * @param {object} query - query object used to perform search with\n\t * @returns {(object|null)} First matching document, or null if none\n\t * @memberof Collection\n\t */\n\tfindOne(query) {\n\t\tquery = query || {};\n\n\t\t// Instantiate Resultset and exec find op passing firstOnly = true param\n\t\tvar result = new Resultset(this, {\n\t\t\tqueryObj: query,\n\t\t\tfirstOnly: true\n\t\t});\n\n\t\tif (Array.isArray(result) && result.length === 0) {\n\t\t\treturn null;\n\t\t} else {\n\t\t\tif (!this.cloneObjects) {\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn clone(result, this.cloneMethod);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Chain method, used for beginning a series of chained find() and/or view() operations\n\t * on a collection.\n\t *\n\t * @param {array} transform - Ordered array of transform step objects similar to chain\n\t * @param {object} parameters - Object containing properties representing parameters to substitute\n\t * @returns {Resultset} (this) resultset, or data array if any map or join functions where called\n\t * @memberof Collection\n\t */\n\tchain(transform, parameters) {\n\t\tvar rs = new Resultset(this);\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t}\n\n\t/**\n\t * Find method, api is similar to mongodb.\n\t * for more complex queries use [chain()]{@link Collection#chain} or [where()]{@link Collection#where}.\n\t * @example {@tutorial Query Examples}\n\t * @param {object} query - 'mongo-like' query object\n\t * @returns {array} Array of matching documents\n\t * @memberof Collection\n\t */\n\tfind(query) {\n\t\tif (typeof(query) === 'undefined') {\n\t\t\tquery = 'getAll';\n\t\t}\n\n\t\tvar results = new Resultset(this, {\n\t\t\tqueryObj: query\n\t\t});\n\t\tif (!this.cloneObjects) {\n\t\t\treturn results;\n\t\t} else {\n\t\t\treturn cloneObjectArray(results, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Find object by unindexed field by property equal to value,\n\t * simply iterates and returns the first element matching the query\n\t */\n\tfindOneUnindexed(prop, value) {\n\t\tvar i = this.data.length,\n\t\t\tdoc;\n\t\twhile (i--) {\n\t\t\tif (this.data[i][prop] === value) {\n\t\t\t\tdoc = this.data[i];\n\t\t\t\treturn doc;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Transaction methods\n\t */\n\n\t/** start the transation */\n\tstartTransaction() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = clone(this.data, this.cloneMethod);\n\t\t\tthis.cachedIndex = this.idIndex;\n\t\t\tthis.cachedBinaryIndex = this.binaryIndices;\n\n\t\t\t// propagate startTransaction to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].startTransaction();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** commit the transation */\n\tcommit() {\n\t\tif (this.transactional) {\n\t\t\tthis.cachedData = null;\n\t\t\tthis.cachedIndex = null;\n\t\t\tthis.cachedBinaryIndex = null;\n\n\t\t\t// propagate commit to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].commit();\n\t\t\t}\n\t\t}\n\t}\n\n\t/** roll back the transation */\n\trollback() {\n\t\tif (this.transactional) {\n\t\t\tif (this.cachedData !== null && this.cachedIndex !== null) {\n\t\t\t\tthis.data = this.cachedData;\n\t\t\t\tthis.idIndex = this.cachedIndex;\n\t\t\t\tthis.binaryIndices = this.cachedBinaryIndex;\n\t\t\t}\n\n\t\t\t// propagate rollback to dynamic views\n\t\t\tfor (var idx = 0; idx < this.DynamicViews.length; idx++) {\n\t\t\t\tthis.DynamicViews[idx].rollback();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Query the collection by supplying a javascript filter function.\n\t * @example\n\t * var results = coll.where(function(obj) {\n\t *   return obj.legs === 8;\n\t * });\n\t *\n\t * @param {function} fun - filter function to run against all collection docs\n\t * @returns {array} all documents which pass your filter function\n\t * @memberof Collection\n\t */\n\twhere(fun) {\n\t\tvar results = new Resultset(this, {\n\t\t\tqueryFunc: fun\n\t\t});\n\t\tif (!this.cloneObjects) {\n\t\t\treturn results;\n\t\t} else {\n\t\t\treturn cloneObjectArray(results, this.cloneMethod);\n\t\t}\n\t}\n\n\t/**\n\t * Map Reduce operation\n\t *\n\t * @param {function} mapFunction - function to use as map function\n\t * @param {function} reduceFunction - function to use as reduce function\n\t * @returns {data} The result of your mapReduce operation\n\t * @memberof Collection\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data.map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Join two collections on specified properties\n\t *\n\t * @param {array} joinData - array of documents to 'join' to this collection\n\t * @param {string} leftJoinProp - property name in collection\n\t * @param {string} rightJoinProp - property name in joinData\n\t * @param {function=} mapFun - (Optional) map function to use\n\t * @returns {Resultset} Result of the mapping operation\n\t * @memberof Collection\n\t */\n\teqJoin(joinData, leftJoinProp, rightJoinProp, mapFun) {\n\t\t// logic in Resultset class\n\t\treturn new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);\n\t}\n\n\t/* ------ STAGING API -------- */\n\t/**\n\t * stages: a map of uniquely identified 'stages', which hold copies of objects to be\n\t * manipulated without affecting the data in the original collection\n\t */\n\n\n\t/**\n\t * (Staging API) create a stage and/or retrieve it\n\t * @memberof Collection\n\t */\n\tgetStage(name) {\n\t\tif (!this.stages[name]) {\n\t\t\tthis.stages[name] = {};\n\t\t}\n\t\treturn this.stages[name];\n\t}\n\n\t/**\n\t * a collection of objects recording the changes applied through a commmitStage\n\t */\n\n\t/**\n\t * (Staging API) create a copy of an object and insert it into a stage\n\t * @memberof Collection\n\t */\n\tstage(stageName, obj) {\n\t\tvar copy = JSON.parse(JSON.stringify(obj));\n\t\tthis.getStage(stageName)[obj.$loki] = copy;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * (Staging API) re-attach all objects to the original collection, so indexes and views can be rebuilt\n\t * then create a message to be inserted in the commitlog\n\t * @param {string} stageName - name of stage\n\t * @param {string} message\n\t * @memberof Collection\n\t */\n\tcommitStage(stageName, message) {\n\t\tvar stage = this.getStage(stageName),\n\t\t\tprop,\n\t\t\ttimestamp = new Date().getTime();\n\n\t\tfor (prop in stage) {\n\n\t\t\tthis.update(stage[prop]);\n\t\t\tthis.commitLog.push({\n\t\t\t\ttimestamp: timestamp,\n\t\t\t\tmessage: message,\n\t\t\t\tdata: JSON.parse(JSON.stringify(stage[prop]))\n\t\t\t});\n\t\t}\n\t\tthis.stages[stageName] = {};\n\t}\n\n\tno_op() {\n\t\treturn;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textract(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tisDotNotation = isDeepProperty(field),\n\t\t\tresult = [];\n\t\tfor (i; i < len; i += 1) {\n\t\t\tresult.push(deepProperty(this.data[i], field, isDotNotation));\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmax(field) {\n\t\treturn Math.max.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmin(field) {\n\t\treturn Math.min.apply(null, this.extract(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tmaxRecord(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tdeep = isDeepProperty(field),\n\t\t\tresult = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\tmax;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (max !== undefined) {\n\t\t\t\tif (max < deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmax = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = max;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\tminRecord(field) {\n\t\tvar i = 0,\n\t\t\tlen = this.data.length,\n\t\t\tdeep = isDeepProperty(field),\n\t\t\tresult = {\n\t\t\t\tindex: 0,\n\t\t\t\tvalue: undefined\n\t\t\t},\n\t\t\tmin;\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tif (min !== undefined) {\n\t\t\t\tif (min > deepProperty(this.data[i], field, deep)) {\n\t\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmin = deepProperty(this.data[i], field, deep);\n\t\t\t\tresult.index = this.data[i].$loki;\n\t\t\t}\n\t\t}\n\t\tresult.value = min;\n\t\treturn result;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t */\n\textractNumerical(field) {\n\t\treturn this.extract(field).map(parseBase10).filter(Number).filter(function (n) {\n\t\t\treturn !(isNaN(n));\n\t\t});\n\t}\n\n\t/**\n\t * Calculates the average numerical value of a property\n\t *\n\t * @param {string} field - name of property in docs to average\n\t * @returns {number} average of property in all docs in the collection\n\t * @memberof Collection\n\t */\n\tavg(field) {\n\t\treturn average(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * Calculate standard deviation of a field\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tstdDev(field) {\n\t\treturn standardDeviation(this.extractNumerical(field));\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field\n\t */\n\tmode(field) {\n\t\tvar dict = {},\n\t\t\tdata = this.extract(field);\n\t\tdata.forEach(function (obj) {\n\t\t\tif (dict[obj]) {\n\t\t\t\tdict[obj] += 1;\n\t\t\t} else {\n\t\t\t\tdict[obj] = 1;\n\t\t\t}\n\t\t});\n\t\tvar max,\n\t\t\tprop, mode;\n\t\tfor (prop in dict) {\n\t\t\tif (max) {\n\t\t\t\tif (max < dict[prop]) {\n\t\t\t\t\tmode = prop;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tmode = prop;\n\t\t\t\tmax = dict[prop];\n\t\t\t}\n\t\t}\n\t\treturn mode;\n\t}\n\n\t/**\n\t * @memberof Collection\n\t * @param {string} field - property name\n\t */\n\tmedian(field) {\n\t\tvar values = this.extractNumerical(field);\n\t\tvalues.sort(sub);\n\n\t\tvar half = Math.floor(values.length / 2);\n\n\t\tif (values.length % 2) {\n\t\t\treturn values[half];\n\t\t} else {\n\t\t\treturn (values[half - 1] + values[half]) / 2.0;\n\t\t}\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/collection.js\n// module id = 1\n// module chunks = 0","/**\n * Created by toni on 1/27/17.\n */\n\n\nexport var Utils = {\n\tcopyProperties: function(src, dest) {\n\t\tvar prop;\n\t\tfor (prop in src) {\n\t\t\tdest[prop] = src[prop];\n\t\t}\n\t},\n\t// used to recursively scan hierarchical transform step object for param substitution\n\tresolveTransformObject: function(subObj, params, depth) {\n\t\tvar prop,\n\t\t\tpname;\n\n\t\tif (typeof depth !== 'number') {\n\t\t\tdepth = 0;\n\t\t}\n\n\t\tif (++depth >= 10) return subObj;\n\n\t\tfor (prop in subObj) {\n\t\t\tif (typeof subObj[prop] === 'string' && subObj[prop].indexOf(\"[%lktxp]\") === 0) {\n\t\t\t\tpname = subObj[prop].substring(8);\n\t\t\t\tif (params.hasOwnProperty(pname)) {\n\t\t\t\t\tsubObj[prop] = params[pname];\n\t\t\t\t}\n\t\t\t} else if (typeof subObj[prop] === \"object\") {\n\t\t\t\tsubObj[prop] = Utils.resolveTransformObject(subObj[prop], params, depth);\n\t\t\t}\n\t\t}\n\n\t\treturn subObj;\n\t},\n\t// top level utility to resolve an entire (single) transform (array of steps) for parameter substitution\n\tresolveTransformParams: function(transform, params) {\n\t\tvar idx,\n\t\t\tclonedStep,\n\t\t\tresolvedTransform = [];\n\n\t\tif (typeof params === 'undefined') return transform;\n\n\t\t// iterate all steps in the transform array\n\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\t// clone transform so our scan and replace can operate directly on cloned transform\n\t\t\tclonedStep = JSON.parse(JSON.stringify(transform[idx]));\n\t\t\tresolvedTransform.push(Utils.resolveTransformObject(clonedStep, params));\n\t\t}\n\n\t\treturn resolvedTransform;\n\t}\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/utils.js\n// module id = 2\n// module chunks = 0","export function clone(data, method) {\n\tif (data === null || data === undefined) {\n\t\treturn null;\n\t}\n\n\tvar cloneMethod = method || 'parse-stringify',\n\t\tcloned;\n\n\tswitch (cloneMethod) {\n\t\tcase \"parse-stringify\":\n\t\t\tcloned = JSON.parse(JSON.stringify(data));\n\t\t\tbreak;\n\t\tcase \"jquery-extend-deep\":\n\t\t\tcloned = jQuery.extend(true, {}, data);\n\t\t\tbreak;\n\t\tcase \"shallow\":\n\t\t\tcloned = Object.create(data.prototype || null);\n\t\t\tObject.keys(data).map(function(i) {\n\t\t\t\tcloned[i] = data[i];\n\t\t\t});\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\n\treturn cloned;\n}\n\nexport function cloneObjectArray(objarray, method) {\n\tvar i,\n\t\tresult = [];\n\n\tif (method == \"parse-stringify\") {\n\t\treturn clone(objarray, method);\n\t}\n\n\ti = objarray.length - 1;\n\n\tfor (; i <= 0; i--) {\n\t\tresult.push(clone(objarray[i], method));\n\t}\n\n\treturn result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/clone.js\n// module id = 3\n// module chunks = 0","/**\n * Created by toni on 1/27/17.\n */\n\n\n/** Helper function for determining 'less-than' conditions for ops, sorting, and binary indices.\n *     In the future we might want $lt and $gt ops to use their own functionality/helper.\n *     Since binary indices on a property might need to index [12, NaN, new Date(), Infinity], we\n *     need this function (as well as gtHelper) to always ensure one value is LT, GT, or EQ to another.\n */\nexport function ltHelper(prop1, prop2, equal) {\n\tvar cv1, cv2;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\tif (equal) {\n\t\t\t\treturn prop1 === prop2;\n\t\t\t} else {\n\t\t\t\tif (prop1) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else {\n\t\t\t\t\treturn prop2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\treturn equal;\n\t\t}\n\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (prop1 === prop2) {\n\t\treturn equal;\n\t}\n\n\tif (prop1 < prop2) {\n\t\treturn true;\n\t}\n\n\tif (prop1 > prop2) {\n\t\treturn false;\n\t}\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\tif (cv1 < cv2) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nexport function gtHelper(prop1, prop2, equal) {\n\tvar cv1, cv2;\n\n\t// 'falsy' and Boolean handling\n\tif (!prop1 || !prop2 || prop1 === true || prop2 === true) {\n\t\tif ((prop1 === true || prop1 === false) && (prop2 === true || prop2 === false)) {\n\t\t\tif (equal) {\n\t\t\t\treturn prop1 === prop2;\n\t\t\t} else {\n\t\t\t\tif (prop1) {\n\t\t\t\t\treturn !prop2;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (prop1 === undefined || prop1 === null || prop1 === false || prop2 === true) {\n\t\t\treturn equal;\n\t\t}\n\t\tif (prop2 === undefined || prop2 === null || prop1 === true || prop2 === false) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tif (prop1 === prop2) {\n\t\treturn equal;\n\t}\n\n\tif (prop1 > prop2) {\n\t\treturn true;\n\t}\n\n\tif (prop1 < prop2) {\n\t\treturn false;\n\t}\n\n\t// not strict equal nor less than nor gt so must be mixed types, convert to string and use that to compare\n\tcv1 = prop1.toString();\n\tcv2 = prop2.toString();\n\n\tif (cv1 == cv2) {\n\t\treturn equal;\n\t}\n\n\tif (cv1 > cv2) {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/helper.js\n// module id = 4\n// module chunks = 0","\nimport {LokiEventEmitter} from './event_emitter';\n\nimport {LokiFsAdapter} from './fs_adapter';\nimport {LokiLocalStorageAdapter} from './local_storage_adapter';\nimport {Collection} from './collection';\nimport {Utils} from './utils';\n\n/*\n'LokiFsAdapter' is not defined                 no-undef\tx\n'LokiLocalStorageAdapter' is not defined       no-undef\tx\n'Collection' is not defined                    no-undef\tx\n'delim' is not defined                         no-undef\tx\n'Utils' is not defined                         no-undef\tx\n\nTBD:\n\t* Default persistence should be not available.\n\t* getIndexedAdapter is also obsolet\n\t* Make some functions private.\n\t* Inflate? -> Utils.copyProperties\n */\n\n/**\n * Loki: The main database class\n * @constructor Loki\n * @implements LokiEventEmitter\n * @param {string} filename - name of the file to be saved to\n * @param {object=} options - (Optional) config options object\n * @param {string} options.env - override environment detection as 'NODEJS', 'BROWSER', 'CORDOVA'\n * @param {boolean} options.verbose - enable console output (default is 'false')\n */\nexport class Loki extends LokiEventEmitter {\n\n\tconstructor(filename, options) {\n\t\tsuper();\n\t\tthis.filename = filename || 'loki.db';\n\t\tthis.collections = [];\n\n\t\t// persist version of code which created the database to the database.\n\t\t// could use for upgrade scenarios\n\t\tthis.databaseVersion = 1.1;\n\t\tthis.engineVersion = 1.1;\n\n\t\t// autosave support (disabled by default)\n\t\t// pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave\n\t\tthis.autosave = false;\n\t\tthis.autosaveInterval = 5000;\n\t\tthis.autosaveHandle = null;\n\n\t\tthis.options = {\n\t\t\tserializationMethod: options && options.hasOwnProperty('serializationMethod') ? options.serializationMethod : 'normal',\n\t\t\tdestructureDelimiter: options && options.hasOwnProperty('destructureDelimiter') ? options.destructureDelimiter : '$<\\n'\n\t\t};\n\n\t\t// currently keeping persistenceMethod and persistenceAdapter as loki level properties that\n\t\t// will not or cannot be deserialized.  You are required to configure persistence every time\n\t\t// you instantiate a loki object (or use default environment detection) in order to load the database anyways.\n\n\t\t// persistenceMethod could be 'fs', 'localStorage', or 'adapter'\n\t\t// this is optional option param, otherwise environment detection will be used\n\t\t// if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.\n\t\tthis.persistenceMethod = null;\n\n\t\t// retain reference to optional (non-serializable) persistenceAdapter 'instance'\n\t\tthis.persistenceAdapter = null;\n\n\t\t// enable console output if verbose flag is set (disabled by default)\n\t\tthis.verbose = options && options.hasOwnProperty('verbose') ? options.verbose : false;\n\n\t\tthis.events = {\n\t\t\t'init': [],\n\t\t\t'loaded': [],\n\t\t\t'flushChanges': [],\n\t\t\t'close': [],\n\t\t\t'changes': [],\n\t\t\t'warning': []\n\t\t};\n\n\t\tvar getENV = function() {\n\t\t\tif (typeof window === 'undefined') {\n\t\t\t\treturn 'NODEJS';\n\t\t\t}\n\n\t\t\tif (typeof global !== 'undefined' && global.window) {\n\t\t\t\treturn 'NODEJS'; //node-webkit\n\t\t\t}\n\n\t\t\tif (typeof document !== 'undefined') {\n\t\t\t\tif (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {\n\t\t\t\t\treturn 'CORDOVA';\n\t\t\t\t}\n\t\t\t\treturn 'BROWSER';\n\t\t\t}\n\t\t\treturn 'CORDOVA';\n\t\t};\n\n\t\t// refactored environment detection due to invalid detection for browser environments.\n\t\t// if they do not specify an options.env we want to detect env rather than default to nodejs.\n\t\t// currently keeping two properties for similar thing (options.env and options.persistenceMethod)\n\t\t//   might want to review whether we can consolidate.\n\t\tif (options && options.hasOwnProperty('env')) {\n\t\t\tthis.ENV = options.env;\n\t\t} else {\n\t\t\tthis.ENV = getENV();\n\t\t}\n\n\t\tthis.on('init', this.clearChanges);\n\t}\n\n\t// experimental support for browserify's abstract syntax scan to pick up dependency of indexed adapter.\n\t// Hopefully, once this hits npm a browserify require of lokijs should scan the main file and detect this indexed adapter reference.\n\tgetIndexedAdapter() {\n\t\tvar adapter;\n\n\t\tif (typeof require === 'function') {\n\t\t\tadapter = require(\"./loki-indexed-adapter.js\");\n\t\t}\n\n\t\treturn adapter;\n\t}\n\n\n\t/**\n\t * configures options related to database persistence.\n\t *\n\t * @param {object} options - configuration options to apply to loki db object\n\t * @param {adapter} options.adapter - an instance of a loki persistence adapter\n\t * @param {boolean} options.autosave - enables autosave\n\t * @param {int} options.autosaveInterval - time interval (in milliseconds) between saves (if dirty)\n\t * @param {boolean} options.autoload - enables autoload on loki instantiation\n\t * @param {object} options.inflate - options that are passed to loadDatabase if autoload enabled\n\t * @param {string} options.serializationMethod - ['normal', 'pretty', 'destructured']\n\t * @param {string} options.destructureDelimiter - string delimiter used for destructured serialization\n\t * @returns {Promise} a Promise that resolves after initialization and (if enabled) autoloading the database\n\t * @memberof Loki\n\t */\n\tinitializePersistence(options) {\n\t\tvar self = this;\n\t\tvar defaultPersistence = {\n\t\t\t\t'NODEJS': 'fs',\n\t\t\t\t'BROWSER': 'localStorage',\n\t\t\t\t'CORDOVA': 'localStorage'\n\t\t\t},\n\t\t\tpersistenceMethods = {\n\t\t\t\t'fs': LokiFsAdapter,\n\t\t\t\t'localStorage': LokiLocalStorageAdapter\n\t\t\t};\n\n\t\tthis.options = options || {};\n\n\t\tthis.persistenceMethod = null;\n\t\t// retain reference to optional persistence adapter 'instance'\n\t\t// currently keeping outside options because it can't be serialized\n\t\tthis.persistenceAdapter = null;\n\n\t\t// process the options\n\t\tif (this.options.hasOwnProperty('persistenceMethod')) {\n\t\t\t// check if the specified persistence method is known\n\t\t\tif (typeof(persistenceMethods[this.options.persistenceMethod]) === 'function') {\n\t\t\t\tthis.persistenceMethod = this.options.persistenceMethod;\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.options.persistenceMethod]();\n\t\t\t}\n\t\t\t// should be throw an error here, or just fall back to defaults ??\n\t\t}\n\n\t\t// ensure defaults exists for options which were not set\n\t\tif (!this.options.hasOwnProperty('serializationMethod')) {\n\t\t\tthis.options.serializationMethod = 'normal';\n\t\t}\n\n\t\t// ensure passed or default option exists\n\t\tif (!this.options.hasOwnProperty('destructureDelimiter')) {\n\t\t\tthis.options.destructureDelimiter = '$<\\n';\n\t\t}\n\n\t\t// if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults\n\t\tif (this.persistenceAdapter === null) {\n\t\t\tthis.persistenceMethod = defaultPersistence[this.ENV];\n\t\t\tif (this.persistenceMethod) {\n\t\t\t\tthis.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();\n\t\t\t}\n\t\t}\n\n\t\t// if user passes adapter, set persistence mode to adapter and retain persistence adapter instance\n\t\tif (this.options.hasOwnProperty('adapter')) {\n\t\t\tthis.persistenceMethod = 'adapter';\n\t\t\tthis.persistenceAdapter = this.options.adapter;\n\t\t}\n\n\t\tif (this.options.hasOwnProperty('autosaveInterval')) {\n\t\t\tthis.autosaveInterval = parseInt(this.options.autosaveInterval, 10);\n\t\t}\n\n\t\tthis.autosaveDisable();\n\n\t\tvar loaded;\n\n\t\t// if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation\n\t\tif (this.options.autoload) {\n\t\t\tloaded = this.loadDatabase(this.options.inflate);\n\t\t} else {\n\t\t\tloaded = Promise.resolve();\n\t\t}\n\n\t\treturn loaded.then(function() {\n\t\t\tif (self.options.autosave) {\n\t\t\t\tself.autosaveEnable();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Copies 'this' database into a new Loki instance. Object references are shared to make lightweight.\n\t *\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool} options.removeNonSerializable - nulls properties not safe for serialization.\n\t * @memberof Loki\n\t */\n\tcopy(options) {\n\t\tvar databaseCopy = new Loki(this.filename);\n\t\tvar clen, idx;\n\n\t\toptions = options || {};\n\n\t\t// currently inverting and letting loadJSONObject do most of the work\n\t\tdatabaseCopy.loadJSONObject(this, {\n\t\t\tretainDirtyFlags: true\n\t\t});\n\n\t\t// since our JSON serializeReplacer is not invoked for reference database adapters, this will let us mimic\n\t\tif (options.hasOwnProperty(\"removeNonSerializable\") && options.removeNonSerializable === true) {\n\t\t\tdatabaseCopy.autosaveHandle = null;\n\t\t\tdatabaseCopy.persistenceAdapter = null;\n\n\t\t\tclen = databaseCopy.collections.length;\n\t\t\tfor (idx = 0; idx < clen; idx++) {\n\t\t\t\tdatabaseCopy.collections[idx].constraints = null;\n\t\t\t\tdatabaseCopy.collections[idx].ttl = null;\n\t\t\t}\n\t\t}\n\n\t\treturn databaseCopy;\n\t}\n\n\t/**\n\t * Shorthand method for quickly creating and populating an anonymous collection.\n\t *    This collection is not referenced internally so upon losing scope it will be garbage collected.\n\t *\n\t * @example\n\t * var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });\n\t *\n\t * @param {Array} docs - document array to initialize the anonymous collection with\n\t * @param {object} options - configuration object, see {@link Loki#addCollection} options\n\t * @returns {Collection} New collection which you can query or chain\n\t * @memberof Loki\n\t */\n\tanonym(docs, options) {\n\t\tvar collection = new Collection('anonym', options);\n\t\tcollection.insert(docs);\n\n\t\tif (this.verbose)\n\t\t\tcollection.console = console;\n\n\t\treturn collection;\n\t}\n\n\t/**\n\t * Adds a collection to the database.\n\t * @param {string} name - name of collection to add\n\t * @param {object=} options - (optional) options to configure collection with.\n\t * @param {array} options.unique - array of property names to define unique constraints for\n\t * @param {array} options.exact - array of property names to define exact constraints for\n\t * @param {array} options.indices - array property names to define binary indexes for\n\t * @param {boolean} options.asyncListeners - default is false\n\t * @param {boolean} options.disableChangesApi - default is true\n\t * @param {boolean} options.autoupdate - use Object.observe to update objects automatically (default: false)\n\t * @param {boolean} options.clone - specify whether inserts and queries clone to/from user\n\t * @param {string} options.cloneMethod - 'parse-stringify' (default), 'jquery-extend-deep', 'shallow'\n\t * @param {int} options.ttlInterval - time interval for clearing out 'aged' documents; not set by default.\n\t * @returns {Collection} a reference to the collection which was just added\n\t * @memberof Loki\n\t */\n\taddCollection(name, options) {\n\t\tvar collection = new Collection(name, options);\n\t\tthis.collections.push(collection);\n\n\t\tif (this.verbose)\n\t\t\tcollection.console = console;\n\n\t\treturn collection;\n\t}\n\n\tloadCollection(collection) {\n\t\tif (!collection.name) {\n\t\t\tthrow new Error('Collection must have a name property to be loaded');\n\t\t}\n\t\tthis.collections.push(collection);\n\t}\n\n\t/**\n\t * Retrieves reference to a collection by name.\n\t * @param {string} collectionName - name of collection to look up\n\t * @returns {Collection} Reference to collection in database by that name, or null if not found\n\t * @memberof Loki\n\t */\n\tgetCollection(collectionName) {\n\t\tvar i,\n\t\t\tlen = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\treturn this.collections[i];\n\t\t\t}\n\t\t}\n\n\t\t// no such collection\n\t\tthis.emit('warning', 'collection ' + collectionName + ' not found');\n\t\treturn null;\n\t}\n\n\tlistCollections() {\n\n\t\tvar i = this.collections.length,\n\t\t\tcolls = [];\n\n\t\twhile (i--) {\n\t\t\tcolls.push({\n\t\t\t\tname: this.collections[i].name,\n\t\t\t\ttype: this.collections[i].objType,\n\t\t\t\tcount: this.collections[i].data.length\n\t\t\t});\n\t\t}\n\t\treturn colls;\n\t}\n\n\t/**\n\t * Removes a collection from the database.\n\t * @param {string} collectionName - name of collection to remove\n\t * @memberof Loki\n\t */\n\tremoveCollection(collectionName) {\n\t\tvar i,\n\t\t\tlen = this.collections.length;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tif (this.collections[i].name === collectionName) {\n\t\t\t\tvar tmpcol = new Collection(collectionName, {});\n\t\t\t\tvar curcol = this.collections[i];\n\t\t\t\tfor (var prop in curcol) {\n\t\t\t\t\tif (curcol.hasOwnProperty(prop) && tmpcol.hasOwnProperty(prop)) {\n\t\t\t\t\t\tcurcol[prop] = tmpcol[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.collections.splice(i, 1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tgetName() {\n\t\treturn this.name;\n\t}\n\n\t/**\n\t * serializeReplacer - used to prevent certain properties from being serialized\n\t *\n\t */\n\tserializeReplacer(key, value) {\n\t\tswitch (key) {\n\t\t\tcase 'autosaveHandle':\n\t\t\tcase 'persistenceAdapter':\n\t\t\tcase 'constraints':\n\t\t\tcase 'ttl':\n\t\t\t\treturn null;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n\n\t/**\n\t * Serialize database to a string which can be loaded via {@link Loki#loadJSON}\n\t *\n\t * @returns {string} Stringified representation of the loki database.\n\t * @memberof Loki\n\t */\n\tserialize(options) {\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"serializationMethod\")) {\n\t\t\toptions.serializationMethod = this.options.serializationMethod;\n\t\t}\n\n\t\tswitch (options.serializationMethod) {\n\t\t\tcase \"normal\":\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t\tcase \"pretty\":\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer, 2);\n\t\t\tcase \"destructured\":\n\t\t\t\treturn this.serializeDestructured(); // use default options\n\t\t\tdefault:\n\t\t\t\treturn JSON.stringify(this, this.serializeReplacer);\n\t\t}\n\t}\n\n\t// alias of serialize\n\ttoJson() {\n\t\treturn this.serialize;\n\t}\n\n\t/**\n\t * Destructured JSON serialization routine to allow alternate serialization methods.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {object=} options - output format options for use externally to loki\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to only output an individual collection or db (-1)\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {string|array} A custom, restructured aggregation of independent serializations.\n\t * @memberof Loki\n\t */\n\tserializeDestructured(options) {\n\t\tvar idx, sidx, result, resultlen;\n\t\tvar reconstruct = [];\n\t\tvar dbcopy;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// 'partitioned' along with 'partition' of 0 or greater is a request for single collection serialization\n\t\tif (options.partitioned === true && options.hasOwnProperty(\"partition\") && options.partition >= 0) {\n\t\t\treturn this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: options.partition\n\t\t\t});\n\t\t}\n\n\t\t// not just an individual collection, so we will need to serialize db container via shallow copy\n\t\tdbcopy = new Loki(this.filename);\n\t\tdbcopy.loadJSONObject(this);\n\n\t\tfor (idx = 0; idx < dbcopy.collections.length; idx++) {\n\t\t\tdbcopy.collections[idx].data = [];\n\t\t}\n\n\t\t// if we -only- wanted the db container portion, return it now\n\t\tif (options.partitioned === true && options.partition === -1) {\n\t\t\t// since we are deconstructing, override serializationMethod to normal for here\n\t\t\treturn dbcopy.serialize({\n\t\t\t\tserializationMethod: \"normal\"\n\t\t\t});\n\t\t}\n\n\t\t// at this point we must be deconstructing the entire database\n\t\t// start by pushing db serialization into first array element\n\t\treconstruct.push(dbcopy.serialize({\n\t\t\tserializationMethod: \"normal\"\n\t\t}));\n\n\t\tdbcopy = null;\n\n\t\t// push collection data into subsequent elements\n\t\tfor (idx = 0; idx < this.collections.length; idx++) {\n\t\t\tresult = this.serializeCollection({\n\t\t\t\tdelimited: options.delimited,\n\t\t\t\tdelimiter: options.delimiter,\n\t\t\t\tcollectionIndex: idx\n\t\t\t});\n\n\t\t\t// NDA : Non-Delimited Array : one iterable concatenated array with empty string collection partitions\n\t\t\tif (options.partitioned === false && options.delimited === false) {\n\t\t\t\tif (!Array.isArray(result)) {\n\t\t\t\t\tthrow new Error(\"a nondelimited, non partitioned collection serialization did not return an expected array\");\n\t\t\t\t}\n\n\t\t\t\t// Array.concat would probably duplicate memory overhead for copying strings.\n\t\t\t\t// Instead copy each individually, and clear old value after each copy.\n\t\t\t\t// Hopefully this will allow g.c. to reduce memory pressure, if needed.\n\t\t\t\tresultlen = result.length;\n\n\t\t\t\tfor (sidx = 0; sidx < resultlen; sidx++) {\n\t\t\t\t\treconstruct.push(result[sidx]);\n\t\t\t\t\tresult[sidx] = null;\n\t\t\t\t}\n\n\t\t\t\treconstruct.push(\"\");\n\t\t\t} else {\n\t\t\t\treconstruct.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// Reconstruct / present results according to four combinations : D, DA, NDA, NDAA\n\t\tif (options.partitioned) {\n\t\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t\t// useful for simple future adaptations of existing persistence adapters to save collections separately\n\t\t\tif (options.delimited) {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t\t// This format might be the most versatile for 'rolling your own' partitioned sync or save.\n\t\t\t// Memory overhead can be reduced by specifying a specific partition, but at this code path they did not, so its all.\n\t\t\telse {\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t} else {\n\t\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t\t// This is the method Loki will use internally if 'destructured'.\n\t\t\t// Little memory overhead improvements but does not require multiple asynchronous adapter call scheduling\n\t\t\tif (options.delimited) {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct.join(options.delimiter);\n\t\t\t}\n\t\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\t\t\t// This format might be best candidate for custom synchronous syncs or saves\n\t\t\telse {\n\t\t\t\t// indicate no more collections\n\t\t\t\treconstruct.push(\"\");\n\n\t\t\t\treturn reconstruct;\n\t\t\t}\n\t\t}\n\n\t\treconstruct.push(\"\");\n\n\t\treturn reconstruct.join(delim);\n\t}\n\n\t/**\n\t * Utility method to serialize a collection in a 'destructured' format\n\t *\n\t * @param {object} options - used to determine output of method\n\t * @param {int=} options.delimited - whether to return single delimited string or an array\n\t * @param {string=} options.delimiter - (optional) if delimited, this is delimiter to use\n\t * @param {int} options.collectionIndex -  specify which collection to serialize data for\n\t *\n\t * @returns {string|array} A custom, restructured aggregation of independent serializations for a single collection.\n\t * @memberof Loki\n\t */\n\tserializeCollection(options) {\n\t\tvar doccount,\n\t\t\tdocidx,\n\t\t\tresultlines = [];\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"collectionIndex\")) {\n\t\t\tthrow new Error(\"serializeCollection called without 'collectionIndex' option\");\n\t\t}\n\n\t\tdoccount = this.collections[options.collectionIndex].data.length;\n\n\t\tresultlines = [];\n\n\t\tfor (docidx = 0; docidx < doccount; docidx++) {\n\t\t\tresultlines.push(JSON.stringify(this.collections[options.collectionIndex].data[docidx]));\n\t\t}\n\n\t\t// D and DA\n\t\tif (options.delimited) {\n\t\t\t// indicate no more documents in collection (via empty delimited string)\n\t\t\tresultlines.push(\"\");\n\n\t\t\treturn resultlines.join(options.delimiter);\n\t\t} else {\n\t\t\t// NDAA and NDA\n\t\t\treturn resultlines;\n\t\t}\n\t}\n\n\t/**\n\t * Destructured JSON deserialization routine to minimize memory overhead.\n\t * Internally, Loki supports destructuring via loki \"serializationMethod' option and\n\t * the optional LokiPartitioningAdapter class. It is also available if you wish to do\n\t * your own structured persistence or data exchange.\n\t *\n\t * @param {string|array} destructuredSource - destructured json or array to deserialize from\n\t * @param {object=} options - source format options\n\t * @param {bool=} options.partitioned - (default: false) whether db and each collection are separate\n\t * @param {int=} options.partition - can be used to deserialize only a single partition\n\t * @param {bool=} options.delimited - (default: true) whether subitems are delimited or subarrays\n\t * @param {string=} options.delimiter - override default delimiter\n\t *\n\t * @returns {object|array} An object representation of the deserialized database, not yet applied to 'this' db or document array\n\t * @memberof Loki\n\t */\n\tdeserializeDestructured(destructuredSource, options) {\n\t\tvar workarray = [];\n\t\tvar len, cdb;\n\t\tvar idx, collIndex = 0,\n\t\t\tcollCount, lineIndex = 1,\n\t\t\tdone = false;\n\t\tvar currLine, currObject;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\t// Partitioned\n\t\t// DA : Delimited Array of strings [0] db [1] collection [n] collection { partitioned: true, delimited: true }\n\t\t// NDAA : Non-Delimited Array with subArrays. db at [0] and collection subarrays at [n] { partitioned: true, delimited : false }\n\t\t// -or- single partition\n\t\tif (options.partitioned) {\n\t\t\t// handle single partition\n\t\t\tif (options.hasOwnProperty('partition')) {\n\t\t\t\t// db only\n\t\t\t\tif (options.partition === -1) {\n\t\t\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\n\t\t\t\t\treturn cdb;\n\t\t\t\t}\n\n\t\t\t\t// single collection, return doc array\n\t\t\t\treturn this.deserializeCollection(destructuredSource[options.partition + 1], options);\n\t\t\t}\n\n\t\t\t// Otherwise we are restoring an entire partitioned db\n\t\t\tcdb = JSON.parse(destructuredSource[0]);\n\t\t\tcollCount = cdb.collections.length;\n\t\t\tfor (collIndex = 0; collIndex < collCount; collIndex++) {\n\t\t\t\t// attach each collection docarray to container collection data, add 1 to collection array index since db is at 0\n\t\t\t\tcdb.collections[collIndex].data = this.deserializeCollection(destructuredSource[collIndex + 1], options);\n\t\t\t}\n\n\t\t\treturn cdb;\n\t\t}\n\n\t\t// Non-Partitioned\n\t\t// D : one big Delimited string { partitioned: false, delimited : true }\n\t\t// NDA : Non-Delimited Array : one iterable array with empty string collection partitions { partitioned: false, delimited: false }\n\n\t\t// D\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tdestructuredSource = null; // lower memory pressure\n\t\t\tlen = workarray.length;\n\n\t\t\tif (len === 0) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\t// NDA\n\t\telse {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\t// first line is database and collection shells\n\t\tcdb = JSON.parse(workarray[0]);\n\t\tcollCount = cdb.collections.length;\n\t\tworkarray[0] = null;\n\n\t\twhile (!done) {\n\t\t\tcurrLine = workarray[lineIndex];\n\n\t\t\t// empty string indicates either end of collection or end of file\n\t\t\tif (workarray[lineIndex] === \"\") {\n\t\t\t\t// if no more collections to load into, we are done\n\t\t\t\tif (++collIndex > collCount) {\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrObject = JSON.parse(workarray[lineIndex]);\n\t\t\t\tcdb.collections[collIndex].data.push(currObject);\n\t\t\t}\n\n\t\t\t// lower memory pressure and advance iterator\n\t\t\tworkarray[lineIndex++] = null;\n\t\t}\n\n\t\treturn cdb;\n\t}\n\n\t/**\n\t * Deserializes a destructured collection.\n\t *\n\t * @param {string|array} destructuredSource - destructured representation of collection to inflate\n\t * @param {object} options - used to describe format of destructuredSource input\n\t * @param {int} options.delimited - whether source is delimited string or an array\n\t * @param {string} options.delimiter - (optional) if delimited, this is delimiter to use\n\t *\n\t * @returns {array} an array of documents to attach to collection.data.\n\t * @memberof Loki\n\t */\n\tdeserializeCollection(destructuredSource, options) {\n\t\tvar workarray = [];\n\t\tvar idx, len;\n\n\t\toptions = options || {};\n\n\t\tif (!options.hasOwnProperty(\"partitioned\")) {\n\t\t\toptions.partitioned = false;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimited\")) {\n\t\t\toptions.delimited = true;\n\t\t}\n\n\t\tif (!options.hasOwnProperty(\"delimiter\")) {\n\t\t\toptions.delimiter = this.options.destructureDelimiter;\n\t\t}\n\n\t\tif (options.delimited) {\n\t\t\tworkarray = destructuredSource.split(options.delimiter);\n\t\t\tworkarray.pop();\n\t\t} else {\n\t\t\tworkarray = destructuredSource;\n\t\t}\n\n\t\tlen = workarray.length;\n\t\tfor (idx = 0; idx < len; idx++) {\n\t\t\tworkarray[idx] = JSON.parse(workarray[idx]);\n\t\t}\n\n\t\treturn workarray;\n\t}\n\n\t/**\n\t * Inflates a loki database from a serialized JSON string\n\t *\n\t * @param {string} serializedDb - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t * @memberof Loki\n\t */\n\tloadJSON(serializedDb, options) {\n\t\tvar dbObject;\n\t\tif (serializedDb.length === 0) {\n\t\t\tdbObject = {};\n\t\t} else {\n\t\t\t// using option defined in instantiated db not what was in serialized db\n\t\t\tswitch (this.options.serializationMethod) {\n\t\t\t\tcase \"normal\":\n\t\t\t\tcase \"pretty\":\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"destructured\":\n\t\t\t\t\tdbObject = this.deserializeDestructured(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tdbObject = JSON.parse(serializedDb);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tthis.loadJSONObject(dbObject, options);\n\t}\n\n\t/**\n\t * Inflates a loki database from a JS object\n\t *\n\t * @param {object} dbObject - a serialized loki database string\n\t * @param {object} options - apply or override collection level settings\n\t * @param {bool?} options.retainDirtyFlags - whether collection dirty flags will be preserved\n\t * @memberof Loki\n\t */\n\tloadJSONObject(dbObject, options) {\n\t\tvar i = 0,\n\t\t\tlen = dbObject.collections ? dbObject.collections.length : 0,\n\t\t\tcoll,\n\t\t\tcopyColl,\n\t\t\tclen,\n\t\t\tj,\n\t\t\tloader,\n\t\t\tcollObj;\n\n\t\tthis.name = dbObject.name;\n\n\t\t// restore database version\n\t\tthis.databaseVersion = 1.0;\n\t\tif (dbObject.hasOwnProperty('databaseVersion')) {\n\t\t\tthis.databaseVersion = dbObject.databaseVersion;\n\t\t}\n\n\t\tthis.collections = [];\n\n\t\tfunction makeLoader(coll) {\n\t\t\tvar collOptions = options[coll.name];\n\t\t\tvar inflater;\n\n\t\t\tif (collOptions.proto) {\n\t\t\t\tinflater = collOptions.inflate || Utils.copyProperties;\n\n\t\t\t\treturn function(data) {\n\t\t\t\t\tvar collObj = new(collOptions.proto)();\n\t\t\t\t\tinflater(data, collObj);\n\t\t\t\t\treturn collObj;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn collOptions.inflate;\n\t\t}\n\n\t\tfor (i; i < len; i += 1) {\n\t\t\tcoll = dbObject.collections[i];\n\t\t\tcopyColl = this.addCollection(coll.name);\n\n\t\t\tcopyColl.adaptiveBinaryIndices = coll.hasOwnProperty('adaptiveBinaryIndices') ? (coll.adaptiveBinaryIndices === true) : false;\n\t\t\tcopyColl.transactional = coll.transactional;\n\t\t\tcopyColl.asyncListeners = coll.asyncListeners;\n\t\t\tcopyColl.disableChangesApi = coll.disableChangesApi;\n\t\t\tcopyColl.cloneObjects = coll.cloneObjects;\n\t\t\tcopyColl.cloneMethod = coll.cloneMethod || \"parse-stringify\";\n\t\t\tcopyColl.autoupdate = coll.autoupdate;\n\t\t\tcopyColl.changes = coll.changes;\n\n\t\t\tif (options && options.retainDirtyFlags === true) {\n\t\t\t\tcopyColl.dirty = coll.dirty;\n\t\t\t} else {\n\t\t\t\tcopyColl.dirty = false;\n\t\t\t}\n\n\t\t\t// load each element individually\n\t\t\tclen = coll.data.length;\n\t\t\tj = 0;\n\t\t\tif (options && options.hasOwnProperty(coll.name)) {\n\t\t\t\tloader = makeLoader(coll);\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcollObj = loader(coll.data[j]);\n\t\t\t\t\tcopyColl.data[j] = collObj;\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(collObj);\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\tfor (j; j < clen; j++) {\n\t\t\t\t\tcopyColl.data[j] = coll.data[j];\n\t\t\t\t\tcopyColl.addAutoUpdateObserver(copyColl.data[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcopyColl.maxId = (coll.data.length === 0) ? 0 : coll.maxId;\n\t\t\tcopyColl.idIndex = coll.idIndex;\n\t\t\tif (typeof(coll.binaryIndices) !== 'undefined') {\n\t\t\t\tcopyColl.binaryIndices = coll.binaryIndices;\n\t\t\t}\n\t\t\tif (typeof coll.transforms !== 'undefined') {\n\t\t\t\tcopyColl.transforms = coll.transforms;\n\t\t\t}\n\n\t\t\tcopyColl.ensureId();\n\n\t\t\t// regenerate unique indexes\n\t\t\tcopyColl.uniqueNames = [];\n\t\t\tif (coll.hasOwnProperty(\"uniqueNames\")) {\n\t\t\t\tcopyColl.uniqueNames = coll.uniqueNames;\n\t\t\t\tfor (j = 0; j < copyColl.uniqueNames.length; j++) {\n\t\t\t\t\tcopyColl.ensureUniqueIndex(copyColl.uniqueNames[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case they are loading a database created before we added dynamic views, handle undefined\n\t\t\tif (typeof(coll.DynamicViews) === 'undefined') continue;\n\n\t\t\t// reinflate DynamicViews and attached Resultsets\n\t\t\tfor (var idx = 0; idx < coll.DynamicViews.length; idx++) {\n\t\t\t\tvar colldv = coll.DynamicViews[idx];\n\n\t\t\t\tvar dv = copyColl.addDynamicView(colldv.name, colldv.options);\n\t\t\t\tdv.resultdata = colldv.resultdata;\n\t\t\t\tdv.resultsdirty = colldv.resultsdirty;\n\t\t\t\tdv.filterPipeline = colldv.filterPipeline;\n\n\t\t\t\tdv.sortCriteria = colldv.sortCriteria;\n\t\t\t\tdv.sortFunction = null;\n\n\t\t\t\tdv.sortDirty = colldv.sortDirty;\n\t\t\t\tdv.resultset.filteredrows = colldv.resultset.filteredrows;\n\t\t\t\tdv.resultset.searchIsChained = colldv.resultset.searchIsChained;\n\t\t\t\tdv.resultset.filterInitialized = colldv.resultset.filterInitialized;\n\n\t\t\t\tdv.rematerialize({\n\t\t\t\t\tremoveWhereFilters: true\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Emits the close event. In autosave scenarios, if the database is dirty, this will save and disable timer.\n\t * Does not actually destroy the db.\n\t *\n\t * @returns {Promise} a Promise that resolves after closing the database succeeded\n\t * @memberof Loki\n\t */\n\tclose() {\n\t\tvar self = this;\n\t\tvar saved;\n\n\t\t// for autosave scenarios, we will let close perform final save (if dirty)\n\t\t// For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes\n\t\tif (this.autosave) {\n\t\t\tthis.autosaveDisable();\n\t\t\tif (this.autosaveDirty()) {\n\t\t\t\tsaved = this.saveDatabase();\n\t\t\t}\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(function() {\n\t\t\tself.emit('close');\n\t\t});\n\t}\n\n\t/**-------------------------+\n\t | Changes API               |\n\t +--------------------------*/\n\n\t/**\n\t * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,\n\t * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)\n\t */\n\n\t/**\n\t * (Changes API) : takes all the changes stored in each\n\t * collection and creates a single array for the entire database. If an array of names\n\t * of collections is passed then only the included collections will be tracked.\n\t *\n\t * @param {array=} optional array of collection names. No arg means all collections are processed.\n\t * @returns {array} array of changes\n\t * @see private method createChange() in Collection\n\t * @memberof Loki\n\t */\n\tgenerateChangesNotification(arrayOfCollectionNames) {\n\t\tfunction getCollName(coll) {\n\t\t\treturn coll.name;\n\t\t}\n\t\tvar changes = [],\n\t\t\tselectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);\n\n\t\tthis.collections.forEach(function(coll) {\n\t\t\tif (selectedCollections.indexOf(getCollName(coll)) !== -1) {\n\t\t\t\tchanges = changes.concat(coll.getChanges());\n\t\t\t}\n\t\t});\n\t\treturn changes;\n\t}\n\n\t/**\n\t * (Changes API) - stringify changes for network transmission\n\t * @returns {string} string representation of the changes\n\t * @memberof Loki\n\t */\n\tserializeChanges(collectionNamesArray) {\n\t\treturn JSON.stringify(this.generateChangesNotification(collectionNamesArray));\n\t}\n\n\t/**\n\t * (Changes API) : clears all the changes in all collections.\n\t * @memberof Loki\n\t */\n\tclearChanges() {\n\t\tthis.collections.forEach(function(coll) {\n\t\t\tif (coll.flushChanges) {\n\t\t\t\tcoll.flushChanges();\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Handles loading from file system, local storage, or adapter (indexeddb).\n\t *\n\t * @param {object} options - an object containing inflation options for each collection\n\t * @returns {Promise} a Promise that resolves after the database is loaded\n\t * @memberof Loki\n\t */\n\tloadDatabase(options) {\n\t\tvar self = this;\n\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.loadDatabase(this.filename))\n\t\t\t.then(function loadDatabaseCallback(dbString) {\n\t\t\t\tif (typeof(dbString) === 'string') {\n\t\t\t\t\tself.loadJSON(dbString, options || {});\n\t\t\t\t\tself.emit('load', self);\n\t\t\t\t} else {\n\t\t\t\t\t// if adapter has returned an js object (other than null or error) attempt to load from JSON object\n\t\t\t\t\tif (typeof(dbString) === \"object\" && dbString !== null && !(dbString instanceof Error)) {\n\t\t\t\t\t\tself.loadJSONObject(dbString, options || {});\n\t\t\t\t\t\tself.emit('load', self);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (dbString instanceof Error)\n\t\t\t\t\t\t\tthrow dbString;\n\n\t\t\t\t\t\tthrow new TypeError('The persistence adapter did not load a serialized DB string or object.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\t/**\n\t * Handles saving to file system, local storage, or adapter (indexeddb)\n\t *\n\t * @memberof Loki\n\t * @returns {Promise} a Promise that resolves after the database is persisted\n\t */\n\tsaveDatabase() {\n\t\tvar self = this;\n\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\tvar saved;\n\n\t\t// check if the adapter is requesting (and supports) a 'reference' mode export\n\t\tif (this.persistenceAdapter.mode === \"reference\" && typeof this.persistenceAdapter.exportDatabase === \"function\") {\n\t\t\t// filename may seem redundant but loadDatabase will need to expect this same filename\n\t\t\tsaved = this.persistenceAdapter.exportDatabase(this.filename, this.copy({\n\t\t\t\tremoveNonSerializable: true\n\t\t\t}));\n\t\t}\n\t\t// otherwise just pass the serialized database to adapter\n\t\telse {\n\t\t\tsaved = this.persistenceAdapter.saveDatabase(this.filename, self.serialize());\n\t\t}\n\n\t\treturn Promise.resolve(saved).then(function() {\n\t\t\tself.autosaveClearFlags();\n\t\t\tself.emit(\"save\");\n\t\t});\n\t}\n\n\t// alias\n\tsave() {\n\t\treturn this.saveDatabase();\n\t}\n\n\t/**\n\t * Handles deleting a database from file system, local storage, or adapter (indexeddb)\n\t *\n\t * @returns {Promise} a Promise that resolves after the database is deleted\n\t * @memberof Loki\n\t */\n\tdeleteDatabase() {\n\t\t// the persistenceAdapter should be present if all is ok, but check to be sure.\n\t\tif (this.persistenceAdapter === null) {\n\t\t\treturn Promise.reject(new Error('persistenceAdapter not configured'));\n\t\t}\n\n\t\treturn Promise.resolve(this.persistenceAdapter.deleteDatabase(this.filename));\n\t}\n\n\t/**\n\t * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database\n\t *\n\t * @returns {boolean} - true if database has changed since last autosave, false if not.\n\t */\n\tautosaveDirty() {\n\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\tif (this.collections[idx].dirty) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * autosaveClearFlags - resets dirty flags on all collections.\n\t *    Called from saveDatabase() after db is saved.\n\t *\n\t */\n\tautosaveClearFlags() {\n\t\tfor (var idx = 0; idx < this.collections.length; idx++) {\n\t\t\tthis.collections[idx].dirty = false;\n\t\t}\n\t}\n\n\t/**\n\t * autosaveEnable - begin a javascript interval to periodically save the database.\n\t *\n\t */\n\tautosaveEnable() {\n\t\tif (this.autosaveHandle) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar self = this;\n\t\tvar running = true;\n\n\t\tthis.autosave = true;\n\t\tthis.autosaveHandle = function() {\n\t\t\trunning = false;\n\t\t\tself.autosaveHandle = undefined;\n\t\t};\n\n\t\t(function saveDatabase() {\n\t\t\tsetTimeout(function() {\n\t\t\t\tif (running) {\n\t\t\t\t\tself.saveDatabase().then(saveDatabase, saveDatabase);\n\t\t\t\t}\n\t\t\t}, self.autosaveInterval);\n\t\t})();\n\t}\n\n\t/**\n\t * autosaveDisable - stop the autosave interval timer.\n\t *\n\t */\n\tautosaveDisable() {\n\t\tthis.autosave = false;\n\n\t\tif (this.autosaveHandle) {\n\t\t\tthis.autosaveHandle();\n\t\t}\n\t}\n}\n\nLoki.Plugins = {};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/loki.js\n// module id = 5\n// module chunks = 0","import {clone} from './clone';\nimport {Collection} from './collection';\nimport {Utils} from './utils';\nimport {ltHelper, gtHelper} from './helper';\n\n/*\n 'Utils' is not defined                 no-undef\t(resolveTransformParams)\n 'sortHelper' is not defined            no-undef\n 'compoundeval' is not defined          no-undef\n 'indexedOpsList' is not defined        no-undef\n 'LokiOps' is not defined               no-undef\n 'dotSubScan' is not defined            no-undef\n 'clone' is not defined                 no-undef\n\n\n */\n\nfunction containsCheckFn(a) {\n\tif (typeof a === 'string' || Array.isArray(a)) {\n\t\treturn function(b) {\n\t\t\treturn a.indexOf(b) !== -1;\n\t\t};\n\t} else if (typeof a === 'object' && a !== null) {\n\t\treturn function(b) {\n\t\t\treturn hasOwnProperty.call(a, b);\n\t\t};\n\t}\n\treturn null;\n}\n\nfunction doQueryOp(val, op) {\n\tfor (var p in op) {\n\t\tif (hasOwnProperty.call(op, p)) {\n\t\t\treturn LokiOps[p](val, op[p]);\n\t\t}\n\t}\n\treturn false;\n}\n\n\nexport var LokiOps = {\n\t// comparison operators\n\t// a is the value in the collection\n\t// b is the query value\n\t$eq: function(a, b) {\n\t\treturn a === b;\n\t},\n\n\t// abstract/loose equality\n\t$aeq: function(a, b) {\n\t\treturn a == b;\n\t},\n\n\t$ne: function(a, b) {\n\t\t// ecma 5 safe test for NaN\n\t\tif (b !== b) {\n\t\t\t// ecma 5 test value is not NaN\n\t\t\treturn (a === a);\n\t\t}\n\n\t\treturn a !== b;\n\t},\n\n\t$dteq: function(a, b) {\n\t\tif (ltHelper(a, b, false)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !gtHelper(a, b, false);\n\t},\n\n\t$gt: function(a, b) {\n\t\treturn gtHelper(a, b, false);\n\t},\n\n\t$gte: function(a, b) {\n\t\treturn gtHelper(a, b, true);\n\t},\n\n\t$lt: function(a, b) {\n\t\treturn ltHelper(a, b, false);\n\t},\n\n\t$lte: function(a, b) {\n\t\treturn ltHelper(a, b, true);\n\t},\n\n\t// ex : coll.find({'orderCount': {$between: [10, 50]}});\n\t$between: function(a, vals) {\n\t\tif (a === undefined || a === null) return false;\n\t\treturn (gtHelper(a, vals[0], true) && ltHelper(a, vals[1], true));\n\t},\n\n\t$in: function(a, b) {\n\t\treturn b.indexOf(a) !== -1;\n\t},\n\n\t$nin: function(a, b) {\n\t\treturn b.indexOf(a) === -1;\n\t},\n\n\t$keyin: function(a, b) {\n\t\treturn a in b;\n\t},\n\n\t$nkeyin: function(a, b) {\n\t\treturn !(a in b);\n\t},\n\n\t$definedin: function(a, b) {\n\t\treturn b[a] !== undefined;\n\t},\n\n\t$undefinedin: function(a, b) {\n\t\treturn b[a] === undefined;\n\t},\n\n\t$regex: function(a, b) {\n\t\treturn b.test(a);\n\t},\n\n\t$containsString: function(a, b) {\n\t\treturn (typeof a === 'string') && (a.indexOf(b) !== -1);\n\t},\n\n\t$containsNone: function(a, b) {\n\t\treturn !LokiOps.$containsAny(a, b);\n\t},\n\n\t$containsAny: function(a, b) {\n\t\tvar checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.some(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$contains: function(a, b) {\n\t\tvar checkFn = containsCheckFn(a);\n\t\tif (checkFn !== null) {\n\t\t\treturn (Array.isArray(b)) ? (b.every(checkFn)) : (checkFn(b));\n\t\t}\n\t\treturn false;\n\t},\n\n\t$type: function(a, b) {\n\t\tvar type = typeof a;\n\t\tif (type === 'object') {\n\t\t\tif (Array.isArray(a)) {\n\t\t\t\ttype = 'array';\n\t\t\t} else if (a instanceof Date) {\n\t\t\t\ttype = 'date';\n\t\t\t}\n\t\t}\n\t\treturn (typeof b !== 'object') ? (type === b) : doQueryOp(type, b);\n\t},\n\n\t$size: function(a, b) {\n\t\tif (Array.isArray(a)) {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$len: function(a, b) {\n\t\tif (typeof a === 'string') {\n\t\t\treturn (typeof b !== 'object') ? (a.length === b) : doQueryOp(a.length, b);\n\t\t}\n\t\treturn false;\n\t},\n\n\t$where: function(a, b) {\n\t\treturn b(a) === true;\n\t},\n\n\t// field-level logical operators\n\t// a is the value in the collection\n\t// b is the nested query operation (for '$not')\n\t//   or an array of nested query operations (for '$and' and '$or')\n\t$not: function(a, b) {\n\t\treturn !doQueryOp(a, b);\n\t},\n\n\t$and: function(a, b) {\n\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (!doQueryOp(a, b[idx])) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t},\n\n\t$or: function(a, b) {\n\t\tfor (var idx = 0, len = b.length; idx < len; idx += 1) {\n\t\t\tif (doQueryOp(a, b[idx])) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n};\n\n// making indexing opt-in... our range function knows how to deal with these ops :\nvar indexedOpsList = ['$eq', '$aeq', '$dteq', '$gt', '$gte', '$lt', '$lte', '$in', '$between'];\n\n\nfunction sortHelper(prop1, prop2, desc) {\n\tif (prop1 === prop2) {\n\t\treturn 0;\n\t}\n\n\tif (ltHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (1) : (-1);\n\t}\n\n\tif (gtHelper(prop1, prop2, false)) {\n\t\treturn (desc) ? (-1) : (1);\n\t}\n\n\t// not lt, not gt so implied equality-- date compatible\n\treturn 0;\n}\n\n/**\n * compoundeval() - helper function for compoundsort(), performing individual object comparisons\n *\n * @param {array} properties - array of property names, in order, by which to evaluate sort order\n * @param {object} obj1 - first object to compare\n * @param {object} obj2 - second object to compare\n * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first\n */\nfunction compoundeval(properties, obj1, obj2) {\n\tvar res = 0;\n\tvar prop, field;\n\tfor (var i = 0, len = properties.length; i < len; i++) {\n\t\tprop = properties[i];\n\t\tfield = prop[0];\n\t\tres = sortHelper(obj1[field], obj2[field], prop[1]);\n\t\tif (res !== 0) {\n\t\t\treturn res;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n/**\n * dotSubScan - helper function used for dot notation queries.\n *\n * @param {object} root - object to traverse\n * @param {array} paths - array of properties to drill into\n * @param {function} fun - evaluation function to test with\n * @param {any} value - comparative value to also pass to (compare) fun\n * @param {number} poffset - index of the item in 'paths' to start the sub-scan from\n */\nfunction dotSubScan(root, paths, fun, value, poffset) {\n\tvar pathOffset = poffset || 0;\n\tvar path = paths[pathOffset];\n\tif (root === undefined || root === null || !hasOwnProperty.call(root, path)) {\n\t\treturn false;\n\t}\n\n\tvar valueFound = false;\n\tvar element = root[path];\n\tif (pathOffset + 1 >= paths.length) {\n\t\t// if we have already expanded out the dot notation,\n\t\t// then just evaluate the test function and value on the element\n\t\tvalueFound = fun(element, value);\n\t} else if (Array.isArray(element)) {\n\t\tfor (var index = 0, len = element.length; index < len; index += 1) {\n\t\t\tvalueFound = dotSubScan(element[index], paths, fun, value, pathOffset + 1);\n\t\t\tif (valueFound === true) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tvalueFound = dotSubScan(element, paths, fun, value, pathOffset + 1);\n\t}\n\n\treturn valueFound;\n}\n\n/**\n * Resultset class allowing chainable queries.  Intended to be instanced internally.\n *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.\n *\n * @example\n *    mycollection.chain()\n *      .find({ 'doors' : 4 })\n *      .where(function(obj) { return obj.name === 'Toyota' })\n *      .data();\n *\n * @constructor Resultset\n * @param {Collection} collection - The collection which this Resultset will query against.\n * @param {Object=} options - Object containing one or more options.\n * @param {string} options.queryObj - Optional mongo-style query object to initialize resultset with.\n * @param {function} options.queryFunc - Optional javascript filter function to initialize resultset with.\n * @param {bool} options.firstOnly - Optional boolean used by collection.findOne().\n */\nexport class Resultset {\n\n\tconstructor(collection, options) {\n\t\toptions = options || {};\n\n\t\toptions.queryObj = options.queryObj || null;\n\t\toptions.queryFunc = options.queryFunc || null;\n\t\toptions.firstOnly = options.firstOnly || false;\n\n\t\t// retain reference to collection we are querying against\n\t\tthis.collection = collection;\n\n\t\t// if chain() instantiates with null queryObj and queryFunc, so we will keep flag for later\n\t\tthis.searchIsChained = (!options.queryObj && !options.queryFunc);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\t// if user supplied initial queryObj or queryFunc, apply it\n\t\tif (typeof(options.queryObj) !== \"undefined\" && options.queryObj !== null) {\n\t\t\treturn this.find(options.queryObj, options.firstOnly);\n\t\t}\n\t\tif (typeof(options.queryFunc) !== \"undefined\" && options.queryFunc !== null) {\n\t\t\treturn this.where(options.queryFunc);\n\t\t}\n\n\t\t// otherwise return unfiltered Resultset for future filtering\n\t\treturn this;\n\t}\n\n\t/**\n\t * reset() - Reset the resultset to its initial state.\n\t *\n\t * @returns {Resultset} Reference to this resultset, for future chain operations.\n\t */\n\treset() {\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tthis.filteredrows = [];\n\t\t}\n\t\tthis.filterInitialized = false;\n\t\treturn this;\n\t}\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tvar copy = this.copy();\n\t\tcopy.collection = null;\n\t\treturn copy;\n\t}\n\n\t/**\n\t * Allows you to limit the number of documents passed to next chain operation.\n\t *    A resultset copy() is made to avoid altering original resultset.\n\t *\n\t * @param {int} qty - The number of documents to return.\n\t * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\tlimit(qty) {\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar rscopy = new Resultset(this.collection);\n\t\trscopy.filteredrows = this.filteredrows.slice(0, qty);\n\t\trscopy.filterInitialized = true;\n\t\treturn rscopy;\n\t}\n\n\t/**\n\t * Used for skipping 'pos' number of documents in the resultset.\n\t *\n\t * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.\n\t * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.\n\t * @memberof Resultset\n\t */\n\toffset(pos) {\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar rscopy = new Resultset(this.collection);\n\t\trscopy.filteredrows = this.filteredrows.slice(pos);\n\t\trscopy.filterInitialized = true;\n\t\treturn rscopy;\n\t}\n\n\t/**\n\t * copy() - To support reuse of resultset in branched query situations.\n\t *\n\t * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.\n\t * @memberof Resultset\n\t */\n\tcopy() {\n\t\tvar result = new Resultset(this.collection);\n\n\t\tif (this.filteredrows.length > 0) {\n\t\t\tresult.filteredrows = this.filteredrows.slice();\n\t\t}\n\t\tresult.filterInitialized = this.filterInitialized;\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Alias of copy()\n\t * @memberof Resultset\n\t */\n\tbranch() {\n\t\treturn this.copy();\n\t}\n\n\t/**\n\t * transform() - executes a named collection transform or raw array of transform steps against the resultset.\n\t *\n\t * @param transform {(string|array)} - name of collection transform or raw transform array\n\t * @param parameters {object=} - (Optional) object property hash of parameters, if the transform requires them.\n\t * @returns {Resultset} either (this) resultset or a clone of of this resultset (depending on steps)\n\t * @memberof Resultset\n\t */\n\ttransform(transform, parameters) {\n\t\tvar idx,\n\t\t\tstep,\n\t\t\trs = this;\n\n\t\t// if transform is name, then do lookup first\n\t\tif (typeof transform === 'string') {\n\t\t\tif (this.collection.transforms.hasOwnProperty(transform)) {\n\t\t\t\ttransform = this.collection.transforms[transform];\n\t\t\t}\n\t\t}\n\n\t\t// either they passed in raw transform array or we looked it up, so process\n\t\tif (typeof transform !== 'object' || !Array.isArray(transform)) {\n\t\t\tthrow new Error(\"Invalid transform\");\n\t\t}\n\n\t\tif (typeof parameters !== 'undefined') {\n\t\t\ttransform = Utils.resolveTransformParams(transform, parameters);\n\t\t}\n\n\t\tfor (idx = 0; idx < transform.length; idx++) {\n\t\t\tstep = transform[idx];\n\n\t\t\tswitch (step.type) {\n\t\t\t\tcase \"find\":\n\t\t\t\t\trs.find(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"where\":\n\t\t\t\t\trs.where(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"simplesort\":\n\t\t\t\t\trs.simplesort(step.property, step.desc);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"compoundsort\":\n\t\t\t\t\trs.compoundsort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sort\":\n\t\t\t\t\trs.sort(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"limit\":\n\t\t\t\t\trs = rs.limit(step.value);\n\t\t\t\t\tbreak; // limit makes copy so update reference\n\t\t\t\tcase \"offset\":\n\t\t\t\t\trs = rs.offset(step.value);\n\t\t\t\t\tbreak; // offset makes copy so update reference\n\t\t\t\tcase \"map\":\n\t\t\t\t\trs = rs.map(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"eqJoin\":\n\t\t\t\t\trs = rs.eqJoin(step.joinData, step.leftJoinKey, step.rightJoinKey, step.mapFun);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases break chain by returning array data so make any of these last in transform steps\n\t\t\t\tcase \"mapReduce\":\n\t\t\t\t\trs = rs.mapReduce(step.mapFunction, step.reduceFunction);\n\t\t\t\t\tbreak;\n\t\t\t\t// following cases update documents in current filtered resultset (use carefully)\n\t\t\t\tcase \"update\":\n\t\t\t\t\trs.update(step.value);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"remove\":\n\t\t\t\t\trs.remove();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn rs;\n\t}\n\n\t/**\n\t * Instances a new anonymous collection with the documents contained in the current resultset.\n\t *\n\t * @param {object} collectionOptions - Options to pass to new anonymous collection construction.\n\t * @returns {Collection} A reference to an anonymous collection initialized with resultset data().\n\t * @memberof Resultset\n\t */\n\tinstance(collectionOptions) {\n\t\tvar docs = this.data();\n\t\tvar idx,\n\t\t\tdoc;\n\n\t\tcollectionOptions = collectionOptions || {};\n\n\t\tvar instanceCollection = new Collection(collectionOptions);\n\n\t\tfor (idx = 0; idx < docs.length; idx++) {\n\t\t\tif (this.collection.cloneObjects) {\n\t\t\t\tdoc = docs[idx];\n\t\t\t} else {\n\t\t\t\tdoc = clone(docs[idx], this.collection.cloneMethod);\n\t\t\t}\n\n\t\t\tdelete doc.$loki;\n\t\t\tdelete doc.meta;\n\n\t\t\tinstanceCollection.insert(doc);\n\t\t}\n\n\t\treturn instanceCollection;\n\t}\n\n\t/**\n\t * User supplied compare function is provided two documents to compare. (chainable)\n\t * @example\n\t *    rslt.sort(function(obj1, obj2) {\n\t *      if (obj1.name === obj2.name) return 0;\n\t *      if (obj1.name > obj2.name) return 1;\n\t *      if (obj1.name < obj2.name) return -1;\n\t *    });\n\t *\n\t * @param {function} comparefun - A javascript compare function used for sorting.\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsort(comparefun) {\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(userComparer, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn userComparer(data[a], data[b]);\n\t\t\t\t};\n\t\t\t})(comparefun, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Simpler, loose evaluation for user to sort based on a property name. (chainable).\n\t *    Sorting based on the same lt/gt helper functions used for binary indices.\n\t *\n\t * @param {string} propname - name of property to sort by.\n\t * @param {bool=} isdesc - (Optional) If true, the property will be sorted in descending order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tsimplesort(propname, isdesc) {\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\t// if we have a binary index and no other filters applied, we can use that instead of sorting (again)\n\t\t\tif (this.collection.binaryIndices.hasOwnProperty(propname)) {\n\t\t\t\t// make sure index is up-to-date\n\t\t\t\tthis.collection.ensureIndex(propname);\n\t\t\t\t// copy index values into filteredrows\n\t\t\t\tthis.filteredrows = this.collection.binaryIndices[propname].values.slice(0);\n\t\t\t\t// we are done, return this (resultset) for further chain ops\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\t// otherwise initialize array for sort below\n\t\t\telse {\n\t\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t\t}\n\t\t}\n\n\t\tif (typeof(isdesc) === 'undefined') {\n\t\t\tisdesc = false;\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(prop, desc, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn sortHelper(data[a][prop], data[b][prop], desc);\n\t\t\t\t};\n\t\t\t})(propname, isdesc, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * rs.compoundsort(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * rs.compoundsort(['age', ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.\n\t * @memberof Resultset\n\t */\n\tcompoundsort(properties) {\n\t\tif (properties.length === 0) {\n\t\t\tthrow new Error(\"Invalid call to compoundsort, need at least one property\");\n\t\t}\n\n\t\tvar prop;\n\t\tif (properties.length === 1) {\n\t\t\tprop = properties[0];\n\t\t\tif (Array.isArray(prop)) {\n\t\t\t\treturn this.simplesort(prop[0], prop[1]);\n\t\t\t}\n\t\t\treturn this.simplesort(prop, false);\n\t\t}\n\n\t\t// unify the structure of 'properties' to avoid checking it repeatedly while sorting\n\t\tfor (var i = 0, len = properties.length; i < len; i += 1) {\n\t\t\tprop = properties[i];\n\t\t\tif (!Array.isArray(prop)) {\n\t\t\t\tproperties[i] = [prop, false];\n\t\t\t}\n\t\t}\n\n\t\t// if this is chained resultset with no filters applied, just we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar wrappedComparer =\n\t\t\t(function(props, data) {\n\t\t\t\treturn function(a, b) {\n\t\t\t\t\treturn compoundeval(props, data[a], data[b]);\n\t\t\t\t};\n\t\t\t})(properties, this.collection.data);\n\n\t\tthis.filteredrows.sort(wrappedComparer);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * findOr() - oversee the operation of OR'ed query expressions.\n\t *    OR'ed expression evaluation runs each expression individually against the full collection,\n\t *    and finally does a set OR on each expression's results.\n\t *    Each evaluation can utilize a binary index to prevent multiple linear array scans.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindOr(expressionArray) {\n\t\tvar fr = null,\n\t\t\tfri = 0,\n\t\t\tfrlen = 0,\n\t\t\tdocset = [],\n\t\t\tidxset = [],\n\t\t\tidx = 0,\n\t\t\torigCount = this.count();\n\n\t\t// If filter is already initialized, then we query against only those items already in filter.\n\t\t// This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.\n\t\tfor (var ei = 0, elen = expressionArray.length; ei < elen; ei++) {\n\t\t\t// we need to branch existing query to run each filter separately and combine results\n\t\t\tfr = this.branch().find(expressionArray[ei]).filteredrows;\n\t\t\tfrlen = fr.length;\n\t\t\t// if the find operation did not reduce the initial set, then the initial set is the actual result\n\t\t\tif (frlen === origCount) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\t// add any document 'hits'\n\t\t\tfor (fri = 0; fri < frlen; fri++) {\n\t\t\t\tidx = fr[fri];\n\t\t\t\tif (idxset[idx] === undefined) {\n\t\t\t\t\tidxset[idx] = true;\n\t\t\t\t\tdocset.push(idx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.filteredrows = docset;\n\t\tthis.filterInitialized = true;\n\n\t\treturn this;\n\t}\n\t$or() {\n\t\treturn this.findOr(...arguments);\n\t}\n\n\t/**\n\t * findAnd() - oversee the operation of AND'ed query expressions.\n\t *    AND'ed expression evaluation runs each expression progressively against the full collection,\n\t *    internally utilizing existing chained resultset functionality.\n\t *    Only the first filter can utilize a binary index.\n\t *\n\t * @param {array} expressionArray - array of expressions\n\t * @returns {Resultset} this resultset for further chain ops.\n\t */\n\tfindAnd(expressionArray) {\n\t\t// we have already implementing method chaining in this (our Resultset class)\n\t\t// so lets just progressively apply user supplied and filters\n\t\tfor (var i = 0, len = expressionArray.length; i < len; i++) {\n\t\t\tif (this.count() === 0) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tthis.find(expressionArray[i]);\n\t\t}\n\t\treturn this;\n\t}\n\n\t$and() {\n\t\treturn this.findAnd(...arguments);\n\t}\n\n\t/**\n\t * Used for querying via a mongo-style query object.\n\t *\n\t * @param {object} query - A mongo-style query object used for filtering current results.\n\t * @param {boolean=} firstOnly - (Optional) Used by collection.findOne()\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tfind(query, firstOnly) {\n\t\tif (this.collection.data.length === 0) {\n\t\t\tif (this.searchIsChained) {\n\t\t\t\tthis.filteredrows = [];\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\treturn [];\n\t\t}\n\n\t\tvar queryObject = query || 'getAll',\n\t\t\tp,\n\t\t\tproperty,\n\t\t\tqueryObjectOp,\n\t\t\toperator,\n\t\t\tvalue,\n\t\t\tkey,\n\t\t\tsearchByIndex = false,\n\t\t\tresult = [],\n\t\t\tindex = null;\n\n\t\t// if this was note invoked via findOne()\n\t\tfirstOnly = firstOnly || false;\n\n\t\tif (typeof queryObject === 'object') {\n\t\t\tfor (p in queryObject) {\n\t\t\t\tif (hasOwnProperty.call(queryObject, p)) {\n\t\t\t\t\tproperty = p;\n\t\t\t\t\tqueryObjectOp = queryObject[p];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// apply no filters if they want all\n\t\tif (!property || queryObject === 'getAll') {\n\t\t\t// coll.find(), coll.findOne(), coll.chain().find().data() all path here\n\n\t\t\tif (firstOnly) {\n\t\t\t\treturn (this.collection.data.length > 0) ? this.collection.data[0] : null;\n\t\t\t}\n\n\t\t\treturn (this.searchIsChained) ? (this) : (this.collection.data.slice());\n\t\t}\n\n\t\t// injecting $and and $or expression tree evaluation here.\n\t\tif (property === '$and' || property === '$or') {\n\t\t\tif (this.searchIsChained) {\n\t\t\t\tthis[property](queryObjectOp);\n\n\t\t\t\t// for chained find with firstonly,\n\t\t\t\tif (firstOnly && this.filteredrows.length > 1) {\n\t\t\t\t\tthis.filteredrows = this.filteredrows.slice(0, 1);\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\t// our $and operation internally chains filters\n\t\t\t\tresult = this.collection.chain()[property](queryObjectOp).data();\n\n\t\t\t\t// if this was coll.findOne() return first object or empty array if null\n\t\t\t\t// since this is invoked from a constructor we can't return null, so we will\n\t\t\t\t// make null in coll.findOne();\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\treturn (result.length === 0) ? ([]) : (result[0]);\n\t\t\t\t}\n\n\t\t\t\t// not first only return all results\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\t// see if query object is in shorthand mode (assuming eq operator)\n\t\tif (queryObjectOp === null || (typeof queryObjectOp !== 'object' || queryObjectOp instanceof Date)) {\n\t\t\toperator = '$eq';\n\t\t\tvalue = queryObjectOp;\n\t\t} else if (typeof queryObjectOp === 'object') {\n\t\t\tfor (key in queryObjectOp) {\n\t\t\t\tif (hasOwnProperty.call(queryObjectOp, key)) {\n\t\t\t\t\toperator = key;\n\t\t\t\t\tvalue = queryObjectOp[key];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Do not know what you want to do.');\n\t\t}\n\n\t\t// for regex ops, precompile\n\t\tif (operator === '$regex') {\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\tvalue = new RegExp(value[0], value[1]);\n\t\t\t} else if (!(value instanceof RegExp)) {\n\t\t\t\tvalue = new RegExp(value);\n\t\t\t}\n\t\t}\n\n\t\tif (query.query) {\n\t\t\tlet res = this.collection._fullTextSearch.search(query);\n\t\t\tlet docIds = Object.keys(res);\n\t\t\tlet results = [];\n\t\t\tfor (let i = 0; i < docIds.length; i++) {\n\t\t\t\tlet docId = parseInt(docIds[i]);\n\t\t\t\tfor (let j = 0; j < this.collection.data.length; j++) {\n\t\t\t\t\tif (this.collection.data[j].$loki === docId) {\n\t\t\t\t\t\tresults.push(this.collection.data[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn results;\n\t\t}\n\n\t\t// if user is deep querying the object such as find('name.first': 'odin')\n\t\tvar usingDotNotation = (property.indexOf('.') !== -1);\n\n\t\t// if an index exists for the property being queried against, use it\n\t\t// for now only enabling for non-chained query (who's set of docs matches index)\n\t\t// or chained queries where it is the first filter applied and prop is indexed\n\t\tvar doIndexCheck = !usingDotNotation &&\n\t\t\t(!this.searchIsChained || !this.filterInitialized);\n\n\t\tif (doIndexCheck && this.collection.binaryIndices[property] &&\n\t\t\tindexedOpsList.indexOf(operator) !== -1) {\n\t\t\t// this is where our lazy index rebuilding will take place\n\t\t\t// basically we will leave all indexes dirty until we need them\n\t\t\t// so here we will rebuild only the index tied to this property\n\t\t\t// ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param\n\t\t\tif (this.collection.adaptiveBinaryIndices !== true) {\n\t\t\t\tthis.collection.ensureIndex(property);\n\t\t\t}\n\n\t\t\tsearchByIndex = true;\n\t\t\tindex = this.collection.binaryIndices[property];\n\t\t}\n\n\t\t// the comparison function\n\t\tvar fun = LokiOps[operator];\n\n\t\t// \"shortcut\" for collection data\n\t\tvar t = this.collection.data;\n\t\t// filter data length\n\t\tvar i = 0,\n\t\t\tlen = 0;\n\n\t\t// Query executed differently depending on :\n\t\t//    - whether it is chained or not\n\t\t//    - whether the property being queried has an index defined\n\t\t//    - if chained, we handle first pass differently for initial filteredrows[] population\n\t\t//\n\t\t// For performance reasons, each case has its own if block to minimize in-loop calculations\n\n\t\t// If not a chained query, bypass filteredrows and work directly against data\n\t\tif (!this.searchIsChained) {\n\t\t\tif (!searchByIndex) {\n\t\t\t\ti = t.length;\n\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\t\treturn (t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\t\treturn (t[i]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\t// if using dot notation then treat property as keypath such as 'name.first'.\n\t\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\tresult.push(t[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// searching by binary index via calculateRange() utility method\n\t\t\t\tvar seg = this.collection.calculateRange(operator, property, value);\n\n\t\t\t\t// not chained so this 'find' was designated in Resultset constructor\n\t\t\t\t// so return object itself\n\t\t\t\tif (firstOnly) {\n\t\t\t\t\tif (seg[1] !== -1) {\n\t\t\t\t\t\treturn t[index.values[seg[0]]];\n\t\t\t\t\t}\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\tfor (i = seg[0]; i <= seg[1]; i++) {\n\t\t\t\t\t\tresult.push(t[index.values[i]]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, len = seg.length; i < len; i++) {\n\t\t\t\t\t\tresult.push(t[index.values[seg[i]]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// not a chained query so return result as data[]\n\t\t\treturn result;\n\t\t}\n\n\n\t\t// Otherwise this is a chained query\n\t\t// Chained queries now preserve results ordering at expense on slightly reduced unindexed performance\n\n\t\tvar filter, rowIdx = 0;\n\n\t\t// If the filteredrows[] is already initialized, use it\n\t\tif (this.filterInitialized) {\n\t\t\tfilter = this.filteredrows;\n\t\t\tlen = filter.length;\n\n\t\t\t// currently supporting dot notation for non-indexed conditions only\n\t\t\tif (usingDotNotation) {\n\t\t\t\tproperty = property.split('.');\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (dotSubScan(t[rowIdx], property, fun, value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\trowIdx = filter[i];\n\t\t\t\t\tif (fun(t[rowIdx][property], value)) {\n\t\t\t\t\t\tresult.push(rowIdx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// first chained query so work against data[] but put results in filteredrows\n\t\telse {\n\t\t\t// if not searching by index\n\t\t\tif (!searchByIndex) {\n\t\t\t\tlen = t.length;\n\n\t\t\t\tif (usingDotNotation) {\n\t\t\t\t\tproperty = property.split('.');\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (dotSubScan(t[i], property, fun, value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tif (fun(t[i][property], value)) {\n\t\t\t\t\t\t\tresult.push(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// search by index\n\t\t\t\tvar segm = this.collection.calculateRange(operator, property, value);\n\n\t\t\t\tif (operator !== '$in') {\n\t\t\t\t\tfor (i = segm[0]; i <= segm[1]; i++) {\n\t\t\t\t\t\tresult.push(index.values[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (i = 0, len = segm.length; i < len; i++) {\n\t\t\t\t\t\tresult.push(index.values[segm[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.filterInitialized = true; // next time work against filteredrows[]\n\t\t}\n\n\t\tthis.filteredrows = result;\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * where() - Used for filtering via a javascript filter function.\n\t *\n\t * @param {function} fun - A javascript function used for filtering current results by.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\twhere(fun) {\n\t\tvar viewFunction,\n\t\t\tresult = [];\n\n\t\tif ('function' === typeof fun) {\n\t\t\tviewFunction = fun;\n\t\t} else {\n\t\t\tthrow new TypeError('Argument is not a stored view or a function');\n\t\t}\n\t\ttry {\n\t\t\t// if not a chained query then run directly against data[] and return object []\n\t\t\tif (!this.searchIsChained) {\n\t\t\t\tvar i = this.collection.data.length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (viewFunction(this.collection.data[i]) === true) {\n\t\t\t\t\t\tresult.push(this.collection.data[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// not a chained query so returning result as data[]\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\t// else chained query, so run against filteredrows\n\t\t\telse {\n\t\t\t\t// If the filteredrows[] is already initialized, use it\n\t\t\t\tif (this.filterInitialized) {\n\t\t\t\t\tvar j = this.filteredrows.length;\n\n\t\t\t\t\twhile (j--) {\n\t\t\t\t\t\tif (viewFunction(this.collection.data[this.filteredrows[j]]) === true) {\n\t\t\t\t\t\t\tresult.push(this.filteredrows[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filteredrows = result;\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t\t// otherwise this is initial chained op, work against data, push into filteredrows[]\n\t\t\t\telse {\n\t\t\t\t\tvar k = this.collection.data.length;\n\n\t\t\t\t\twhile (k--) {\n\t\t\t\t\t\tif (viewFunction(this.collection.data[k]) === true) {\n\t\t\t\t\t\t\tresult.push(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filteredrows = result;\n\t\t\t\t\tthis.filterInitialized = true;\n\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * count() - returns the number of documents in the resultset.\n\t *\n\t * @returns {number} The number of documents in the resultset.\n\t * @memberof Resultset\n\t */\n\tcount() {\n\t\tif (this.searchIsChained && this.filterInitialized) {\n\t\t\treturn this.filteredrows.length;\n\t\t}\n\t\treturn this.collection.count();\n\t}\n\n\t/**\n\t * Terminates the chain and returns array of filtered documents\n\t *\n\t * @param {object=} options - allows specifying 'forceClones' and 'forceCloneMethod' options.\n\t * @param {boolean} options.forceClones - Allows forcing the return of cloned objects even when\n\t *        the collection is not configured for clone object.\n\t * @param {string} options.forceCloneMethod - Allows overriding the default or collection specified cloning method.\n\t *        Possible values include 'parse-stringify', 'jquery-extend-deep', and 'shallow'\n\t *\n\t * @returns {array} Array of documents in the resultset\n\t * @memberof Resultset\n\t */\n\tdata(options) {\n\t\tvar result = [],\n\t\t\tdata = this.collection.data,\n\t\t\tlen,\n\t\t\ti,\n\t\t\tmethod;\n\n\t\toptions = options || {};\n\n\t\t// if this is chained resultset with no filters applied, just return collection.data\n\t\tif (this.searchIsChained && !this.filterInitialized) {\n\t\t\tif (this.filteredrows.length === 0) {\n\t\t\t\t// determine whether we need to clone objects or not\n\t\t\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\t\t\tlen = data.length;\n\t\t\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\n\t\t\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\t\t\tresult.push(clone(data[i], method));\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t// otherwise we are not cloning so return sliced array with same object references\n\t\t\t\telse {\n\t\t\t\t\treturn data.slice();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// filteredrows must have been set manually, so use it\n\t\t\t\tthis.filterInitialized = true;\n\t\t\t}\n\t\t}\n\n\t\tvar fr = this.filteredrows;\n\t\tlen = fr.length;\n\n\t\tif (this.collection.cloneObjects || options.forceClones) {\n\t\t\tmethod = options.forceCloneMethod || this.collection.cloneMethod;\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tresult.push(clone(data[fr[i]], method));\n\t\t\t}\n\t\t} else {\n\t\t\tfor (i = 0; i < len; i++) {\n\t\t\t\tresult.push(data[fr[i]]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Used to run an update operation on all documents currently in the resultset.\n\t *\n\t * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.\n\t * @returns {Resultset} this resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tupdate(updateFunction) {\n\n\t\tif (typeof(updateFunction) !== \"function\") {\n\t\t\tthrow new TypeError('Argument is not a function');\n\t\t}\n\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tvar len = this.filteredrows.length,\n\t\t\trcd = this.collection.data;\n\n\t\tfor (var idx = 0; idx < len; idx++) {\n\t\t\t// pass in each document object currently in resultset to user supplied updateFunction\n\t\t\tupdateFunction(rcd[this.filteredrows[idx]]);\n\n\t\t\t// notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate\n\t\t\tthis.collection.update(rcd[this.filteredrows[idx]]);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes all document objects which are currently in resultset from collection (as well as resultset)\n\t *\n\t * @returns {Resultset} this (empty) resultset for further chain ops.\n\t * @memberof Resultset\n\t */\n\tremove() {\n\n\t\t// if this is chained resultset with no filters applied, we need to populate filteredrows first\n\t\tif (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {\n\t\t\tthis.filteredrows = this.collection.prepareFullDocIndex();\n\t\t}\n\n\t\tthis.collection.remove(this.data());\n\n\t\tthis.filteredrows = [];\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns {value} The output of your reduceFunction\n\t * @memberof Resultset\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties\n\t * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key\n\t * @param {Array} joinData - Data array to join to.\n\t * @param {(string|function)} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on\n\t * @param {(string|function)} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on\n\t * @param {function=} mapFun - (Optional) A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}\n\t * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]\n\t * @memberof Resultset\n\t */\n\teqJoin(joinData, leftJoinKey, rightJoinKey, mapFun) {\n\n\t\tvar leftData = [],\n\t\t\tleftDataLength,\n\t\t\trightData = [],\n\t\t\trightDataLength,\n\t\t\tkey,\n\t\t\tresult = [],\n\t\t\tleftKeyisFunction = typeof leftJoinKey === 'function',\n\t\t\trightKeyisFunction = typeof rightJoinKey === 'function',\n\t\t\tjoinMap = {};\n\n\t\t//get the left data\n\t\tleftData = this.data();\n\t\tleftDataLength = leftData.length;\n\n\t\t//get the right data\n\t\tif (joinData instanceof Resultset) {\n\t\t\trightData = joinData.data();\n\t\t} else if (Array.isArray(joinData)) {\n\t\t\trightData = joinData;\n\t\t} else {\n\t\t\tthrow new TypeError('joinData needs to be an array or result set');\n\t\t}\n\t\trightDataLength = rightData.length;\n\n\t\t//construct a lookup table\n\n\t\tfor (var i = 0; i < rightDataLength; i++) {\n\t\t\tkey = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];\n\t\t\tjoinMap[key] = rightData[i];\n\t\t}\n\n\t\tif (!mapFun) {\n\t\t\tmapFun = function(left, right) {\n\t\t\t\treturn {\n\t\t\t\t\tleft: left,\n\t\t\t\t\tright: right\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\n\t\t//Run map function over each object in the resultset\n\t\tfor (var j = 0; j < leftDataLength; j++) {\n\t\t\tkey = leftKeyisFunction ? leftJoinKey(leftData[j]) : leftData[j][leftJoinKey];\n\t\t\tresult.push(mapFun(leftData[j], joinMap[key] || {}));\n\t\t}\n\n\t\t//return return a new resultset with no filters\n\t\tthis.collection = new Collection('joinData');\n\t\tthis.collection.insert(result);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t}\n\n\tmap(mapFun) {\n\t\tvar data = this.data().map(mapFun);\n\t\t//return return a new resultset with no filters\n\t\tthis.collection = new Collection('mappedData');\n\t\tthis.collection.insert(data);\n\t\tthis.filteredrows = [];\n\t\tthis.filterInitialized = false;\n\n\t\treturn this;\n\t}\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/resultset.js\n// module id = 6\n// module chunks = 0","\n/**\n * A loki persistence adapter which persists using node fs module\n * @constructor LokiFsAdapter\n */\nexport class LokiFsAdapter {\n\n\tconstructor() {\n\t\tthis.fs = undefined; //TODO require('fs');\n\t}\n\n\t/**\n\t * loadDatabase() - Load data from file, will throw an error if the file does not exist\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiFsAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tvar self = this;\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.stat(dbname, function(err, stats) {\n\t\t\t\tif (!err && stats.isFile()) {\n\t\t\t\t\tself.fs.readFile(dbname, {\n\t\t\t\t\t\tencoding: 'utf8'\n\t\t\t\t\t}, function readFileCallback(err, data) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(data);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treject();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * saveDatabase() - save data to file, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiFsAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tvar self = this;\n\t\tvar tmpdbname = dbname + '~';\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.writeFile(tmpdbname, dbstring, function(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tself.fs.rename(tmpdbname, dbname, function(err) {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * deleteDatabase() - delete the database file, will throw an error if the\n\t * file can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiFsAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tvar self = this;\n\n\t\treturn new Promise(function(resolve, reject) {\n\t\t\tself.fs.unlink(dbname, function deleteDatabaseCallback(err) {\n\t\t\t\tif (err) {\n\t\t\t\t\treject(err);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/fs_adapter.js\n// module id = 7\n// module chunks = 0","\nfunction localStorageAvailable() {\n\ttry {\n\t\treturn (window && window.localStorage !== undefined && window.localStorage !== null);\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n/*\n 'localStorageAvailable' is not defined\n */\n\n/**\n * A loki persistence adapter which persists to web browser's local storage object\n * @constructor LokiLocalStorageAdapter\n */\nexport class LokiLocalStorageAdapter {\n\n\t/**\n\t * loadDatabase() - Load data from localstorage\n\t * @param {string} dbname - the name of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\treturn Promise.resolve(localStorage.getItem(dbname));\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n\t/**\n\t * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved\n\t * might want to expand this to avoid dataloss on partial save\n\t * @param {string} dbname - the filename of the database to load\n\t * @returns {Promise} a Promise that resolves after the database was saved\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.setItem(dbname, dbstring);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n\t/**\n\t * deleteDatabase() - delete the database from localstorage, will throw an error if it\n\t * can't be deleted\n\t * @param {string} dbname - the filename of the database to delete\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiLocalStorageAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tif (localStorageAvailable()) {\n\t\t\tlocalStorage.removeItem(dbname);\n\n\t\t\treturn Promise.resolve();\n\t\t}\n\n\t\treturn Promise.reject(new Error('localStorage is not available'));\n\t}\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/local_storage_adapter.js\n// module id = 8\n// module chunks = 0","/*\nLoki IndexedDb Adapter (need to include this script to use it)\n\nConsole Usage can be used for management/diagnostic, here are a few examples :\nadapter.getDatabaseList(); // with no callback passed, this method will log results to console\nadapter.saveDatabase(\"UserDatabase\", JSON.stringify(myDb));\nadapter.loadDatabase(\"UserDatabase\"); // will log the serialized db to console\nadapter.deleteDatabase(\"UserDatabase\");\n*/\n\n/**\n * Loki persistence adapter class for indexedDb.\n *     This class fulfills abstract adapter interface which can be applied to other storage methods.\n *     Utilizes the included LokiCatalog app/key/value database for actual database persistence.\n *     IndexedDb storage is provided per-domain, so we implement app/key/value database to\n *     allow separate contexts for separate apps within a domain.\n *\n * @example\n * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n *\n * @constructor LokiIndexedAdapter\n *\n * @param {string} appname - (Optional) Application name context can be used to distinguish subdomains, \"loki\" by default\n */\nexport class LokiIndexedAdapter {\n\n\tconstructor(appname) {\n\t\tthis.app = \"loki\";\n\n\t\tif (typeof(appname) !== \"undefined\") {\n\t\t\tthis.app = appname;\n\t\t}\n\n\t\t// keep reference to catalog class for base AKV operations\n\t\tthis.catalog = null;\n\n\t\tif (!this.checkAvailability()) {\n\t\t\tthrow new Error(\"indexedDB does not seem to be supported for your environment\");\n\t\t}\n\t}\n\n\t/**\n\t * Used to check if adapter is available\n\t *\n\t * @returns {boolean} true if indexeddb is available, false if not.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tcheckAvailability() {\n\t\tif (typeof indexedDB !== \"undefined\" && indexedDB) return true;\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Retrieves a serialized db string from the catalog.\n\t *\n\t * @example\n\t * // LOAD\n\t * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t * var db = new loki(\"test\", { adapter: idbAdapter });\n\t *   db.loadDatabase(function(result) {\n\t *   console.log(\"done\");\n\t * });\n\t *\n\t * @param {string} dbname - the name of the database to retrieve.\n\t * @returns {Promise} a Promise that resolves after the database was loaded\n\t * @memberof LokiIndexedAdapter\n\t */\n\tloadDatabase(dbname) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tadapter.catalog = new LokiCatalog(function(cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t\tresolve(adapter.loadDatabase(dbname));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// lookup up db string in AKV db\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.catalog.getAppKey(appName, dbname, function(result) {\n\t\t\t\tif (result.id === 0) {\n\t\t\t\t\tresolve();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tresolve(result.val);\n\t\t\t});\n\t\t});\n\t}\n\n\t// alias\n\tloadKey(dbname) {\n\t\treturn this.loadDatabase(dbname);\n\t}\n\n\t/**\n\t * Saves a serialized db to the catalog.\n\t *\n\t * @example\n\t * // SAVE : will save App/Key/Val as \"finance\"/\"test\"/{serializedDb}\n\t * var idbAdapter = new LokiIndexedAdapter(\"finance\");\n\t * var db = new loki(\"test\", { adapter: idbAdapter });\n\t * var coll = db.addCollection(\"testColl\");\n\t * coll.insert({test: \"val\"});\n\t * db.saveDatabase();  // could pass callback if needed for async complete\n\t *\n\t * @param {string} dbname - the name to give the serialized database within the catalog.\n\t * @param {string} dbstring - the serialized db string to save.\n\t * @returns {Promise} a Promise that resolves after the database was persisted\n\t * @memberof LokiIndexedAdapter\n\t */\n\tsaveDatabase(dbname, dbstring) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\tvar resolve, reject;\n\t\tvar result = new Promise(function(res, rej) {\n\t\t\tresolve = res;\n\t\t\treject = rej;\n\t\t});\n\n\t\tfunction saveCallback(result) {\n\t\t\tif (result && result.success === true) {\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\treject(new Error(\"Error saving database\"));\n\t\t\t}\n\t\t}\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t// now that catalog has been initialized, set (add/update) the AKV entry\n\t\t\t\tcat.setAppKey(appName, dbname, dbstring, saveCallback);\n\t\t\t});\n\n\t\t\treturn result;\n\t\t}\n\n\t\t// set (add/update) entry to AKV database\n\t\tthis.catalog.setAppKey(appName, dbname, dbstring, saveCallback);\n\n\t\treturn result;\n\t}\n\n\t// alias\n\tsaveKey(dbname, dbstring) {\n\t\treturn this.saveDatabase(dbname, dbstring);\n\t}\n\n\t/**\n\t * Deletes a serialized db from the catalog.\n\t *\n\t * @example\n\t * // DELETE DATABASE\n\t * // delete \"finance\"/\"test\" value from catalog\n\t * idbAdapter.deleteDatabase(\"test\", function {\n\t *   // database deleted\n\t * });\n\t *\n\t * @param {string} dbname - the name of the database to delete from the catalog.\n\t * @returns {Promise} a Promise that resolves after the database was deleted\n\t * @memberof LokiIndexedAdapter\n\t */\n\tdeleteDatabase(dbname) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference and pass callback ahead\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\treturn new Promise(function(resolve) {\n\t\t\t\tadapter.catalog = new LokiCatalog(function(cat) {\n\t\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\t\tresolve(adapter.deleteDatabase(dbname));\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\n\t\t// catalog was already initialized, so just lookup object and delete by id\n\t\treturn new Promise(function(resolve) {\n\t\t\tthis.catalog.getAppKey(appName, dbname, function(result) {\n\t\t\t\tvar id = result.id;\n\n\t\t\t\tif (id !== 0) {\n\t\t\t\t\tadapter.catalog.deleteAppKey(id);\n\t\t\t\t}\n\n\t\t\t\tresolve();\n\t\t\t});\n\t\t});\n\t}\n\n\t// alias\n\tdeleteKey(dbname) {\n\t\treturn this.deleteDatabase(dbname);\n\t}\n\n\t/**\n\t * Removes all database partitions and pages with the base filename passed in.\n\t * This utility method does not (yet) guarantee async deletions will be completed before returning\n\t *\n\t * @param {string} dbname - the base filename which container, partitions, or pages are derived\n\t * @memberof LokiIndexedAdapter\n\t */\n\tdeleteDatabasePartitions(dbname) {\n\t\tvar self = this;\n\t\tthis.getDatabaseList(function(result) {\n\t\t\tresult.forEach(function(str) {\n\t\t\t\tif (str.startsWith(dbname)) {\n\t\t\t\t\tself.deleteDatabase(str);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Retrieves object array of catalog entries for current app.\n\t *\n\t * @example\n\t * idbAdapter.getDatabaseList(function(result) {\n\t *   // result is array of string names for that appcontext (\"finance\")\n\t *   result.forEach(function(str) {\n\t *     console.log(str);\n\t *   });\n\t * });\n\t *\n\t * @param {function} callback - should accept array of database names in the catalog for current app.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tgetDatabaseList(callback) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference so dont -need- callback in constructor\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\tadapter.getDatabaseList(callback);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// catalog already initialized\n\t\t// get all keys for current appName, and transpose results so just string array\n\t\tthis.catalog.getAppKeys(appName, function(results) {\n\t\t\tvar names = [];\n\n\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\tnames.push(results[idx].key);\n\t\t\t}\n\n\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\tcallback(names);\n\t\t\t} else {\n\t\t\t\tnames.forEach(function(obj) {\n\t\t\t\t\tconsole.log(obj);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\t// alias\n\tgetKeyList(callback) {\n\t\treturn this.getDatabaseList(callback);\n\t}\n\n\t/**\n\t * Allows retrieval of list of all keys in catalog along with size\n\t *\n\t * @param {function} callback - (Optional) callback to accept result array.\n\t * @memberof LokiIndexedAdapter\n\t */\n\tgetCatalogSummary(callback) {\n\t\tvar appName = this.app;\n\t\tvar adapter = this;\n\n\t\t// lazy open/create db reference\n\t\tif (this.catalog === null || this.catalog.db === null) {\n\t\t\tthis.catalog = new LokiCatalog(function(cat) {\n\t\t\t\tadapter.catalog = cat;\n\n\t\t\t\tadapter.getCatalogSummary(callback);\n\t\t\t});\n\n\t\t\treturn;\n\t\t}\n\n\t\t// catalog already initialized\n\t\t// get all keys for current appName, and transpose results so just string array\n\t\tthis.catalog.getAllKeys(function(results) {\n\t\t\tvar entries = [];\n\t\t\tvar obj,\n\t\t\t\tsize,\n\t\t\t\toapp,\n\t\t\t\tokey,\n\t\t\t\toval;\n\n\t\t\tfor (var idx = 0; idx < results.length; idx++) {\n\t\t\t\tobj = results[idx];\n\t\t\t\toapp = obj.app || '';\n\t\t\t\tokey = obj.key || '';\n\t\t\t\toval = obj.val || '';\n\n\t\t\t\t// app and key are composited into an appkey column so we will mult by 2\n\t\t\t\tsize = oapp.length * 2 + okey.length * 2 + oval.length + 1;\n\n\t\t\t\tentries.push({\n\t\t\t\t\t\"app\": obj.app,\n\t\t\t\t\t\"key\": obj.key,\n\t\t\t\t\t\"size\": size\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\tcallback(entries);\n\t\t\t} else {\n\t\t\t\tentries.forEach(function(obj) {\n\t\t\t\t\tconsole.log(obj);\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * LokiCatalog - underlying App/Key/Value catalog persistence\n *    This non-interface class implements the actual persistence.\n *    Used by the IndexedAdapter class.\n */\nclass LokiCatalog {\n\tconstructor(callback) {\n\t\tthis.db = null;\n\t\tthis.initializeLokiCatalog(callback);\n\t}\n\n\tinitializeLokiCatalog(callback) {\n\t\tvar openRequest = indexedDB.open(\"LokiCatalog\", 1);\n\t\tvar cat = this;\n\n\t\t// If database doesn't exist yet or its version is lower than our version specified above (2nd param in line above)\n\t\topenRequest.onupgradeneeded = function(e) {\n\t\t\tvar thisDB = e.target.result;\n\t\t\tif (thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\tthisDB.deleteObjectStore(\"LokiAKV\");\n\t\t\t}\n\n\t\t\tif (!thisDB.objectStoreNames.contains(\"LokiAKV\")) {\n\t\t\t\tvar objectStore = thisDB.createObjectStore(\"LokiAKV\", {\n\t\t\t\t\tkeyPath: \"id\",\n\t\t\t\t\tautoIncrement: true\n\t\t\t\t});\n\t\t\t\tobjectStore.createIndex(\"app\", \"app\", {\n\t\t\t\t\tunique: false\n\t\t\t\t});\n\t\t\t\tobjectStore.createIndex(\"key\", \"key\", {\n\t\t\t\t\tunique: false\n\t\t\t\t});\n\t\t\t\t// hack to simulate composite key since overhead is low (main size should be in val field)\n\t\t\t\t// user (me) required to duplicate the app and key into comma delimited appkey field off object\n\t\t\t\t// This will allow retrieving single record with that composite key as well as\n\t\t\t\t// still supporting opening cursors on app or key alone\n\t\t\t\tobjectStore.createIndex(\"appkey\", \"appkey\", {\n\t\t\t\t\tunique: true\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\topenRequest.onsuccess = function(e) {\n\t\t\tcat.db = e.target.result;\n\n\t\t\tif (typeof(callback) === \"function\") callback(cat);\n\t\t};\n\n\t\topenRequest.onerror = function(e) {\n\t\t\tthrow e;\n\t\t};\n\t}\n\n\tgetAppKey(app, key, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"appkey\");\n\t\tvar appkey = app + \",\" + key;\n\t\tvar request = index.get(appkey);\n\n\t\trequest.onsuccess = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar lres = e.target.result;\n\n\t\t\t\tif (lres === null || typeof(lres) === \"undefined\") {\n\t\t\t\t\tlres = {\n\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(lres);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(lres);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback({\n\t\t\t\t\t\tid: 0,\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t}\n\n\tgetAppKeyById(id, callback, data) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar request = store.get(id);\n\n\t\trequest.onsuccess = (function(data, usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(e.target.result, data);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log(e.target.result);\n\t\t\t\t}\n\t\t\t};\n\t\t})(data, callback);\n\t}\n\n\tsetAppKey(app, key, val, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"appkey\");\n\t\tvar appkey = app + \",\" + key;\n\t\tvar request = index.get(appkey);\n\n\t\t// first try to retrieve an existing object by that key\n\t\t// need to do this because to update an object you need to have id in object, otherwise it will append id with new autocounter and clash the unique index appkey\n\t\trequest.onsuccess = function(e) {\n\t\t\tvar res = e.target.result;\n\n\t\t\tif (res === null || res === undefined) {\n\t\t\t\tres = {\n\t\t\t\t\tapp: app,\n\t\t\t\t\tkey: key,\n\t\t\t\t\tappkey: app + \",\" + key,\n\t\t\t\t\tval: val\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tres.val = val;\n\t\t\t}\n\n\t\t\tvar requestPut = store.put(res);\n\n\t\t\trequestPut.onerror = (function(usercallback) {\n\t\t\t\treturn function(e) {\n\t\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (set) onerror\");\n\t\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t})(callback);\n\n\t\t\trequestPut.onsuccess = (function(usercallback) {\n\t\t\t\treturn function(e) {\n\t\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\t\tusercallback({\n\t\t\t\t\t\t\tsuccess: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t})(callback);\n\t\t};\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback({\n\t\t\t\t\t\tsuccess: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.setAppKey (get) onerror\");\n\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t}\n\n\tdeleteAppKey(id, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readwrite\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar request = store.delete(id);\n\n\t\trequest.onsuccess = (function(usercallback) {\n\t\t\treturn function(evt) {\n\t\t\t\tif (typeof(usercallback) === \"function\") usercallback({\n\t\t\t\t\tsuccess: true\n\t\t\t\t});\n\t\t\t};\n\t\t})(callback);\n\n\t\trequest.onerror = (function(usercallback) {\n\t\t\treturn function(evt) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(false);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.deleteAppKey raised onerror\");\n\t\t\t\t\tconsole.error(request.error);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\t}\n\n\tgetAppKeys(app, callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar index = store.index(\"app\");\n\n\t\t// We want cursor to all values matching our (single) app param\n\t\tvar singleKeyRange = IDBKeyRange.only(app);\n\n\t\t// To use one of the key ranges, pass it in as the first argument of openCursor()/openKeyCursor()\n\t\tvar cursor = index.openCursor(singleKeyRange);\n\n\t\t// cursor internally, pushing results into this.data[] and return\n\t\t// this.data[] when done (similar to service)\n\t\tvar localdata = [];\n\n\t\tcursor.onsuccess = (function(data, callback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar cursor = e.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tvar currObject = cursor.value;\n\n\t\t\t\t\tdata.push(currObject);\n\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})(localdata, callback);\n\n\t\tcursor.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") {\n\t\t\t\t\tusercallback(null);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\"LokiCatalog.getAppKeys raised onerror\");\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t}\n\t\t\t};\n\t\t})(callback);\n\n\t}\n\n\t// Hide \"cursoring\" and return array of { id: id, key: key }\n\tgetAllKeys(callback) {\n\t\tvar transaction = this.db.transaction([\"LokiAKV\"], \"readonly\");\n\t\tvar store = transaction.objectStore(\"LokiAKV\");\n\t\tvar cursor = store.openCursor();\n\n\t\tvar localdata = [];\n\n\t\tcursor.onsuccess = (function(data, callback) {\n\t\t\treturn function(e) {\n\t\t\t\tvar cursor = e.target.result;\n\t\t\t\tif (cursor) {\n\t\t\t\t\tvar currObject = cursor.value;\n\n\t\t\t\t\tdata.push(currObject);\n\n\t\t\t\t\tcursor.continue();\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof(callback) === \"function\") {\n\t\t\t\t\t\tcallback(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log(data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t})(localdata, callback);\n\n\t\tcursor.onerror = (function(usercallback) {\n\t\t\treturn function(e) {\n\t\t\t\tif (typeof(usercallback) === \"function\") usercallback(null);\n\t\t\t};\n\t\t})(callback);\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/loki-indexed-adapter.js\n// module id = 9\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 10\n// module chunks = 0","import {LokiEventEmitter} from './event_emitter';\nimport {Resultset} from './resultset';\n\n/*\n'LokiEventEmitter' is not defined        no-undef\n'Resultset' is not defined               no-undef\n\napplySortCriteria -> like Resultset::compoundsort\n\nqueueRebuildEvent -> Promise?\n\n */\n\n/**\n * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.\n *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it\n *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)\n *\n * @example\n * var mydv = mycollection.addDynamicView('test');  // default is non-persistent\n * mydv.applyFind({ 'doors' : 4 });\n * mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });\n * var results = mydv.data();\n *\n * @constructor DynamicView\n * @implements LokiEventEmitter\n * @param {Collection} collection - A reference to the collection to work against\n * @param {string} name - The name of this dynamic view\n * @param {object=} options - (Optional) Pass in object with 'persistent' and/or 'sortPriority' options.\n * @param {boolean} options.persistent - indicates if view is to main internal results array in 'resultdata'\n * @param {string} options.sortPriority - 'passive' (sorts performed on call to data) or 'active' (after updates)\n * @param {number} options.minRebuildInterval - minimum rebuild interval (need clarification to docs here)\n * @see {@link Collection#addDynamicView} to construct instances of DynamicView\n */\nexport class DynamicView extends LokiEventEmitter {\n\n\tconstructor(collection, name, options) {\n\t\tsuper();\n\t\tthis.collection = collection;\n\t\tthis.name = name;\n\t\tthis.rebuildPending = false;\n\t\tthis.options = options || {};\n\n\t\tif (!this.options.hasOwnProperty('persistent')) {\n\t\t\tthis.options.persistent = false;\n\t\t}\n\n\t\t// 'persistentSortPriority':\n\t\t// 'passive' will defer the sort phase until they call data(). (most efficient overall)\n\t\t// 'active' will sort async whenever next idle. (prioritizes read speeds)\n\t\tif (!this.options.hasOwnProperty('sortPriority')) {\n\t\t\tthis.options.sortPriority = 'passive';\n\t\t}\n\n\t\tif (!this.options.hasOwnProperty('minRebuildInterval')) {\n\t\t\tthis.options.minRebuildInterval = 1;\n\t\t}\n\n\t\tthis.resultset = new Resultset(collection);\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = false;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\t// for now just have 1 event for when we finally rebuilt lazy view\n\t\t// once we refactor transactions, i will tie in certain transactional events\n\n\t\tthis.events = {\n\t\t\t'rebuild': []\n\t\t};\n\t}\n\n\t/**\n\t * rematerialize() - intended for use immediately after deserialization (loading)\n\t *    This will clear out and reapply filterPipeline ops, recreating the view.\n\t *    Since where filters do not persist correctly, this method allows\n\t *    restoring the view to state where user can re-apply those where filters.\n\t *\n\t * @param {Object=} options - (Optional) allows specification of 'removeWhereFilters' option\n\t * @returns {DynamicView} This dynamic view for further chained ops.\n\t * @memberof DynamicView\n\t * @fires DynamicView.rebuild\n\t */\n\trematerialize(options) {\n\t\tvar fpl,\n\t\t\tfpi,\n\t\t\tidx;\n\n\t\toptions = options || {};\n\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\t\tthis.resultset = new Resultset(this.collection);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.sortDirty = true;\n\t\t}\n\n\t\tif (options.hasOwnProperty('removeWhereFilters')) {\n\t\t\t// for each view see if it had any where filters applied... since they don't\n\t\t\t// serialize those functions lets remove those invalid filters\n\t\t\tfpl = this.filterPipeline.length;\n\t\t\tfpi = fpl;\n\t\t\twhile (fpi--) {\n\t\t\t\tif (this.filterPipeline[fpi].type === 'where') {\n\t\t\t\t\tif (fpi !== this.filterPipeline.length - 1) {\n\t\t\t\t\t\tthis.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.filterPipeline.length--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// back up old filter pipeline, clear filter pipeline, and reapply pipeline ops\n\t\tvar ofp = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\t// now re-apply 'find' filterPipeline ops\n\t\tfpl = ofp.length;\n\t\tfor (idx = 0; idx < fpl; idx++) {\n\t\t\tthis.applyFind(ofp[idx].val);\n\t\t}\n\n\t\t// during creation of unit tests, i will remove this forced refresh and leave lazy\n\t\tthis.data();\n\n\t\t// emit rebuild event in case user wants to be notified\n\t\tthis.emit('rebuild', this);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * branchResultset() - Makes a copy of the internal resultset for branched queries.\n\t *    Unlike this dynamic view, the branched resultset will not be 'live' updated,\n\t *    so your branched query should be immediately resolved and not held for future evaluation.\n\t *\n\t * @param {(string|array=)} transform - Optional name of collection transform, or an array of transform steps\n\t * @param {object=} parameters - optional parameters (if optional transform requires them)\n\t * @returns {Resultset} A copy of the internal resultset for branched queries.\n\t * @memberof DynamicView\n\t */\n\tbranchResultset(transform, parameters) {\n\t\tvar rs = this.resultset.branch();\n\n\t\tif (typeof transform === 'undefined') {\n\t\t\treturn rs;\n\t\t}\n\n\t\treturn rs.transform(transform, parameters);\n\t}\n\n\t/**\n\t * toJSON() - Override of toJSON to avoid circular references\n\t *\n\t */\n\ttoJSON() {\n\t\tvar copy = new DynamicView(this.collection, this.name, this.options);\n\n\t\tcopy.resultset = this.resultset;\n\t\tcopy.resultdata = []; // let's not save data (copy) to minimize size\n\t\tcopy.resultsdirty = true;\n\t\tcopy.filterPipeline = this.filterPipeline;\n\t\tcopy.sortFunction = this.sortFunction;\n\t\tcopy.sortCriteria = this.sortCriteria;\n\t\tcopy.sortDirty = this.sortDirty;\n\n\t\t// avoid circular reference, reapply in db.loadJSON()\n\t\tcopy.collection = null;\n\n\t\treturn copy;\n\t}\n\n\t/**\n\t * removeFilters() - Used to clear pipeline and reset dynamic view to initial state.\n\t *     Existing options should be retained.\n\t * @param {object=} options - configure removeFilter behavior\n\t * @param {boolean=} options.queueSortPhase - (default: false) if true we will async rebuild view (maybe set default to true in future?)\n\t * @memberof DynamicView\n\t */\n\tremoveFilters(options) {\n\t\toptions = options || {};\n\n\t\tthis.rebuildPending = false;\n\t\tthis.resultset.reset();\n\t\tthis.resultdata = [];\n\t\tthis.resultsdirty = true;\n\n\t\tthis.cachedresultset = null;\n\n\t\t// keep ordered filter pipeline\n\t\tthis.filterPipeline = [];\n\n\t\t// sorting member variables\n\t\t// we only support one active search, applied using applySort() or applySimpleSort()\n\t\tthis.sortFunction = null;\n\t\tthis.sortCriteria = null;\n\t\tthis.sortDirty = false;\n\n\t\tif (options.queueSortPhase === true) {\n\t\t\tthis.queueSortPhase();\n\t\t}\n\t}\n\n\t/**\n\t * applySort() - Used to apply a sort to the dynamic view\n\t * @example\n\t * dv.applySort(function(obj1, obj2) {\n\t *   if (obj1.name === obj2.name) return 0;\n\t *   if (obj1.name > obj2.name) return 1;\n\t *   if (obj1.name < obj2.name) return -1;\n\t * });\n\t *\n\t * @param {function} comparefun - a javascript compare function used for sorting\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySort(comparefun) {\n\t\tthis.sortFunction = comparefun;\n\t\tthis.sortCriteria = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applySimpleSort() - Used to specify a property used for view translation.\n\t * @example\n\t * dv.applySimpleSort(\"name\");\n\t *\n\t * @param {string} propname - Name of property by which to sort.\n\t * @param {boolean=} isdesc - (Optional) If true, the sort will be in descending order.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplySimpleSort(propname, isdesc) {\n\t\tthis.sortCriteria = [\n\t\t\t[propname, isdesc || false]\n\t\t];\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applySortCriteria() - Allows sorting a resultset based on multiple columns.\n\t * @example\n\t * // to sort by age and then name (both ascending)\n\t * dv.applySortCriteria(['age', 'name']);\n\t * // to sort by age (ascending) and then by name (descending)\n\t * dv.applySortCriteria(['age', ['name', true]);\n\t * // to sort by age (descending) and then by name (descending)\n\t * dv.applySortCriteria(['age', true], ['name', true]);\n\t *\n\t * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order\n\t * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.\n\t * @memberof DynamicView\n\t */\n\tapplySortCriteria(criteria) {\n\t\tthis.sortCriteria = criteria;\n\t\tthis.sortFunction = null;\n\n\t\tthis.queueSortPhase();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * startTransaction() - marks the beginning of a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tstartTransaction() {\n\t\tthis.cachedresultset = this.resultset.copy();\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * commit() - commits a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\tcommit() {\n\t\tthis.cachedresultset = null;\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * rollback() - rolls back a transaction.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\trollback() {\n\t\tthis.resultset = this.cachedresultset;\n\n\t\tif (this.options.persistent) {\n\t\t\t// for now just rebuild the persistent dynamic view data in this worst case scenario\n\t\t\t// (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.\n\t\t\tthis.resultdata = this.resultset.data();\n\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\n\t/**\n\t * Implementation detail.\n\t * _indexOfFilterWithId() - Find the index of a filter in the pipeline, by that filter's ID.\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter.\n\t * @returns {number}: index of the referenced filter in the pipeline; -1 if not found.\n\t */\n\t_indexOfFilterWithId(uid) {\n\t\tif (typeof uid === 'string' || typeof uid === 'number') {\n\t\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx += 1) {\n\t\t\t\tif (uid === this.filterPipeline[idx].uid) {\n\t\t\t\t\treturn idx;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Implementation detail.\n\t * _addFilter() - Add the filter object to the end of view's filter pipeline and apply the filter to the resultset.\n\t *\n\t * @param {object} filter - The filter object. Refer to applyFilter() for extra details.\n\t */\n\t_addFilter(filter) {\n\t\tthis.filterPipeline.push(filter);\n\t\tthis.resultset[filter.type](filter.val);\n\t}\n\n\t/**\n\t * reapplyFilters() - Reapply all the filters in the current pipeline.\n\t *\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t */\n\treapplyFilters() {\n\t\tthis.resultset.reset();\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tvar filters = this.filterPipeline;\n\t\tthis.filterPipeline = [];\n\n\t\tfor (var idx = 0, len = filters.length; idx < len; idx += 1) {\n\t\t\tthis._addFilter(filters[idx]);\n\t\t}\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyFilter() - Adds or updates a filter in the DynamicView filter pipeline\n\t *\n\t * @param {object} filter - A filter object to add to the pipeline.\n\t *    The object is in the format { 'type': filter_type, 'val', filter_param, 'uid', optional_filter_id }\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFilter(filter) {\n\t\tvar idx = this._indexOfFilterWithId(filter.uid);\n\t\tif (idx >= 0) {\n\t\t\tthis.filterPipeline[idx] = filter;\n\t\t\treturn this.reapplyFilters();\n\t\t}\n\n\t\tthis.cachedresultset = null;\n\t\tif (this.options.persistent) {\n\t\t\tthis.resultdata = [];\n\t\t\tthis.resultsdirty = true;\n\t\t}\n\n\t\tthis._addFilter(filter);\n\n\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\tthis.queueSortPhase();\n\t\t} else {\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyFind() - Adds or updates a mongo-style query option in the DynamicView filter pipeline\n\t *\n\t * @param {object} query - A mongo-style query object to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyFind(query, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'find',\n\t\t\tval: query,\n\t\t\tuid: uid\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * applyWhere() - Adds or updates a javascript filter function in the DynamicView filter pipeline\n\t *\n\t * @param {function} fun - A javascript filter function to apply to pipeline\n\t * @param {(string|number)=} uid - Optional: The unique ID of this filter, to reference it in the future.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tapplyWhere(fun, uid) {\n\t\tthis.applyFilter({\n\t\t\ttype: 'where',\n\t\t\tval: fun,\n\t\t\tuid: uid\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * removeFilter() - Remove the specified filter from the DynamicView filter pipeline\n\t *\n\t * @param {(string|number)} uid - The unique ID of the filter to be removed.\n\t * @returns {DynamicView} this DynamicView object, for further chain ops.\n\t * @memberof DynamicView\n\t */\n\tremoveFilter(uid) {\n\t\tvar idx = this._indexOfFilterWithId(uid);\n\t\tif (idx < 0) {\n\t\t\tthrow new Error(\"Dynamic view does not contain a filter with ID: \" + uid);\n\t\t}\n\n\t\tthis.filterPipeline.splice(idx, 1);\n\t\tthis.reapplyFilters();\n\t\treturn this;\n\t}\n\n\t/**\n\t * count() - returns the number of documents representing the current DynamicView contents.\n\t *\n\t * @returns {number} The number of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tcount() {\n\t\t// in order to be accurate we will pay the minimum cost (and not alter dv state management)\n\t\t// recurring resultset data resolutions should know internally its already up to date.\n\t\t// for persistent data this will not update resultdata nor fire rebuild event.\n\t\tif (this.resultsdirty) {\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t}\n\n\t\treturn this.resultset.count();\n\t}\n\n\t/**\n\t * data() - resolves and pending filtering and sorting, then returns document array as result.\n\t *\n\t * @returns {array} An array of documents representing the current DynamicView contents.\n\t * @memberof DynamicView\n\t */\n\tdata() {\n\t\t// using final sort phase as 'catch all' for a few use cases which require full rebuild\n\t\tif (this.sortDirty || this.resultsdirty) {\n\t\t\tthis.performSortPhase({\n\t\t\t\tsuppressRebuildEvent: true\n\t\t\t});\n\t\t}\n\t\treturn (this.options.persistent) ? (this.resultdata) : (this.resultset.data());\n\t}\n\n\t/**\n\t * queueRebuildEvent() - When the view is not sorted we may still wish to be notified of rebuild events.\n\t *     This event will throttle and queue a single rebuild event when batches of updates affect the view.\n\t */\n\tqueueRebuildEvent() {\n\t\tif (this.rebuildPending) {\n\t\t\treturn;\n\t\t}\n\t\tthis.rebuildPending = true;\n\n\t\tvar self = this;\n\t\tsetTimeout(function() {\n\t\t\tif (self.rebuildPending) {\n\t\t\t\tself.rebuildPending = false;\n\t\t\t\tself.emit('rebuild', self);\n\t\t\t}\n\t\t}, this.options.minRebuildInterval);\n\t}\n\n\t/**\n\t * queueSortPhase : If the view is sorted we will throttle sorting to either :\n\t *    (1) passive - when the user calls data(), or\n\t *    (2) active - once they stop updating and yield js thread control\n\t */\n\tqueueSortPhase() {\n\t\t// already queued? exit without queuing again\n\t\tif (this.sortDirty) {\n\t\t\treturn;\n\t\t}\n\t\tthis.sortDirty = true;\n\n\t\tvar self = this;\n\t\tif (this.options.sortPriority === \"active\") {\n\t\t\t// active sorting... once they are done and yield js thread, run async performSortPhase()\n\t\t\tsetTimeout(function() {\n\t\t\t\tself.performSortPhase();\n\t\t\t}, this.options.minRebuildInterval);\n\t\t} else {\n\t\t\t// must be passive sorting... since not calling performSortPhase (until data call), lets use queueRebuildEvent to\n\t\t\t// potentially notify user that data has changed.\n\t\t\tthis.queueRebuildEvent();\n\t\t}\n\t}\n\n\t/**\n\t * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)\n\t *\n\t */\n\tperformSortPhase(options) {\n\t\t// async call to this may have been pre-empted by synchronous call to data before async could fire\n\t\tif (!this.sortDirty && !this.resultsdirty) {\n\t\t\treturn;\n\t\t}\n\n\t\toptions = options || {};\n\n\t\tif (this.sortDirty) {\n\t\t\tif (this.sortFunction) {\n\t\t\t\tthis.resultset.sort(this.sortFunction);\n\t\t\t} else if (this.sortCriteria) {\n\t\t\t\tthis.resultset.compoundsort(this.sortCriteria);\n\t\t\t}\n\n\t\t\tthis.sortDirty = false;\n\t\t}\n\n\t\tif (this.options.persistent) {\n\t\t\t// persistent view, rebuild local resultdata array\n\t\t\tthis.resultdata = this.resultset.data();\n\t\t\tthis.resultsdirty = false;\n\t\t}\n\n\t\tif (!options.suppressRebuildEvent) {\n\t\t\tthis.emit('rebuild', this);\n\t\t}\n\t}\n\n\t/**\n\t * evaluateDocument() - internal method for (re)evaluating document inclusion.\n\t *    Called by : collection.insert() and collection.update().\n\t *\n\t * @param {int} objIndex - index of document to (re)run through filter pipeline.\n\t * @param {bool} isNew - true if the document was just added to the collection.\n\t */\n\tevaluateDocument(objIndex, isNew) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar ofr = this.resultset.filteredrows;\n\t\tvar oldPos = (isNew) ? (-1) : (ofr.indexOf(+objIndex));\n\t\tvar oldlen = ofr.length;\n\n\t\t// creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;\n\t\t// mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)\n\t\tvar evalResultset = new Resultset(this.collection);\n\t\tevalResultset.filteredrows = [objIndex];\n\t\tevalResultset.filterInitialized = true;\n\t\tvar filter;\n\t\tfor (var idx = 0, len = this.filterPipeline.length; idx < len; idx++) {\n\t\t\tfilter = this.filterPipeline[idx];\n\t\t\tevalResultset[filter.type](filter.val);\n\t\t}\n\n\t\t// not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)\n\t\tvar newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;\n\n\t\t// wasn't in old, shouldn't be now... do nothing\n\t\tif (oldPos === -1 && newPos === -1) return;\n\n\t\t// wasn't in resultset, should be now... add\n\t\tif (oldPos === -1 && newPos !== -1) {\n\t\t\tofr.push(objIndex);\n\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata.push(this.collection.data[objIndex]);\n\t\t\t}\n\n\t\t\t// need to re-sort to sort new document\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, shouldn't be now... delete\n\t\tif (oldPos !== -1 && newPos === -1) {\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr.splice(oldPos, 1);\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.splice(oldPos, 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t// was in resultset, should still be now... (update persistent only?)\n\t\tif (oldPos !== -1 && newPos !== -1) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\t// in case document changed, replace persistent view data with the latest collection.data document\n\t\t\t\tthis.resultdata[oldPos] = this.collection.data[objIndex];\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/**\n\t * removeDocument() - internal function called on collection.delete()\n\t */\n\tremoveDocument(objIndex) {\n\t\t// if no filter applied yet, the result 'set' should remain 'everything'\n\t\tif (!this.resultset.filterInitialized) {\n\t\t\tif (this.options.persistent) {\n\t\t\t\tthis.resultdata = this.resultset.data();\n\t\t\t}\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar ofr = this.resultset.filteredrows;\n\t\tvar oldPos = ofr.indexOf(+objIndex);\n\t\tvar oldlen = ofr.length;\n\t\tvar idx;\n\n\t\tif (oldPos !== -1) {\n\t\t\t// if not last row in resultdata, swap last to hole and truncate last row\n\t\t\tif (oldPos < oldlen - 1) {\n\t\t\t\tofr[oldPos] = ofr[oldlen - 1];\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata[oldPos] = this.resultdata[oldlen - 1];\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// last row, so just truncate last row\n\t\t\telse {\n\t\t\t\tofr.length = oldlen - 1;\n\n\t\t\t\tif (this.options.persistent) {\n\t\t\t\t\tthis.resultdata.length = oldlen - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// in case changes to data altered a sort column\n\t\t\tif (this.sortFunction || this.sortCriteria) {\n\t\t\t\tthis.queueSortPhase();\n\t\t\t} else {\n\t\t\t\tthis.queueRebuildEvent();\n\t\t\t}\n\t\t}\n\n\t\t// since we are using filteredrows to store data array positions\n\t\t// if they remove a document (whether in our view or not),\n\t\t// we need to adjust array positions -1 for all document array references after that position\n\t\toldlen = ofr.length;\n\t\tfor (idx = 0; idx < oldlen; idx++) {\n\t\t\tif (ofr[idx] > objIndex) {\n\t\t\t\tofr[idx]--;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * mapReduce() - data transformation via user supplied functions\n\t *\n\t * @param {function} mapFunction - this function accepts a single document for you to transform and return\n\t * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value\n\t * @returns The output of your reduceFunction\n\t * @memberof DynamicView\n\t */\n\tmapReduce(mapFunction, reduceFunction) {\n\t\ttry {\n\t\t\treturn reduceFunction(this.data().map(mapFunction));\n\t\t} catch (err) {\n\t\t\tthrow err;\n\t\t}\n\t}\n\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/dynamic_view.js\n// module id = 11\n// module chunks = 0","export class ExactIndex {\n\n\tconstructor(exactField) {\n\t\tthis.index = {};\n\t\tthis.field = exactField;\n\t}\n\n\t// add the value you want returned to the key in the index\n\tset(key, val) {\n\t\tif (this.index[key]) {\n\t\t\tthis.index[key].push(val);\n\t\t} else {\n\t\t\tthis.index[key] = [val];\n\t\t}\n\t\tconsole.log(\"?\");\n\t}\n\n\t// remove the value from the index, if the value was the last one, remove the key\n\tremove(key, val) {\n\t\tvar idxSet = this.index[key];\n\t\tfor (var i in idxSet) {\n\t\t\tif (idxSet[i] == val) {\n\t\t\t\tidxSet.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\tif (idxSet.length < 1) {\n\t\t\tthis.index[key] = undefined;\n\t\t}\n\t}\n\n\t// get the values related to the key, could be more than one\n\tget(key) {\n\t\tconsole.log(\"!\");\n\t\treturn this.index[key];\n\t}\n\n\t// clear will zap the index\n\tclear(key) {\n\t\tthis.index = {};\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/exact_index.js\n// module id = 12\n// module chunks = 0","export class UniqueIndex {\n\n\tconstructor(uniqueField) {\n\t\tthis.field = uniqueField;\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t}\n\n\tset(obj) {\n\t\tvar fieldValue = obj[this.field];\n\t\tif (fieldValue !== null && typeof(fieldValue) !== 'undefined') {\n\t\t\tif (this.keyMap[fieldValue]) {\n\t\t\t\tthrow new Error('Duplicate key for property ' + this.field + ': ' + fieldValue);\n\t\t\t} else {\n\t\t\t\tthis.keyMap[fieldValue] = obj;\n\t\t\t\tthis.lokiMap[obj.$loki] = fieldValue;\n\t\t\t}\n\t\t}\n\t}\n\n\tget(key) {\n\t\treturn this.keyMap[key];\n\t}\n\n\tbyId(id) {\n\t\treturn this.keyMap[this.lokiMap[id]];\n\t}\n\n\t/**\n\t * Updates a document's unique index given an updated object.\n\t * @param  {Object} obj Original document object\n\t * @param  {Object} doc New document object (likely the same as obj)\n\t */\n\tupdate(obj, doc) {\n\t\tif (this.lokiMap[obj.$loki] !== doc[this.field]) {\n\t\t\tvar old = this.lokiMap[obj.$loki];\n\t\t\tthis.set(doc);\n\t\t\t// make the old key fail bool test, while avoiding the use of delete (mem-leak prone)\n\t\t\tthis.keyMap[old] = undefined;\n\t\t} else {\n\t\t\tthis.keyMap[obj[this.field]] = doc;\n\t\t}\n\t}\n\tremove(key) {\n\t\tvar obj = this.keyMap[key];\n\t\tif (obj !== null && typeof obj !== 'undefined') {\n\t\t\tthis.keyMap[key] = undefined;\n\t\t\tthis.lokiMap[obj.$loki] = undefined;\n\t\t} else {\n\t\t\tthrow new Error('Key is not in unique index: ' + this.field);\n\t\t}\n\t}\n\tclear() {\n\t\tthis.keyMap = {};\n\t\tthis.lokiMap = {};\n\t}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/core/unique_index.js\n// module id = 13\n// module chunks = 0"],"sourceRoot":""}